<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker容器</title>
    <url>/docker/docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><h3 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h3><p>&emsp;&emsp;容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统和跑在上面的应用。</p>
<h3 id="新建启动容器"><a href="#新建启动容器" class="headerlink" title="新建启动容器"></a>新建启动容器</h3><p>&emsp;&emsp;启动容器的主要命令是docker run，下面的命令输出一个“hello world”，之后终止容器</p>
<a id="more"></a>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面命令启动一个bash终端，允许用户进行交互</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;命令中的-t 表示让docker分配一个伪终端并绑定到容器的标准输入上，-i 则表示让容器的标准输入持续打开</p>
<p>&emsp;&emsp;利用docker run 来创建容器时，docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在从公有仓库进行下载；</li>
<li>利用镜像创建并启动一个容器；</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一个可读写层；</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</li>
<li>从地址池配置一个IP地址给容器；</li>
<li>执行用户指定的应用程序；</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已经终止的容器"><a href="#启动已经终止的容器" class="headerlink" title="启动已经终止的容器"></a>启动已经终止的容器</h3><p>可以使用docker start 命令，启动一个已经终止的容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker start 容器ID</span><br></pre></td></tr></table></figure>

<h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><p>如果需要让docker 后台运行，可以通过添加-d 参数来启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 /bin/sh -c <span class="string">"while true; do ech</span></span><br><span class="line"><span class="string">o hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;-d参数启动后会返回一个唯一的id，可以通过docker ps 查看容器信息；要获取容器输入信息，可以通过docker logs命令进行查看</p>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>&emsp;&emsp;可以使用docker stop命令来终止一个已经运行的容器，此外，当docker 容器中指定的应用结束时，容器也自动终止。当docker 启动终端时，可以通过exit或ctrl+d来退出终端，容器立刻终止；</p>
<p>终止后的容器可以通过docker ps -a 进行查看；</p>
<p>docker restart命令会将一个运行态的容器终止，然后重新启动它；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">$ docker stop 容器ID</span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>attach 命令</p>
<p>&emsp;&emsp;docker attach命令是docker自带的命令，命令后面接容器，可以进入到该容器，打开终端；但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p>
<p>nsenter命令</p>
<p>&emsp;&emsp;nsenter 工具在 util-linux 包2.23版本后包含。 如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp; curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz | tar -zxf-; <span class="built_in">cd</span> util-linux-2.24;</span><br><span class="line">$ ./configure --without-ncurses</span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>
<p>为了连接到容器，需要找到容器的第一个进程的pid,可以通过下面命令获取；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PID=$(docker inspect --format <span class="string">"&#123;&#123; .State.Pid &#125;&#125;"</span> &lt;container&gt;)</span><br></pre></td></tr></table></figure>
<p>通过这个pid可以连接到这个容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nsenter --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure>
<h4 id="完整的demo"><a href="#完整的demo" class="headerlink" title="完整的demo"></a>完整的demo</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu</span><br><span class="line"><span class="comment"># 返回的容器id</span></span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">243c32535da7 ubuntu:latest <span class="string">"/bin/bash"</span> 18 seconds ago Up 17 seconds nostalgic_hypatia</span><br><span class="line">$ PID=$(docker-pid 243c32535da7)</span><br><span class="line">10981</span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid</span><br><span class="line">root@243c32535da7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用docker export 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREA</span><br><span class="line">TED STATUS PORTS NA</span><br><span class="line">MES</span><br><span class="line">7691a814370e ubuntu:14.04 <span class="string">"/bin/bash"</span> 36 h</span><br><span class="line">ours ago Exited (0) 21 hours ago te</span><br><span class="line">st</span><br><span class="line">$ sudo docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用docker import 命令从容器快照文件中再导入为镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu v1.0 9d37a6082e97 Abou</span><br><span class="line">t a minute ago 171.3 MB</span><br></pre></td></tr></table></figure>
<p>也可以通过指定的url或目录来导入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容<br>器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状<br>态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入<br>时可以重新指定标签等元数据信息。</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用docker rm 来删除一个处于终止状态的容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>如果要删除一个正在运行的容器，可以添加 -f 参数，docker 会发送SIGKILL信号给容器。</p>
<h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>使用命令 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">docker rm <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span> -<span class="params">q</span>)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像</title>
    <url>/docker/docker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>&emsp;&emsp;镜像是docker的三大组件之一，docker运行容器需要本地存在对应的镜像，如果镜像不存在，docker会从镜像仓库下载，默认是从docker hub 公共注册服务器的仓库中下载。可以通过 docker pull 命令从仓库中获取需要的镜像；</p>
<a id="more"></a>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取Ubuntu12.04镜像</span></span><br><span class="line">1 $ sudo docker pull ubuntu:12.04</span><br><span class="line">2 Pulling repository ubuntu</span><br><span class="line">3 ab8e2728644c: Pulling dependent layers</span><br><span class="line">4 511136ea3c5a: Download complete</span><br><span class="line">5 5f0ffaa9455e: Download complete</span><br><span class="line">6 a300658979be: Download complete</span><br><span class="line">7 904483ae0c30: Download complete</span><br><span class="line">8 ffdaafd1ca50: Download complete</span><br><span class="line">9 d047ae21eeaf: Download complete</span><br></pre></td></tr></table></figure>
<p>下载过程中会输出获取每一层镜像的信息<br>该命令相当于</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull</span><br><span class="line">registry.hub.docker.com/ubuntu:12.04</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果官方注册服务器下载比较慢的时候，可以选择从其他仓库进行下载，从其他仓库下载需要指定完整的仓库注册服务器的地址；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 $ sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</span><br><span class="line">2 Pulling dl.dockerpool.com:5000/ubuntu</span><br><span class="line">3 ab8e2728644c: Pulling dependent layers</span><br><span class="line">4 511136ea3c5a: Download complete</span><br><span class="line">5 5f0ffaa9455e: Download complete</span><br><span class="line">6 a300658979be: Download complete</span><br><span class="line">7 904483ae0c30: Download complete</span><br><span class="line">8 ffdaafd1ca50: Download complete</span><br><span class="line">9 d047ae21eeaf: Download complete</span><br></pre></td></tr></table></figure>
<p>下载镜像完成后，就可以使用镜像了。</p>
<h3 id="使用-docker-images-列出本地所有镜像"><a href="#使用-docker-images-列出本地所有镜像" class="headerlink" title="使用 docker images 列出本地所有镜像"></a>使用 docker images 列出本地所有镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              14.04               578c3e61a98c        3 weeks ago         223MB</span><br><span class="line">ubuntu              latest              113a43faa138        3 weeks ago         81.2MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        2 months ago        1.85kB</span><br><span class="line">ubuntu              12.04               5b117edd0b76        14 months ago       104MB</span><br></pre></td></tr></table></figure>
<p>可以看到本地已有镜像的信息，包括镜像名，镜像标记，镜像ID，镜像的创建时间和镜像的大小；</p>
<p>利用创建的镜像来启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -t -i ubuntu:16.04 /bin/bash</span><br><span class="line">root@4af941efaebf:/<span class="comment"># ls</span></span><br></pre></td></tr></table></figure>

<h3 id="可以用-docker-tag-命令来修改镜像的标签"><a href="#可以用-docker-tag-命令来修改镜像的标签" class="headerlink" title="可以用 docker tag 命令来修改镜像的标签"></a>可以用 docker tag 命令来修改镜像的标签</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker tag 5e8b97a2a082 ubuntu16.04:my</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu16.04         latest              5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu16.04         my                  5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              16.04               5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              14.04               578c3e61a98c        3 weeks ago         223MB</span><br><span class="line">ubuntu              latest              113a43faa138        3 weeks ago         81.2MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        2 months ago        1.85kB</span><br><span class="line">ubuntu              12.04               5b117edd0b76        14 months ago       104MB</span><br></pre></td></tr></table></figure>

<h3 id="本地导入镜像"><a href="#本地导入镜像" class="headerlink" title="本地导入镜像"></a>本地导入镜像</h3><p>先下载一个镜像，比如Ubuntu14.04，之后使用以下命令进行导入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04</span><br></pre></td></tr></table></figure>

<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>&emsp;&emsp;用户可以通过docker push 命令来上传自己创建的镜像到仓库中进行共享。例如，用户在Docker Hub上注册后可以推送自己的镜像到仓库中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker push ouruser/sinatra</span><br><span class="line">The push refers to a repository [ouruser/sinatra] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository ouruser/sinatra (3 tags)</span><br></pre></td></tr></table></figure>

<h3 id="存储镜像"><a href="#存储镜像" class="headerlink" title="存储镜像"></a>存储镜像</h3><p>可以使用docker save 命令，导出docker 镜像到本地文件中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure>

<h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load 命令，将本地文件的镜像导入到本地镜像库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker load --input ubuntu_14.04.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sudo docker load &lt; ubuntu_14.04.tar</span><br></pre></td></tr></table></figure>

<h3 id="移除本地镜像"><a href="#移除本地镜像" class="headerlink" title="移除本地镜像"></a>移除本地镜像</h3><p>可以使用docker rmi 命令移除本地镜像；移除镜像前需要先使用<strong>docker rm</strong>命令删除依赖该镜像的所有容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rmi Ubuntu16.04</span><br></pre></td></tr></table></figure>

<h3 id="清理所有未打过标签的本地镜像"><a href="#清理所有未打过标签的本地镜像" class="headerlink" title="清理所有未打过标签的本地镜像"></a>清理所有未打过标签的本地镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rmi $(docker images -q -f <span class="string">"dangling=true"</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sudo docker rmi $(docker images --quiet --filter <span class="string">"dangling=true"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习</title>
    <url>/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/numpy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="numpy学习小结"><a href="#numpy学习小结" class="headerlink" title="numpy学习小结"></a>numpy学习小结</h2><h3 id="安装numpy包"><a href="#安装numpy包" class="headerlink" title="安装numpy包"></a>安装numpy包</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure>
<h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ul>
<li>ndarray.ndim：数组的维数。在Python世界中，维数称之为rank</li>
<li>ndarray.shape：数组的维度。这是一系列数字，长度由数组的维度（ndim）决定。例如：长度为n的一维数组的shape是n。一个n行m列的矩阵的shape是n,m</li>
<li>ndarray.size：数组中所有元素的数量</li>
<li>ndarray.dtype：数组中元素的类型，例如numpy.int32, numpy.int16或者numpy.float64</li>
<li>ndarray.itemsize：数组中每个元素的大小，单位为字节</li>
<li>ndarray.data：存储数组元素的缓冲。通常我们只需要通过下标来访问元素，而不需要访问缓冲</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"a's ndim &#123;&#125;"</span>.format(a.ndim))</span><br><span class="line">print(<span class="string">"a's shape &#123;&#125;"</span>.format(a.shape))</span><br><span class="line">print(<span class="string">"a's size &#123;&#125;"</span>.format(a.size))</span><br><span class="line">print(<span class="string">"a's dtype &#123;&#125;"</span>.format(a.dtype))</span><br><span class="line">print(<span class="string">"a's itemsize &#123;&#125;"</span>.format(a.itemsize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br><span class="line"><span class="comment"># a's ndim 1</span></span><br><span class="line"><span class="comment"># a's shape (3,)</span></span><br><span class="line"><span class="comment"># a's size 3</span></span><br><span class="line"><span class="comment"># a's dtype int32</span></span><br><span class="line"><span class="comment"># a's itemsize 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"b's ndim &#123;&#125;"</span>.format(b.ndim))</span><br><span class="line">print(<span class="string">"b's shape &#123;&#125;"</span>.format(b.shape))</span><br><span class="line">print(<span class="string">"b's size &#123;&#125;"</span>.format(b.size))</span><br><span class="line">print(<span class="string">"b's dtype &#123;&#125;"</span>.format(b.dtype))</span><br><span class="line">print(<span class="string">"b's itemsize &#123;&#125;"</span>.format(b.itemsize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># b's ndim 2</span></span><br><span class="line"><span class="comment"># b's shape (2, 3)</span></span><br><span class="line"><span class="comment"># b's size 6</span></span><br><span class="line"><span class="comment"># b's dtype int32</span></span><br><span class="line"><span class="comment"># b's itemsize 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>zeros：用来创建元素全部是0的数组</li>
<li>ones：用来创建元素全部是1的数组</li>
<li>empty：用来创建未初始化的数据，因此是内容是不确定的</li>
<li>arange：通过指定范围和步长来创建数组</li>
<li>linespace：通过指定范围和元素数量来创建数组</li>
<li>random：用来生成随机数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.zeros((<span class="number">2</span>,<span class="number">3</span>))     </span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># [[0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 0.]]</span></span><br><span class="line"></span><br><span class="line">d = np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># [[1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1.]]</span></span><br><span class="line"></span><br><span class="line">e = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># [[6.23042070e-307 3.56043053e-307 1.37961641e-306]</span></span><br><span class="line"><span class="comment">#  [6.23039015e-307 1.69115935e-306 2.11392033e-307]]</span></span><br><span class="line"></span><br><span class="line">f = np.arange(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0.3</span>)</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment"># [1.  1.3 1.6 1.9]</span></span><br><span class="line"></span><br><span class="line">g = np.linspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># [1.  1.5 2. ]</span></span><br><span class="line"></span><br><span class="line">h = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(h)</span><br><span class="line"><span class="comment"># [[0.64425744 0.4496131  0.88346286]</span></span><br><span class="line"><span class="comment">#  [0.3458989  0.89334331 0.61867948]]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了生成数组之外，当我们已经持有某个数据之后，我们可能会需要根据已有数组来产生一些新的数据结构，这时候我们可以使用下面这些函数：</p>
<ul>
<li>reshape：根据已有数组和指定的shape，生成一个新的数组</li>
<li>vstack：用来将多个数组在垂直（v代表vertical）方向拼接（数组的维度必须匹配）</li>
<li>hstack：用来将多个数组在水平（h代表horizontal）方向拼接（数组的维度必须匹配）</li>
<li>hsplit：用来将数组在水平方向拆分</li>
<li>vsplit：用来将数组在垂直方向拆分</li>
</ul>
<p>&emsp;&emsp;下面我们通过一些例子来进行说明。为了便于测试，我们先创建几个数据。这里我们创建了：</p>
<ul>
<li>zero_line：一行包含3个0的数组</li>
<li>one_column：一列包含3个1的数组</li>
<li>a：一个2行3列的矩阵</li>
<li>b：[11, 20)区间的整数数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zero_line = np.zeros((<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">one_column = np.ones((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [[0. 0. 0.]]</span></span><br><span class="line"><span class="comment"># [[1.]</span></span><br><span class="line"><span class="comment">#  [1.]</span></span><br><span class="line"><span class="comment">#  [1.]]</span></span><br><span class="line"></span><br><span class="line">a = np.array(([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]))</span><br><span class="line">b = np.arange(<span class="number">11</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># [11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组b原先是一个一维数组，现在我们通过reshape方法将其调整成为一个3行3列的矩阵</span></span><br><span class="line"><span class="comment">#这里的第二参数设为-1，表示根据实际情况自动决定。由于原先是9个元素的数组，因此调整后刚好是3X3的矩阵</span></span><br><span class="line">b = b.reshape(<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># [[11 12 13]</span></span><br><span class="line"><span class="comment">#  [14 15 16]</span></span><br><span class="line"><span class="comment">#  [17 18 19]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖直方向拼接数组</span></span><br><span class="line">c = np.vstack((a,b,zero_line))</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># [[ 1.  2.  3.]</span></span><br><span class="line"><span class="comment">#  [ 4.  5.  6.]</span></span><br><span class="line"><span class="comment">#  [11. 12. 13.]</span></span><br><span class="line"><span class="comment">#  [14. 15. 16.]</span></span><br><span class="line"><span class="comment">#  [17. 18. 19.]</span></span><br><span class="line"><span class="comment">#  [ 0.  0.  0.]]</span></span><br><span class="line"></span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [5 6]]</span></span><br><span class="line"><span class="comment"># 水平方向拼接数组</span></span><br><span class="line">d = np.hstack((a,b,one_column))</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># [[ 1.  2. 11. 12. 13.  1.]</span></span><br><span class="line"><span class="comment">#  [ 3.  4. 14. 15. 16.  1.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6. 17. 18. 19.  1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数量进行水平拆分</span></span><br><span class="line">e = np.hsplit(d,<span class="number">3</span>)</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># [array([[1., 2.],</span></span><br><span class="line"><span class="comment">#        [3., 4.],</span></span><br><span class="line"><span class="comment">#        [5., 6.]]), array([[11., 12.],</span></span><br><span class="line"><span class="comment">#        [14., 15.],</span></span><br><span class="line"><span class="comment">#        [17., 18.]]), array([[13.,  1.],</span></span><br><span class="line"><span class="comment">#        [16.,  1.],</span></span><br><span class="line"><span class="comment">#        [19.,  1.]])]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定列数进行水平拆分</span></span><br><span class="line">f = np.hsplit(d,(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment"># [array([[1.],</span></span><br><span class="line"><span class="comment">#        [3.],</span></span><br><span class="line"><span class="comment">#        [5.]]), array([[ 2., 11.],</span></span><br><span class="line"><span class="comment">#        [ 4., 14.],</span></span><br><span class="line"><span class="comment">#        [ 6., 17.]]), array([[12., 13.,  1.],</span></span><br><span class="line"><span class="comment">#        [15., 16.,  1.],</span></span><br><span class="line"><span class="comment">#        [18., 19.,  1.]])]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖直拆分</span></span><br><span class="line">g = np.vsplit(d,<span class="number">3</span>)</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># [array([[ 1.,  2., 11., 12., 13.,  1.]]), array([[ 3.,  4., 14., 15., 16.,  1.]]), array([[ 5.,  6., 17., 18., 19.,  1.]])]</span></span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = np.arange(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">print(base_data)</span><br><span class="line">print(base_data[<span class="number">10</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117</span></span><br><span class="line"><span class="string"> 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135</span></span><br><span class="line"><span class="string"> 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153</span></span><br><span class="line"><span class="string"> 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171</span></span><br><span class="line"><span class="string"> 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189</span></span><br><span class="line"><span class="string"> 190 191 192 193 194 195 196 197 198 199]</span></span><br><span class="line"><span class="string">110</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">every_five = np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">5</span>)</span><br><span class="line">print(every_five)</span><br><span class="line"><span class="comment"># [ 0  5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95]</span></span><br><span class="line"></span><br><span class="line">print(base_data[every_five])</span><br><span class="line"><span class="comment"># [100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195]</span></span><br><span class="line"></span><br><span class="line">a = np.array([(<span class="number">1</span>,<span class="number">2</span>),[<span class="number">10</span>,<span class="number">20</span>]])</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [[ 1  2]</span></span><br><span class="line"><span class="comment">#  [10 20]]</span></span><br><span class="line">print(base_data[a])</span><br><span class="line"><span class="comment"># [[101 102]</span></span><br><span class="line"><span class="comment">#  [110 120]]</span></span><br><span class="line"></span><br><span class="line">base_data2 = base_data.reshape(<span class="number">10</span>, <span class="number">-1</span>)</span><br><span class="line">print(base_data2)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[100 101 102 103 104 105 106 107 108 109]</span></span><br><span class="line"><span class="string"> [110 111 112 113 114 115 116 117 118 119]</span></span><br><span class="line"><span class="string"> [120 121 122 123 124 125 126 127 128 129]</span></span><br><span class="line"><span class="string"> [130 131 132 133 134 135 136 137 138 139]</span></span><br><span class="line"><span class="string"> [140 141 142 143 144 145 146 147 148 149]</span></span><br><span class="line"><span class="string"> [150 151 152 153 154 155 156 157 158 159]</span></span><br><span class="line"><span class="string"> [160 161 162 163 164 165 166 167 168 169]</span></span><br><span class="line"><span class="string"> [170 171 172 173 174 175 176 177 178 179]</span></span><br><span class="line"><span class="string"> [180 181 182 183 184 185 186 187 188 189]</span></span><br><span class="line"><span class="string"> [190 191 192 193 194 195 196 197 198 199]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(base_data2[<span class="number">-1</span>,<span class="number">-1</span>])  <span class="comment"># 199</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片索引从0开始</span></span><br><span class="line">print(base_data2[<span class="number">2</span>, :])</span><br><span class="line"><span class="comment"># [120 121 122 123 124 125 126 127 128 129]</span></span><br><span class="line">print(base_data2[:,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [103 113 123 133 143 153 163 173 183 193]</span></span><br></pre></td></tr></table></figure>

<h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = (np.random.random((<span class="number">5</span>,<span class="number">5</span>))<span class="number">-0.5</span>) * <span class="number">100</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ -4.99893607  39.77193936 -15.46706727  16.80691258 -38.51945213]</span></span><br><span class="line"><span class="string"> [-49.06612449  49.35329335  -0.4216167   13.12483635 -41.60876645]</span></span><br><span class="line"><span class="string"> [-43.18292355 -25.25568989   0.44448147  -2.89856688 -24.13873839]</span></span><br><span class="line"><span class="string"> [ 32.75485688  11.0737333   18.77766764  22.513295     3.48913839]</span></span><br><span class="line"><span class="string"> [-10.96543248 -40.42721305  30.38299405 -32.77083843  40.39435566]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.amin(base_data))</span><br><span class="line"><span class="comment"># -49.06612449306485</span></span><br><span class="line"></span><br><span class="line">print(np.amax(base_data))</span><br><span class="line"><span class="comment"># 49.35329334672289</span></span><br><span class="line"></span><br><span class="line">print(np.average(base_data))</span><br><span class="line"><span class="comment"># -2.0333544702011186</span></span><br><span class="line"></span><br><span class="line">print(np.sin(base_data))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 0.95922553  0.87660695 -0.23857285 -0.89073028 -0.73137794]</span></span><br><span class="line"><span class="string"> [ 0.93180625 -0.7908454  -0.40923611  0.52988566  0.69474259]</span></span><br><span class="line"><span class="string"> [ 0.71691953 -0.12263914  0.42998979 -0.24064058  0.83821559]</span></span><br><span class="line"><span class="string"> [ 0.9732393  -0.99694714 -0.07182638 -0.4987417  -0.34059131]</span></span><br><span class="line"><span class="string"> [ 0.99954577 -0.40180897 -0.858805   -0.97678732  0.43167496]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.sum(base_data))</span><br><span class="line"><span class="comment"># -50.83386175502796</span></span><br></pre></td></tr></table></figure>

<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = np.floor((np.random.random((<span class="number">5</span>,<span class="number">5</span>))<span class="number">-0.5</span>) * <span class="number">100</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 39. -20. -44. -45.   6.]</span></span><br><span class="line"><span class="string"> [ -5.  44.  42. -33.  -6.]</span></span><br><span class="line"><span class="string"> [-14.  -9. -13. -30.  -4.]</span></span><br><span class="line"><span class="string"> [ 31. -50.   5.   7.  45.]</span></span><br><span class="line"><span class="string"> [ 39. -16.  42.  39. -24.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 矩阵转置</span></span><br><span class="line">print(base_data.T)  或着</span><br><span class="line">print(base_data.transpose())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 39.  -5. -14.  31.  39.]</span></span><br><span class="line"><span class="string"> [-20.  44.  -9. -50. -16.]</span></span><br><span class="line"><span class="string"> [-44.  42. -13.   5.  42.]</span></span><br><span class="line"><span class="string"> [-45. -33. -30.   7.  39.]</span></span><br><span class="line"><span class="string"> [  6.  -6.  -4.  45. -24.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">matri_one = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">minu_one = np.dot(matri_one, <span class="number">-1</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.dot(base_data,minu_one))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[-32. -32. -32. -32. -32.]</span></span><br><span class="line"><span class="string"> [-84. -84. -84. -84. -84.]</span></span><br><span class="line"><span class="string"> [-72. -72. -72. -72. -72.]</span></span><br><span class="line"><span class="string"> [ 51.  51.  51.  51.  51.]</span></span><br><span class="line"><span class="string"> [ 46.  46.  46.  46.  46.]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>生成20个随机数，它们每一个都是[0.0, 1.0)之间<br>根据指定的shape生成随机数<br>生成指定范围内（[0, 100)）的指定数量（20）的随机整数<br>对已有的数据（[0, 1, 2, …, 19]）的顺序随机打乱顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"random: &#123;&#125;\n"</span>.format(np.random.random(<span class="number">20</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">random: [0.105123   0.90013672 0.58255936 0.27769054 0.00139627 0.69873449</span></span><br><span class="line"><span class="string"> 0.32550338 0.72112185 0.35799445 0.72302835 0.67139936 0.30039148</span></span><br><span class="line"><span class="string"> 0.83770639 0.07878046 0.77641452 0.6054163  0.72421693 0.77157218</span></span><br><span class="line"><span class="string"> 0.08644228 0.65128463]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"rand: &#123;&#125;\n"</span>.format(np.random.rand(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">rand: [[0.73446485 0.30451937 0.49029421 0.62473099]</span></span><br><span class="line"><span class="string"> [0.09829422 0.55518899 0.83903237 0.71153898]</span></span><br><span class="line"><span class="string"> [0.11826133 0.53736883 0.47913765 0.0438171 ]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"randint: &#123;&#125;\n"</span>.format(np.random.randint(<span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">randint: [39 51 97 22 92 29 19 54 92 30  5 61 26 19 92 59 23 64 85 97]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"permutation: &#123;&#125;\n"</span>.format(np.random.permutation(np.arange(<span class="number">20</span>))))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">permutation: [ 5  0 14 10  6 13 11  7 18 19  2 12 17  3  9  8  1 15  4 16]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python图片转字符串</title>
    <url>/python/python%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="python-图片转成字符串"><a href="#python-图片转成字符串" class="headerlink" title="python 图片转成字符串"></a>python 图片转成字符串</h2><a id="more"></a>

<h3 id="下面是原始图片"><a href="#下面是原始图片" class="headerlink" title="下面是原始图片"></a>下面是原始图片</h3><p><img src="/image/crawl/red_heart.jpg" alt="红心"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">ascii_char = list(<span class="string">"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</span>)</span><br><span class="line"></span><br><span class="line">WIDTH = <span class="number">85</span> <span class="comment"># 字符画的宽</span></span><br><span class="line">HEIGHT = <span class="number">25</span> <span class="comment"># 字符画的高</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将256灰度映射到70个字符上，也就是RGB值转字符的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_char</span><span class="params">(r, g, b, alpha=<span class="number">256</span>)</span>:</span>  <span class="comment"># alpha透明度</span></span><br><span class="line">   <span class="keyword">if</span> alpha == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">   length = len(ascii_char)</span><br><span class="line">   gray = int(<span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b)  <span class="comment"># 计算灰度</span></span><br><span class="line">   unit = (<span class="number">256.0</span> + <span class="number">1</span>) / length</span><br><span class="line">   <span class="keyword">return</span> ascii_char[int(gray / unit)]  <span class="comment"># 不同的灰度对应着不同的字符</span></span><br><span class="line">   <span class="comment"># 通过灰度来区分色块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   img = <span class="string">'./15.jpg'</span> <span class="comment"># 图片所在位置</span></span><br><span class="line">   im = Image.open(img)</span><br><span class="line">   im = im.resize((WIDTH, HEIGHT), Image.NEAREST)</span><br><span class="line">   txt = <span class="string">""</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(HEIGHT):</span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> range(WIDTH):</span><br><span class="line">           txt += get_char(*im.getpixel((j, i))) <span class="comment"># 获得相应的字符</span></span><br><span class="line">       txt += <span class="string">'\n'</span></span><br><span class="line">   print(txt)  <span class="comment"># 打印出字符画</span></span><br><span class="line">   <span class="comment"># 将字符画 写入文件中</span></span><br><span class="line">   <span class="keyword">with</span> open(<span class="string">"15.txt"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">       f.write(txt)</span><br></pre></td></tr></table></figure>

<h3 id="转换后的效果"><a href="#转换后的效果" class="headerlink" title="转换后的效果"></a>转换后的效果</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">                                                                                </span><br><span class="line">           .uahZO000Okhhw^.                  ..'hhhhhhkqZwk`'.                  </span><br><span class="line">       'phkbddppJJJJmdppddbkb&lt;             aZ0ZqQppppOOdppddbkhk.               </span><br><span class="line">     .hkbddpppmJCpppp0JJQppJCqbk`      'mZ0dpppppJCJJJppppppppddbk:.            </span><br><span class="line">   .mZbdpppppUJpppppppppJJpppLJCQO.   hbQCppppppLJOJJJJppppppppppdbk.           </span><br><span class="line">  .hkdpZppZJJJZpppppppppppppdJJJddbkIhbdpppppppdJJJJJCJJCJJJJJpppppbk,          </span><br><span class="line">  mbbppppppCJJJppppppppppppppppCppdddddpppppppppppJJJJJLppppppJJJ0q0L0.         </span><br><span class="line">.,OLLpppLJqCJCCJppppppppppppppppppppppppppppppppppCppppppppppOJdppppCQ0         </span><br><span class="line">.p0LJCCmppppqCJJwppppppppppZJJLppppppppppppppppppJJppppppppppJJJCqpppL0.        </span><br><span class="line"> mkddppppppppppLJpppppqCJJpppJqpppppppppppJJJJCCJJJJJJJJJJJCqJJqCJJJJLQ         </span><br><span class="line"> .kbdppppppppppJpppppppJmpppp0JdpppppppppwJCJpwJZpppppCJJJJdpppppJppdb[         </span><br><span class="line">  lkbdpppwOqQJJCppppppppppOJJJJJJppppppCJOJpJJCpppppppppJJJpppppppppdq.         </span><br><span class="line">   .kbdpppJwpdJLppppppppppCJCdppJJJppppppJJJppppJJJLppppJJJJJqpppdbk.           </span><br><span class="line">     .kpCJqpppdOZOCLJJJJJJJJJppdJJppppppppJqp0JJJLppppppppppppdCdQ.             </span><br><span class="line">       .<span class="string">"dbdppppJJJpCdCwpppppppppJJpppppppppppppJZppppppppppdbd'.               </span></span><br><span class="line">            kkbLJppppwJJCppppppJJJJJppppppppppppJpppppppdbbm..                  </span><br><span class="line">               .rkbddpppJJJJJCJJJpCJ0ppZLJJJJJJJJdpddpb^                        </span><br><span class="line">                    .kbbpppppJJJqpppppppppppppppCQw'.                           </span><br><span class="line">                        ^kbddppJppppppppppppdbkt.                               </span><br><span class="line">                          .:hbdpppppppppppdb`.                                  </span><br><span class="line">                              .kbdpppppdba.                                     </span><br><span class="line">                                .kbbddb'                                        </span><br><span class="line">                                  .ah..</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter搭建</title>
    <url>/python/jupyter/jupyter%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="搭建jupyter服务器"><a href="#搭建jupyter服务器" class="headerlink" title="搭建jupyter服务器"></a>搭建jupyter服务器</h2><h3 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h3><h3 id="一、选择安装anaconda"><a href="#一、选择安装anaconda" class="headerlink" title="一、选择安装anaconda"></a>一、选择安装anaconda</h3><ol>
<li><p>根目录下创建一个文件夹用来放anaconda安装包</p>
</li>
<li><p>下载anaconda安装包（可以在官网上自行选择版本）</p>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>repo.continuum.io<span class="regexp">/archive/</span>Anaconda3-<span class="number">4.4</span>.<span class="number">0</span>-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>运行安装程序，安装anaconda</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Anaconda3-4</span><span class="selector-class">.4</span><span class="selector-class">.0-Linux-x86_64</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure>
<p> <strong>PS:</strong> 该文件是一个可执行文件，如果下载的文件没有可执行权限，执行命令 chmod  641  Anaconda3-4.4.0-Linux-x86_64.sh 修改权限。</p>
</li>
<li><p>配置环境变量</p>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>environment</span><br></pre></td></tr></table></figure>
<p> 将anaconda的bin文件夹的路径添加到环境变量中去（一般安装目录为/root/anaconda3/bin）</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source /etc/environment  <span class="comment"># 使文件生效</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二、配置jupyter-notebook-的配置文件"><a href="#二、配置jupyter-notebook-的配置文件" class="headerlink" title="二、配置jupyter notebook 的配置文件"></a>二、配置jupyter notebook 的配置文件</h3><ol>
<li><p>生成jupyter notebook 的配置文件</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令对于root用户</span></span><br><span class="line">jupyter notebook  --allow-root  --generate-config</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 对于一般用户</span></span><br><span class="line">jupyter notebook  --generate-config</span><br></pre></td></tr></table></figure>
<p> 执行完该命令后会在 .jupyter文件夹下生成一个jupyter_notebook_config.py的配置文件</p>
</li>
<li><p>修改配置</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vim jupyter_notebook_config.py <span class="comment"># 打开文件修改配置项</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  星号为允许任意ip访问服务</span></span><br><span class="line">c.NotebookApp.ip=<span class="string">'*'</span></span><br><span class="line"><span class="comment"># 该处设置登录jupyter 的密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'此处填写密码'</span></span><br><span class="line"><span class="comment"># 该项为启动服务默认打开浏览器，设置为False默认不打开</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">c.NotebookApp.port =<span class="number">8080</span></span><br><span class="line"><span class="comment"># 该项设置notebook 的工作目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/ubuntu/anaconda'</span></span><br></pre></td></tr></table></figure>
<p> <strong>PS:</strong> 对于密码的配置，我们不应该直接配置明文密码，因此需要对密码进行加密处理</p>
<h4 id="打开ipython"><a href="#打开ipython" class="headerlink" title="打开ipython"></a>打开ipython</h4> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure>
<p> 该命令会让你输入密码，确认密码，然后返回一串加密后的字符串，类似于：sha1:f97cc330b40c:fb618ac068bd66fb36563e15da4f7462131ad5ee</p>
<p> 配置完成之后保存文件。</p>
</li>
</ol>
<h2 id="三、启动jupyter-notebook应用"><a href="#三、启动jupyter-notebook应用" class="headerlink" title="三、启动jupyter notebook应用"></a>三、启动jupyter notebook应用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 notebook 服务</span></span><br><span class="line">nohup jupyter notebook &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更加高级的用法</span></span><br><span class="line">nohup jupyter notebook &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 nohup 是让进程在ssh连接断开时正常运行，&amp;是为了让进程在后台运行。如果想结束该进程，通过 ps aux|grep jupyter-notebook 查找到进程的pid，通过kill命令结束进程。</p>
<p>&emsp;&emsp;/dev/null : 代表空设备文件，2：代表标准错误， 1：代表标准输出</p>
<p>&emsp;&emsp;该命令是将标准输出重定向到文件/dev/null，标准错误输出重定向到标准输出，最终都重定向到/dev/null 文件中.</p>
<p>&emsp;&emsp;服务启动后，我们就可以通过公网ip + 端口访问我们的服务了。</p>
<p>&emsp;&emsp;ps：如果是普通用户启动jupyter notebook应用的话，可能会报错  Permission denied: ‘/run/user/0/jupyter’，这时可以打开文件~/.bashrc，添加一行export XDG_RUNTIME_DIR=””，可以解决这个权限问题。</p>
<p>&emsp;&emsp;如果在创建新的文件的时候出现 Permission denied: Untitled.ipynb的问题，找到你的jupyter的工作家目录，ls -al 查看你的文件的权限， chmod 777 yourdir/ 修改文件的权限。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp; 该服务的搭建过程中，有些重要的对方没有做，没有进行nginx反向代理，没有添加ssl证书。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>jupyter</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>mongo去重</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/mongo%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h2 id="mongo-去重"><a href="#mongo-去重" class="headerlink" title="mongo 去重"></a>mongo 去重</h2><p>进入到Mongo的安装目录，进入到bin文件夹下</p>
<p>导出数据：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mongoexport</span><span class="selector-class">.exe</span> <span class="selector-tag">-d</span> <span class="selector-tag">database</span> <span class="selector-tag">-c</span> <span class="selector-tag">collection</span> <span class="selector-tag">-o</span> <span class="selector-tag">filename</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure>
<p>导入数据：</p>
<a id="more"></a>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">mongoimport.<span class="keyword">exe</span> -d database -<span class="keyword">c</span> collection --<span class="keyword">file</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<p>查询集合中存在重复的数据：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([&#123;<span class="string">$group:</span>&#123;<span class="string">_id:</span>&#123;字段名:<span class="string">'$字段名'</span>&#125;,<span class="string">count:</span>&#123;<span class="string">$sum:</span><span class="number">1</span>&#125;&#125;&#125;,&#123;<span class="string">$match:</span>&#123;<span class="string">count:</span>&#123;<span class="string">$gt:</span><span class="number">1</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>

<p>删除重复数据：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">db<span class="built_in">.collection</span>.aggregate([</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$group:</span>&#123;_id:&#123;字段名:<span class="string">'$字段名'</span>&#125;<span class="built_in">,count</span>:&#123;<span class="variable">$sum:1</span>&#125;,dups:&#123;<span class="variable">$addToSet:</span><span class="string">'$_id'</span>&#125;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$match:</span><span class="built_in">&#123;count</span>:&#123;<span class="variable">$gt:1</span>&#125;&#125;</span><br><span class="line">&#125;]).forEach(<span class="keyword">function</span><span class="built_in">(doc</span>)&#123;</span><br><span class="line">doc.dups.shift();</span><br><span class="line">db<span class="built_in">.collection</span><span class="built_in">.remove</span>(&#123;_id:&#123;<span class="variable">$in:doc</span>.dups&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>解决api变化问题</title>
    <url>/python/%E7%88%AC%E8%99%AB/%E8%A7%A3%E5%86%B3api%E5%8F%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="python解决api变化的问题"><a href="#python解决api变化的问题" class="headerlink" title="python解决api变化的问题"></a>python解决api变化的问题</h2><p>案例：<a href="http://cic.org.vn" target="_blank" rel="noopener">http://cic.org.vn</a></p>
<p>&emsp;&emsp;该网站用python进行模拟登录时，url链接是经过js加载生成的，当我们用requests发送get请求的时候，返回的结果并不是真正的主页数据，而是一段js代码，但是直接从这段js代码中解析我们需要的登录页url很困难，因此这里我们可以构造一个轻量级的js环境，执行js代码来获取我们需要的数据。</p>
<p>环境：<br>我们通过jsdom来构造一个轻量的环境，它是基于node的，因此我们需要安装node环境，这里安装的是node8的版本；</p>
<a id="more"></a>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -sL http<span class="variable">s:</span>//<span class="keyword">deb</span>.nodesource.<span class="keyword">com</span>/setup_8.<span class="keyword">x</span> | sudo -E bash -</span><br><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> nodejs</span><br></pre></td></tr></table></figure>
<p>安装jsdom</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> jsdom</span><br></pre></td></tr></table></figure>

<p>创建js的运行环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">js_env = <span class="string">'''</span></span><br><span class="line"><span class="string">    const jsdom = require("jsdom");const &#123; JSDOM &#125; = jsdom;</span></span><br><span class="line"><span class="string">    const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`, &#123;</span></span><br><span class="line"><span class="string">        url: "%s",</span></span><br><span class="line"><span class="string">        contentType: "text/html;charset=utf-8",</span></span><br><span class="line"><span class="string">        includeNodeLocations: true,</span></span><br><span class="line"><span class="string">        storageQuota: 10000000</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    const window=dom.window;</span></span><br><span class="line"><span class="string">    const document=dom.window.document;</span></span><br><span class="line"><span class="string">    const navigator = dom.window.navigator;</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>
<h3 id="爬虫部分"><a href="#爬虫部分" class="headerlink" title="爬虫部分"></a>爬虫部分</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</span><br></pre></td></tr></table></figure>

<h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = requests.Session()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'cic.org.vn'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'en-US,en;q=0.9'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://cic.org.vn/"</span></span><br><span class="line">res = sess.get(url=url, headers=headers)</span><br><span class="line">html = Selector(text=res.text)</span><br><span class="line">js = html.xpath(<span class="string">"/html/head/script/text()"</span>).extract_first()</span><br></pre></td></tr></table></figure>

<h4 id="将我们获取的js代码加载到我们能构建的js运行环境中"><a href="#将我们获取的js代码加载到我们能构建的js运行环境中" class="headerlink" title="将我们获取的js代码加载到我们能构建的js运行环境中"></a>将我们获取的js代码加载到我们能构建的js运行环境中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctx = execjs.compile(js_env % res.url + js)</span><br></pre></td></tr></table></figure>

<p>执行js获取生成的下一个链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">next_url = ctx.eval(<span class="string">"href"</span>) + ctx.eval(<span class="string">"query"</span>)</span><br><span class="line">print(next_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">url = <span class="string">"https://cic.org.vn/webcenter/portal/CMSPortal/;jsessionid=4Hej6rGiIAbPiBs6nsBUMP61E9XNGVRYkRzjI5H0kxOhUW9dTaqR!873813657?_afrLoop=715225492645337"</span></span><br></pre></td></tr></table></figure>

<p>接下来的步骤都类似上一步，直到我们最终得到登录的url；最后我们就可以正常的模拟登录进行操作抓取数据了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;本次的案例是我第一次遇到的爬虫情况，该网站的主页url也是经过js加载的，其参数是一直变化的，其返回的结果并不是主页的数据，因此我们无法直接从返回的数据中解析出我们需要的参数，所以我们构造这么一个轻量级的js环境进行交互，直接问询我们需要的url参数，到最终获取我们需要的登录页链接中间这种js交互需要3次。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>requests</tag>
        <tag>jsdom</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda函数</title>
    <url>/lambda/lambda%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="记一次项目中lambda函数的应用"><a href="#记一次项目中lambda函数的应用" class="headerlink" title="记一次项目中lambda函数的应用"></a>记一次项目中lambda函数的应用</h2><p>lambda函数也叫做匿名函数，它允许我们快速定义，并且让代码更简洁<br>此次记录一下在项目中使用到lambda函数的场景</p>
<a id="more"></a>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, url=None, headers=None, encode=False, login_info=None, proxy_ip=None, path=None,  verify=False, retry_times=<span class="number">3</span>, decision=lambda x: True, **kwargs)</span>:</span></span><br><span class="line">    proxies = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> proxy_ip:</span><br><span class="line">        proxies = &#123;<span class="string">"http"</span>: proxy_ip, <span class="string">"https"</span>: proxy_ip&#125;</span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    data = kwargs[<span class="string">'params'</span>] <span class="keyword">if</span> <span class="string">'params'</span> <span class="keyword">in</span> kwargs <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(retry_times):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            res = self.session.get(url=url, headers=headers, proxies=proxies, verify=verify, **kwargs)</span><br><span class="line">            self.save_src(url=url, headers=headers, data=data, res=res, login_info=login_info, path=path, encode=encode)</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> res.status_code != <span class="number">200</span>:</span><br><span class="line">                logger.error(<span class="string">'crawl_session get: internet error! url: %s'</span> % url)</span><br><span class="line">            <span class="keyword">if</span> res.status_code &gt;= <span class="number">500</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> res.status_code == <span class="number">200</span> <span class="keyword">and</span> <span class="keyword">not</span> decision(res):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br></pre></td></tr></table></figure>

<p>这里封装了一下requests的get方法，加入了一个decision参数，该参数是一个匿名函数，retry_times是重试次数，通过匿名函数对res结果进行判断，对爬取结果进行预处理；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decision</span><span class="params">(res)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'java.lang.NullPointerException'</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>上面的函数是我们在爬虫中定义的一个判断函数，当我们如果知道爬取结果中必定会有某个特殊的返回值时，通过该函数我们可以判断爬取的结果是否是正确的；简单的例子，当有可能我们请求服务端json数据时，返回状态码是200，response的json确是一个空值，而我们确定该json一定不是空值，这是我们可以通过lambda函数预处理进行重爬。</p>
]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>百度贴吧图片抓取</title>
    <url>/python/%E7%88%AC%E8%99%AB/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%9B%BE%E7%89%87%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<h2 id="python爬取百度贴吧张国荣图片"><a href="#python爬取百度贴吧张国荣图片" class="headerlink" title="python爬取百度贴吧张国荣图片"></a>python爬取百度贴吧张国荣图片</h2><p>一直喜欢哥哥的歌，也一直听哥哥的歌，突然想着收集一些哥哥的照片，所以写了一个爬虫爬取哥哥的图片，也给大家参考一下；</p>
<h4 id="这里我用的request-html这个包"><a href="#这里我用的request-html这个包" class="headerlink" title="这里我用的request-html这个包"></a>这里我用的request-html这个包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTMLSession</span><br><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTML</span><br></pre></td></tr></table></figure>

<h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h4><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrawlSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sess = HTMLSession()</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">"Host"</span>: <span class="string">"tieba.baidu.com"</span>,</span><br><span class="line">            <span class="string">"Referer"</span>: <span class="string">"https://www.baidu.com/"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析请求的api-发现它是get请求，带有参数"><a href="#分析请求的api-发现它是get请求，带有参数" class="headerlink" title="分析请求的api,发现它是get请求，带有参数"></a>分析请求的api,发现它是get请求，带有参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.params = &#123;</span><br><span class="line">            <span class="string">"kw"</span>: <span class="string">"张国荣"</span>,</span><br><span class="line">            <span class="string">"tab"</span>: <span class="string">"album"</span>,</span><br><span class="line">            <span class="string">"subtab"</span>: <span class="string">"album_good"</span>,</span><br><span class="line">            <span class="string">"cat_id"</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送请求，找到分类的id"><a href="#发送请求，找到分类的id" class="headerlink" title="发送请求，找到分类的id"></a>发送请求，找到分类的id</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = self.sess.get(url=<span class="string">"http://tieba.baidu.com/f?"</span>,params=self.params, headers=self.headers)</span><br><span class="line">category_list = re.findall(<span class="string">'&lt;li cat-id="(.*)"&gt;&lt;span&gt;'</span>, resp.text)</span><br></pre></td></tr></table></figure>
<h4 id="对每个分类构造api请求，获取每个图册的id"><a href="#对每个分类构造api请求，获取每个图册的id" class="headerlink" title="对每个分类构造api请求，获取每个图册的id"></a>对每个分类构造api请求，获取每个图册的id</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_tid_list = []</span><br><span class="line"><span class="keyword">for</span> cat_id <span class="keyword">in</span> category_list:</span><br><span class="line">    self.params[<span class="string">"cat_id"</span>] = cat_id</span><br><span class="line">    self.params[<span class="string">"pagelets"</span>] = <span class="string">'album/pagelet/album_good'</span></span><br><span class="line">    self.params[<span class="string">"pagelets_stamp"</span>] = <span class="string">"%013d"</span>%(<span class="number">1000</span> * time.time())</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.sess.get(url=<span class="string">"http://tieba.baidu.com/f?"</span>, params=self.params, headers=self.headers)</span><br><span class="line">        resp.html.render()</span><br><span class="line">        html = HTML(html=resp.html.text)</span><br><span class="line">        tid_list = re.findall(<span class="string">r"/p/\d+"</span>, re.sub(<span class="string">r"\\"</span>, <span class="string">''</span>, str(html.links)))</span><br><span class="line">        all_tid_list.extend(tid_list)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        print(<span class="string">"获取tid失败&#123;&#125;"</span>.format(err))</span><br><span class="line"><span class="keyword">return</span> all_tid_list</span><br></pre></td></tr></table></figure>

<h4 id="拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“-”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数"><a href="#拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“-”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数" class="headerlink" title="拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“_”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数"></a>拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“_”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">        <span class="string">"kw"</span>: <span class="string">"张国荣"</span>,</span><br><span class="line">        <span class="string">"alt"</span>: <span class="string">"jview"</span>,</span><br><span class="line">        <span class="string">"rn"</span>: <span class="string">"200"</span>,</span><br><span class="line">        <span class="string">"tid"</span>: tid,</span><br><span class="line">        <span class="string">"pn"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"ps"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"pe"</span>: <span class="string">"40"</span>,</span><br><span class="line">        <span class="string">"info"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_"</span>: <span class="string">"%013d"</span> % (<span class="number">1000</span> * time.time())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息"><a href="#构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息" class="headerlink" title="构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息"></a>构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_url = <span class="string">"http://tieba.baidu.com/photo/g/bw/picture/list?"</span></span><br><span class="line">resp = self.sess.get(url=base_url, params=params, headers=self.headers).text</span><br><span class="line">time.sleep(random.random() + <span class="number">1</span>)</span><br><span class="line">resp = json.loads(resp)</span><br><span class="line">title = resp[<span class="string">"data"</span>][<span class="string">"title"</span>]</span><br><span class="line">pic_list = resp[<span class="string">"data"</span>][<span class="string">"pic_list"</span>]</span><br></pre></td></tr></table></figure>

<h4 id="保存我们需要的图册标题和图片链接"><a href="#保存我们需要的图册标题和图片链接" class="headerlink" title="保存我们需要的图册标题和图片链接"></a>保存我们需要的图册标题和图片链接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    image_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self.total_images:</span><br><span class="line">        image_dict = &#123;&#125;</span><br><span class="line">        image_url = []</span><br><span class="line">        image_dict[<span class="string">"title"</span>] = item[<span class="string">"title"</span>]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> item[<span class="string">"images_info"</span>]:</span><br><span class="line">            image_url.append(each[<span class="string">"purl"</span>])</span><br><span class="line">        image_dict[<span class="string">"image_url"</span>] = image_url</span><br><span class="line">        image_list.append(image_dict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"image_urls.json"</span>, <span class="string">"w"</span>, encoding=<span class="string">'GBK'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(image_list))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"写入数据失败&#123;&#125;"</span>.format(err))</span><br></pre></td></tr></table></figure>

<p>这样我们就拿到了哥哥的图片链接了，然后我们请求图片链接，下载图片即可<br><img src="/image/crawl/leslie.png" alt="张国荣"></p>
<h2 id="完整代码可以看我的gitub链接："><a href="#完整代码可以看我的gitub链接：" class="headerlink" title="完整代码可以看我的gitub链接："></a>完整代码可以看我的gitub链接：</h2><p><a href="https://github.com/gongjiaqiang/my_spider" target="_blank" rel="noopener">https://github.com/gongjiaqiang/my_spider</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python3中Unicode字符转中文</title>
    <url>/python/%E7%88%AC%E8%99%AB/python3%E4%B8%ADUnicode%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h2 id="python3中将Unicode字符串转成中文"><a href="#python3中将Unicode字符串转成中文" class="headerlink" title="python3中将Unicode字符串转成中文"></a>python3中将Unicode字符串转成中文</h2><p>用python爬虫爬取数据时，有时候会发现爬取的数据类似于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a</span><br></pre></td></tr></table></figure>
<p>这样的Unicode字符串，在python的交互环境里可以直接打印输出查看内容；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>但是有些时候，我们需要保存的是中文数据，而不是Unicode字符串，所以我们需要将Unicode转成中文，我们知道encode()方法是将Unicode码转成我们需要的编码格式，但是我们返回的本身就是str格式，所以我们需要将Unicode字符串转成Unicode码，网上查了资料，是将字符串进行decode(“unicode_escape”)转换，但是在python3中，提示str没有decode的方法。</p>
<p>因此解决的办法是先采用encode()进行编码，在用同样的编码格式进行decode解码；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>.encode(<span class="string">"utf-8"</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(type(data))  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(data)  <span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>.encode(<span class="string">"GBK"</span>).decode(<span class="string">"GBK"</span>)</span><br><span class="line">print(type(data))  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(data)  <span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure>

<p>编码格式可以任意，只是解码的时候需要用相同的格式进行解码就行，这样我们就可以保存中文数据了。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python返回每个月最大天数</title>
    <url>/python/python%E8%BF%94%E5%9B%9E%E6%AF%8F%E4%B8%AA%E6%9C%88%E6%9C%80%E5%A4%A7%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="python返回过去时间里的每月最大天数"><a href="#python返回过去时间里的每月最大天数" class="headerlink" title="python返回过去时间里的每月最大天数"></a>python返回过去时间里的每月最大天数</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    year = now.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">    mon = now.strftime(<span class="string">'%m'</span>)</span><br><span class="line">    day = now.strftime(<span class="string">'%d'</span>)</span><br><span class="line">    date_list = []</span><br><span class="line">    date_list.append([day, mon, year])</span><br><span class="line">    temp = now</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num):</span><br><span class="line">        last_mon_day = temp - datetime.timedelta(days=temp.day)</span><br><span class="line">        last_day = last_mon_day.strftime(<span class="string">'%d'</span>)</span><br><span class="line">        mon = last_mon_day.strftime(<span class="string">'%m'</span>)</span><br><span class="line">        year = last_mon_day.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">        date_list.append([last_day, mon, year])</span><br><span class="line">        temp = last_mon_day</span><br><span class="line">    <span class="keyword">return</span> date_list</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回过去一年每个月的时间</span></span><br><span class="line">date_list = get_date_list(<span class="number">12</span>)</span><br><span class="line">print(date_list)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="string">'22'</span>, <span class="string">'06'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'05'</span>, <span class="string">'2018'</span>], [<span class="string">'30'</span>, <span class="string">'04'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'03'</span>, <span class="string">'2018'</span>], [<span class="string">'28'</span>, <span class="string">'02'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'01'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'12'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'11'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'10'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'09'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'08'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'07'</span>, <span class="string">'2017'</span>]]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中元素替换</title>
    <url>/python/python%E4%B8%AD%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="python中元素进行替换有很多方法，下面是我学习中的一些总结"><a href="#python中元素进行替换有很多方法，下面是我学习中的一些总结" class="headerlink" title="python中元素进行替换有很多方法，下面是我学习中的一些总结"></a>python中元素进行替换有很多方法，下面是我学习中的一些总结</h2><h3 id="1、字符串替换str-replace-方法"><a href="#1、字符串替换str-replace-方法" class="headerlink" title="1、字符串替换str.replace()方法"></a>1、字符串替换str.replace()方法</h3><p>python中的replace()方法是把字符串中的old字符串替换成new的字符串，如果指定替换次数max,则按照替换次数进行替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.replace(old,new,count=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>old：字符串替换前的字符<br>new：字符串替换后的字符<br>count：替换的次数，默认为0，不填表示全局替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>)  <span class="comment"># 表示全局替换</span></span><br><span class="line"><span class="string">'he@@o wor@d! I @ove python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>)  <span class="comment"># 替换指定次数</span></span><br><span class="line"><span class="string">'he@@o world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>).replace(<span class="string">"o"</span>,<span class="string">"$"</span>)  <span class="comment"># 多个字符替换可以进行链式调用replace()方法</span></span><br><span class="line"><span class="string">'he@@$ w$rld! I l$ve pyth$n!'</span></span><br></pre></td></tr></table></figure>

<h3 id="2、正则表达式中的sub-和subn-方法"><a href="#2、正则表达式中的sub-和subn-方法" class="headerlink" title="2、正则表达式中的sub()和subn()方法"></a>2、正则表达式中的sub()和subn()方法</h3><p>sub(pattern, repl, string)<br>其中pattern表示原字符串中的字符，repl表示需要替换成的字符，string表示需要替换的字符串；<br>subn()和sub()的区别在于subn()返回的一个包含新字符串和替换次数的二元组；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">"hello"</span>,<span class="string">"nihao"</span>,str)  </span><br><span class="line"><span class="string">'nihao world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(<span class="string">"l"</span>,<span class="string">"*"</span>,str)</span><br><span class="line">(<span class="string">'he**o wor*d! I *ove python!'</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法"><a href="#3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法" class="headerlink" title="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法"></a>3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法</h3><p>maketrans()方法用来生成字符映射表，而translate()方法则按映射表中定义的对应关系转换并替换其中的字符，用这两种方法可以同时处理多个不同的字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = <span class="string">''</span>.maketrans(<span class="string">"abcdefghij"</span>,<span class="string">"1234567890"</span>)  <span class="comment"># 创建映射表，注意字符串的长度要一致，达到一一对应的目的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! i love python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.translate(table)  <span class="comment"># 按照关系表将sting中的字符逐个进行替换</span></span><br><span class="line"><span class="string">'85llo worl4! 9 lov5 pyt8on'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4、对列表里的元素进行替换，可以使用列表解析的方法"><a href="#4、对列表里的元素进行替换，可以使用列表解析的方法" class="headerlink" title="4、对列表里的元素进行替换，可以使用列表解析的方法"></a>4、对列表里的元素进行替换，可以使用列表解析的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="number">5</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-1、批量进行替换"><a href="#4-1、批量进行替换" class="headerlink" title="4.1、批量进行替换"></a>4.1、批量进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="string">"a"</span> <span class="keyword">if</span> x <span class="keyword">in</span> pattern <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-2、根据字典的映射进行替换"><a href="#4-2、根据字典的映射进行替换" class="headerlink" title="4.2、根据字典的映射进行替换"></a>4.2、根据字典的映射进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="number">1</span>:<span class="string">"apple"</span>, <span class="number">3</span>:<span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [dict[x] <span class="keyword">if</span> x <span class="keyword">in</span> dict <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="string">'apple'</span>, <span class="number">2</span>, <span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。"><a href="#5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。" class="headerlink" title="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。"></a>5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world!"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str = StringIO(str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str</span><br><span class="line">&lt;_io.StringIO object at <span class="number">0x7fa1e61addc8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell()  <span class="comment"># 返回当前的位置</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()  <span class="comment"># 从当前位置开始读取字符串</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 返回字符串的全部内容</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.seek(<span class="number">6</span>)  <span class="comment"># 定义开始修改的位置</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.write(<span class="string">"china"</span>)  <span class="comment"># 修改字符串</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()</span><br><span class="line"><span class="string">'!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 获取修改后的字符串全部内容</span></span><br><span class="line"><span class="string">'hello china!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell() </span><br><span class="line"><span class="number">12</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中arrow库的使用</title>
    <url>/python/python%E4%B8%ADarrow%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p> Arrow是一个Python库，为创建，操作，格式化和转换日期，时间和时间戳提供了一种明智的，人性化的方法。 它实现和更新日期时间类型，填补功能上的空白，并提供支持许多常见创建场景的智能模块API。 简而言之，它可以帮助您使用更少的进口和更少的代码来处理日期和时间。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> arrow</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="简单开始"><a href="#简单开始" class="headerlink" title="简单开始"></a>简单开始</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> arrow</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.utcnow()  <span class="comment"># 获取世界标准时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T09:<span class="number">37</span>:<span class="number">28.989983</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.now()  <span class="comment"># 获取本地时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">40</span>:<span class="number">19.019529</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.now(<span class="string">'US/Pacific'</span>)  <span class="comment"># 获取指定时区的时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T02:<span class="number">41</span>:<span class="number">54.815029</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">44</span>:<span class="number">43.519166</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.year  <span class="comment"># 当前年</span></span><br><span class="line"><span class="number">2018</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.month  <span class="comment"># 当前月份</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.day  <span class="comment"># 当前天</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.hour  <span class="comment"># 当前第几个小时</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.minute  <span class="comment"># 当前多少分钟</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.second  <span class="comment"># 当前多少秒</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.timestamp  <span class="comment"># 获取时间戳</span></span><br><span class="line"><span class="number">1528364683</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.float_timestamp  <span class="comment"># 浮点数时间戳</span></span><br><span class="line"><span class="number">1528364683.519166</span></span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">59</span>:<span class="number">36.917894</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format()</span><br><span class="line"><span class="string">'2018-06-07 17:59:36+08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format(<span class="string">'YYYY-MM-DD HH:mm:ss ZZ'</span>)</span><br><span class="line"><span class="string">'2018-06-07 17:59:36 +08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ctime()  <span class="comment"># 返回日期和时间的ctime格式化表示。</span></span><br><span class="line"><span class="string">'Thu Jun  7 17:59:36 2018'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.weekday()  <span class="comment"># 以整数形式返回星期几（0-6）</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isoweekday()  <span class="comment"># 以整数形式返回一周中的ISO日（1-7）</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isocalendar()  <span class="comment"># 返回3元组（ISO年，ISO周数，ISO工作日）</span></span><br><span class="line">(<span class="number">2018</span>, <span class="number">23</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.toordinal()  <span class="comment"># 返回日期的格雷戈里序数</span></span><br><span class="line"><span class="number">736852</span></span><br></pre></td></tr></table></figure>

<h3 id="从string中解析时间对象"><a href="#从string中解析时间对象" class="headerlink" title="从string中解析时间对象"></a>从string中解析时间对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="string">'2018-06-07 18:52:45'</span>, <span class="string">'YYYY-MM-DD HH:mm:ss'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T18:<span class="number">52</span>:<span class="number">45</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'June was born in May 1980'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(str,<span class="string">'MMMM YYYY'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">1980</span><span class="number">-05</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens"><a href="#解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens" class="headerlink" title="解析的格式化参考：http://arrow.readthedocs.io/en/latest/#tokens"></a>解析的格式化参考：<a href="http://arrow.readthedocs.io/en/latest/#tokens" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/#tokens</a></h3><h3 id="时间的替换和偏移"><a href="#时间的替换和偏移" class="headerlink" title="时间的替换和偏移"></a>时间的替换和偏移</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(hour=<span class="number">20</span>,minute=<span class="number">00</span>)  <span class="comment"># 替换时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T20:<span class="number">00</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(tzinfo=<span class="string">'US/Pacific'</span>)  <span class="comment"># 替换时区</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=+<span class="number">3</span>)  <span class="comment"># 往后偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-10</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=<span class="number">-3</span>)  <span class="comment"># 往前偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-04</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="按名称或tzinfo转换为时区"><a href="#按名称或tzinfo转换为时区" class="headerlink" title="按名称或tzinfo转换为时区"></a>按名称或tzinfo转换为时区</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">16</span>:<span class="number">51.695083</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.to(<span class="string">'US/Pacific'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T04:<span class="number">16</span>:<span class="number">51.695083</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更人性化的设计"><a href="#更人性化的设计" class="headerlink" title="更人性化的设计"></a>更人性化的设计</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>past = arrow.utcnow().shift(hours=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T10:<span class="number">24</span>:<span class="number">19.968351</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past.humanize()</span><br><span class="line"><span class="string">'an hour ago'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>present = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future = present.shift(hours=+<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T13:<span class="number">25</span>:<span class="number">57.160630</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize()</span><br><span class="line"><span class="string">'in 2 hours'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize(a,locale=<span class="string">'ru'</span>)  <span class="comment"># 支持更多的语言环境</span></span><br><span class="line"><span class="string">'через 3 часа'</span></span><br></pre></td></tr></table></figure>

<h3 id="获取任意时间单位的时间跨度"><a href="#获取任意时间单位的时间跨度" class="headerlink" title="获取任意时间单位的时间跨度"></a>获取任意时间单位的时间跨度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'hour'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'year'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-01</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-12</span><span class="number">-31</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'month'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-30</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'day'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="只得到任意单位时间中的最大值或最小值"><a href="#只得到任意单位时间中的最大值或最小值" class="headerlink" title="只得到任意单位时间中的最大值或最小值"></a>只得到任意单位时间中的最大值或最小值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="表示特定于语言环境的数据和功能的类"><a href="#表示特定于语言环境的数据和功能的类" class="headerlink" title="表示特定于语言环境的数据和功能的类"></a>表示特定于语言环境的数据和功能的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrow.locales.Locale</span><br></pre></td></tr></table></figure>

<h2 id="arrow库的官方文档：http-arrow-readthedocs-io-en-latest"><a href="#arrow库的官方文档：http-arrow-readthedocs-io-en-latest" class="headerlink" title="arrow库的官方文档：http://arrow.readthedocs.io/en/latest/"></a>arrow库的官方文档：<a href="http://arrow.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/</a></h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中random库使用</title>
    <url>/python/python%E4%B8%ADrandom%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；"><a href="#1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；" class="headerlink" title="1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；"></a>1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.random()</span><br><span class="line">print(num)  <span class="comment"># num=0.4329135788510704</span></span><br></pre></td></tr></table></figure>
<h3 id="2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"><a href="#2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；" class="headerlink" title="2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"></a>2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.uniform(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(num)  <span class="comment"># num=1.9499995621894857</span></span><br></pre></td></tr></table></figure>
<h3 id="3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限"><a href="#3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限" class="headerlink" title="3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限"></a>3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">print(num)  <span class="comment"># num=2</span></span><br></pre></td></tr></table></figure>
<h3 id="4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"><a href="#4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等" class="headerlink" title="4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"></a>4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">num = random.choice(list)</span><br><span class="line">print(num)  <span class="comment"># num=5</span></span><br></pre></td></tr></table></figure>
<h3 id="5、random-shuffle-随机打乱一个序列"><a href="#5、random-shuffle-随机打乱一个序列" class="headerlink" title="5、random.shuffle() 随机打乱一个序列"></a>5、random.shuffle() 随机打乱一个序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(list)  <span class="comment"># list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">random.shuffle(list)</span><br><span class="line">print(list)  <span class="comment"># list=[1, 5, 4, 2, 0, 6, 9, 8, 3, 7]</span></span><br></pre></td></tr></table></figure>
<h3 id="6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改"><a href="#6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改" class="headerlink" title="6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改"></a>6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">new_list = random.sample(list, <span class="number">5</span>)  <span class="comment"># 第一个参数要截取的对象，第二个参数是截取的长度</span></span><br><span class="line">print(new_list)  <span class="comment"># [7, 9, 0, 8, 1]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理简单验证码</title>
    <url>/python/python%E5%A4%84%E7%90%86%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h4 id="利用python对简单的验证码进行处理"><a href="#利用python对简单的验证码进行处理" class="headerlink" title="利用python对简单的验证码进行处理"></a>利用python对简单的验证码进行处理</h4><p>验证码如下所示：<br><img src="/image/code/code.png" alt="这里写图片描述"><br>首先导入我们需要的包文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br></pre></td></tr></table></figure>
<p>将验证码进行切分，其中进行切分的坐标可以自行调整最佳；Image模块的convert()函数，用于不同模式图像之间的转换。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div_im</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)   <span class="comment"># 转换为灰度图像返回</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">''</span>.join(random.sample(ascii_lowercase, <span class="number">10</span>))  <span class="comment"># 随机序列化一个字符串</span></span><br><span class="line">    regions = [(<span class="number">8</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">26</span>), (<span class="number">20</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">26</span>), (<span class="number">32</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">26</span>), (<span class="number">44</span>, <span class="number">6</span>, <span class="number">56</span>, <span class="number">26</span>)]   <span class="comment"># 定义切分坐标</span></span><br><span class="line">    arr = list()</span><br><span class="line">    <span class="keyword">for</span> i, region <span class="keyword">in</span> enumerate(regions):</span><br><span class="line">        im2 = im.crop(region)   <span class="comment"># 将验证码按坐标进行切分</span></span><br><span class="line">        f_name = <span class="string">'&#123;&#125;_&#123;&#125;.jpg'</span>.format(name, i)</span><br><span class="line">        im2.save(f_name)</span><br><span class="line">        arr.append(f_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>切分后返回的图片为：<br><img src="/image/code/code1.jpg" alt="这里写图片描述"> <img src="/image/code/code2.jpg" alt="这里写图片描述"> <img src="/image/code/code3.jpg" alt="这里写图片描述"> <img src="/image/code/code4.jpg" alt="这里写图片描述"></p>
<p>将图片进行二值化处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_im_to_array</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)</span><br><span class="line">    a = numpy.array(im)</span><br><span class="line">    a = numpy.array([[<span class="number">0</span> <span class="keyword">if</span> j &lt; <span class="number">5</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> i] <span class="keyword">for</span> i <span class="keyword">in</span> a])  <span class="comment"># 数字5是自己调整的阈值</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>样本集标注：采集100张验证码图片进行切分，人为进行标注0~9；<br><img src="/image/code/test1.png" alt="这里写图片描述"><br><img src="/image/code/test2.png" alt="这里写图片描述"></p>
<p>最后就是进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec</span><span class="params">(f_name)</span>:</span></span><br><span class="line">    a = convert_im_to_array(f_name)  <span class="comment"># 测试图片的二值化数组</span></span><br><span class="line">    min_i = <span class="number">-1</span></span><br><span class="line">    min_v = <span class="number">10000000</span>  <span class="comment"># 选择一个较大的数即可</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = <span class="string">'sample_im/&#123;&#125;'</span>.format(i)  <span class="comment"># 样本集路径0~9</span></span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">            b = convert_im_to_array(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(p, im))  <span class="comment"># 样本集图片的二值化数组</span></span><br><span class="line">            tmp = sum(sum((a - b)**<span class="number">2</span>))  </span><br><span class="line">            print(tmp)</span><br><span class="line">            <span class="keyword">if</span> tmp &lt; min_v:</span><br><span class="line">                min_v = tmp</span><br><span class="line">                min_i = i</span><br><span class="line">            print(<span class="string">"min_v的值："</span>,min_v)</span><br><span class="line">        print(<span class="string">"min_i的值："</span>,min_i)</span><br><span class="line">    <span class="keyword">return</span> min_i  <span class="comment"># 返回图片中的数字</span></span><br></pre></td></tr></table></figure>
<p>最后可以进行多次测试比较识别的准确率。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进行excel转json</title>
    <url>/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/python%E8%BF%9B%E8%A1%8Cexcel%E8%BD%ACjson/</url>
    <content><![CDATA[<h2 id="使用python进行excel转json文件"><a href="#使用python进行excel转json文件" class="headerlink" title="使用python进行excel转json文件"></a>使用python进行excel转json文件</h2><h3 id="1、首先导入我们需要用到的库"><a href="#1、首先导入我们需要用到的库" class="headerlink" title="1、首先导入我们需要用到的库"></a>1、首先导入我们需要用到的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、具体代码如下："><a href="#2、具体代码如下：" class="headerlink" title="2、具体代码如下："></a>2、具体代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Excel_to_json</span><span class="params">(file)</span>:</span></span><br><span class="line">    wb = xlrd.open_workbook(file)</span><br><span class="line"></span><br><span class="line">    convert_list = []</span><br><span class="line">    sh = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    title = sh.row_values(<span class="number">0</span>)  <span class="comment"># 表头，json文件的key</span></span><br><span class="line">    print(title)</span><br><span class="line">    <span class="keyword">for</span> rownum <span class="keyword">in</span> range(<span class="number">1</span>, sh.nrows):</span><br><span class="line">        rowvalue = sh.row_values(rownum)</span><br><span class="line">        single = OrderedDict()  <span class="comment"># 有序字典</span></span><br><span class="line">        <span class="keyword">for</span> colnum <span class="keyword">in</span> range(<span class="number">0</span>, len(rowvalue)):</span><br><span class="line">            print(<span class="string">"key:&#123;0&#125;, value:&#123;1&#125;"</span>.format(title[colnum], rowvalue[colnum]))</span><br><span class="line">            single[title[colnum]] = rowvalue[colnum]</span><br><span class="line">        convert_list.append(single)</span><br><span class="line"></span><br><span class="line">    j = json.dumps(convert_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"file.json"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(j)</span><br></pre></td></tr></table></figure>
<h2 id="使用python进行json转csv文件"><a href="#使用python进行json转csv文件" class="headerlink" title="使用python进行json转csv文件"></a>使用python进行json转csv文件</h2><h3 id="1、同样，我们先导入需要的库"><a href="#1、同样，我们先导入需要的库" class="headerlink" title="1、同样，我们先导入需要的库"></a>1、同样，我们先导入需要的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<h3 id="2、代码如下："><a href="#2、代码如下：" class="headerlink" title="2、代码如下："></a>2、代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_to_csv</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(path + <span class="string">'.json'</span>, <span class="string">"r"</span>) <span class="keyword">as</span>  f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    jsonData = json.loads(data)</span><br><span class="line"></span><br><span class="line">    csvfile = open(path + <span class="string">".csv"</span>, <span class="string">"w"</span>, newline=<span class="string">''</span>)</span><br><span class="line">    keys_write = <span class="literal">True</span></span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    print(jsonData)</span><br><span class="line">    <span class="keyword">for</span> dic <span class="keyword">in</span> jsonData:</span><br><span class="line">        <span class="keyword">if</span> keys_write:</span><br><span class="line">            keys = list(dic.keys())</span><br><span class="line">            print(keys)</span><br><span class="line">            writer.writerow(keys)</span><br><span class="line">            keys_write = <span class="literal">False</span></span><br><span class="line">        writer.writerow(list(dic.values()))</span><br><span class="line">        print(list(dic.values()))</span><br><span class="line">    csvfile.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    path = <span class="string">"file"</span>  <span class="comment"># 文件的路径</span></span><br><span class="line">    json_to_csv(path)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python字典多次嵌套</title>
    <url>/python/python%E5%AD%97%E5%85%B8%E5%A4%9A%E6%AC%A1%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h2 id="python实现字典多层嵌套"><a href="#python实现字典多层嵌套" class="headerlink" title="python实现字典多层嵌套"></a>python实现字典多层嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于字典</span></span><br><span class="line">dict1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其实现多次嵌套效果</span></span><br><span class="line">dict2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: &#123;<span class="string">'1'</span>: <span class="number">3</span>, <span class="string">'2'</span>: <span class="number">4</span>&#125;, </span><br><span class="line">        <span class="string">'d'</span>: &#123;<span class="string">'5'</span>: &#123;<span class="string">'2'</span>: <span class="number">5</span>, <span class="string">'3'</span>: <span class="number">6</span>&#125;, <span class="string">'4'</span>: &#123;<span class="string">'1'</span>: <span class="number">7</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(d1)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> key:</span><br><span class="line">            parts = key.split(<span class="string">'.'</span>)</span><br><span class="line">            par = d2</span><br><span class="line">            key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">'=========='</span>, key)</span><br><span class="line">            <span class="keyword">while</span> parts:</span><br><span class="line">                par = par.setdefault(key, &#123;&#125;)</span><br><span class="line">                print(par)</span><br><span class="line">                key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            par[key] = value</span><br><span class="line">            print(par)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        d2[key] = value</span><br><span class="line"></span><br><span class="line">fun(d1)</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure>

<h3 id="其中用到了字典的setdefault方法"><a href="#其中用到了字典的setdefault方法" class="headerlink" title="其中用到了字典的setdefault方法"></a>其中用到了字典的setdefault方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict.setdefault(key,default=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>如果键不存在于字典中，将会添加新的键，并将值设置为默认值；如果字典中包含该给定的键，则返回该键对应的值，否则返回该键设置的默认值。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>dict.get(key,default=None)<br>get方法返回给定键的值，如果键不可用返回默认值；</p>
<h3 id="collection-defaultdict"><a href="#collection-defaultdict" class="headerlink" title="collection defaultdict"></a>collection defaultdict</h3><p>defaultdict()返回一个字典，自动给每一个键赋一个初始值</p>
<p><em>参考链接地址：<a href="https://blog.csdn.net/whgyxy/article/details/72458000" target="_blank" rel="noopener">https://blog.csdn.net/whgyxy/article/details/72458000</a></em></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中闭包和装饰器</title>
    <url>/python/python%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p>   <em>闭包</em> 是引用了变量的函数，这个被引用的自由变量将和这个函数一同存在，即使离开了创造这个变量的环境也不例外。所以，<em>闭包</em> 是由函数和与其相关的引用环境组合而成的实体。简单来说，<em>闭包</em> 就是数据和功能的结合。</p>
<a id="more"></a>
<h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p> <strong>优点：</strong> 可以提高代码的可复用性<br> <strong>缺点：</strong> 由于闭包是引用了外部函数的局部变量，导致外部函数的局部变量没有及时释放，消耗内存。</p>
<h2 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2.装饰器"></a>2.装饰器</h2><h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><p>装饰器本质上也还是一个python函数，它可以让其他函数在不需要的做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的应用场景主要是一些有切面需求的场景，例如：插入日志，性能测试，事务处理，缓存，权限校验等。通过装饰器，我们可以抽离大量与函数功能本身无关的雷同代码并重复应用。</p>
<h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><ul>
<li>引入日志</li>
<li>函数执行时间统计</li>
<li>执行函数前的预备处理</li>
<li>执行函数后的清理功能</li>
<li>权限校验等场景</li>
<li>缓存</li>
</ul>
<h3 id="一个函数同时被多个装饰器装饰的执行顺序"><a href="#一个函数同时被多个装饰器装饰的执行顺序" class="headerlink" title="一个函数同时被多个装饰器装饰的执行顺序"></a>一个函数同时被多个装饰器装饰的执行顺序</h3><p> 一个函数如果同时被多个装饰器装饰，由紧靠函数的装饰器先对函数进行装饰，然后返回的结果在给外层的装饰器去执行装饰，依次类推直到所有装饰器都装饰完成，最后会得到一个函数，在执行这个函数的时候，会先执行最外层装饰器的内容，在执行里面装饰器的内容。这个过程有点像我们给一个精美的物品进行一层一层的包装，在包装的时候是从最里面一层层往往包装，拆开的时候又是从外面一层层的拆开。</p>
<h3 id="对比函数、闭包、对象在作为实参时的区别"><a href="#对比函数、闭包、对象在作为实参时的区别" class="headerlink" title="对比函数、闭包、对象在作为实参时的区别"></a>对比函数、闭包、对象在作为实参时的区别</h3><p><strong>函数作为实参</strong>  如果没有()会作为一个功能传入到另一个函数，如果有()，则会传入这个函数的执行结果即返回值<br><strong>闭包作为实参</strong>  会传入较为复杂的功能和数据<br><strong>对象作为实参</strong>  会传入最为复杂的功能和数据，但是对象占用的空间比较大，传递的是很多的功能和数据</p>
<h3 id="通用的装饰器"><a href="#通用的装饰器" class="headerlink" title="通用的装饰器"></a>通用的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_fun</span><span class="params">(fun)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">call_fun</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"----这是前面的功能---权限验证---"</span>)</span><br><span class="line">		ret = fun(*args, **kwargs)</span><br><span class="line">		print(<span class="string">"----这是后面的功能---log日志功能---"</span>)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	<span class="keyword">return</span> call_fun</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI1MjI0NjA4NDQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之copy</title>
    <url>/python/python%E4%B9%8Bcopy/</url>
    <content><![CDATA[<h2 id="Python中的引用、浅拷贝和深拷贝"><a href="#Python中的引用、浅拷贝和深拷贝" class="headerlink" title="Python中的引用、浅拷贝和深拷贝"></a>Python中的引用、浅拷贝和深拷贝</h2><p>在python中，有一句话：<em>一切皆为对象，一切皆为对象的引用</em>，所以<br>只要记住这句话就很容易清楚python中的引用、浅拷贝和深拷贝了。</p>
<h3 id="1、引用"><a href="#1、引用" class="headerlink" title="1、引用"></a>1、引用</h3><p>python中的引用是经常使用的，python的引用可以节省内存，加快速度，因为它不需要开辟内存空间。例如：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这表示让 a 这个变量去指向一个地址，这个地址保存着数据为 1，让变量 b 也去指向这个地址，那么通过 b 我们一样可以找到数据 1，通过地址的指向来<br>来查找到数据，这就是python中的引用；</p>
<h3 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h3><p>浅拷贝 copy.copy()<br>浅拷贝保存的是数据的地址，不保存内容，浅拷贝是需要开辟单独的内存空间来存储地址的，它不能保证<br>数据的独立性。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="comment"># a 的值[1, 2, 3]</span></span><br><span class="line"><span class="comment"># b 的值[1, 2, 3]</span></span><br><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br></pre></td></tr></table></figure>
<p>可以看出 b 的数据和 a 的数据一样，但是 b 的地址和 a 的地址不相同，而且 b 的地址里保存的是列表里元素 1， 2， 3 的地址，b 通过保存的地址信息来获取数据1, 2, 3 可以通过下面的例子得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705456</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br></pre></td></tr></table></figure>
<p>可以看出列表a 和列表 b 里面的元素 1 都指向着同一个地址，当列表 a 的第一个元素的值变为8时，即指向一个新的保存数据为 8 的地址时，列表b 的第一个元素仍然保存的是元素 1 的地址，此时可以看出，浅拷贝只是把数据的地址保存了，并没有保存数据本身，当列表中如果有元素为可变的列表或字典类时，因为拷贝的是列表或字典所对应的地址，如果列表或字典中有元素发生改变，则浅拷贝的列表也会跟着改变，不能保证数据的独立性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">d = copy.copy(c)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4]]</span></span><br><span class="line"><span class="comment"># d=[1, 2, [3, 4]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br><span class="line">id(c[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line">id(d[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line"></span><br><span class="line">c[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">d <span class="comment"># d=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">a <span class="comment"># [1, 2, 3]</span></span><br><span class="line">b <span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h3><p>深拷贝copy.deepcopy()<br>python中，深拷贝在浅拷贝的基础上更进一步，深拷贝保存的是数据的本身，一旦进行深拷贝，则拷贝后的内容不仅和原本的内容完全一样，而且跟原来的没有任何联系，充分保证了数据的独立性。<br>深拷贝相当于在内存中开辟了一片新的内存，不再用来保存数据的地址，而是用新的地址来保存相同的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4, 5]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure>
<p>可以看出深拷贝是把列表里的数据保存了，和浅拷贝不同，当列表 a 发生改变时，列表 b 并不会跟着改变，这样充分体现了深拷贝可以保证数据的独立性。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python版布隆过滤器</title>
    <url>/python/python%E7%89%88%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="首先导包"><a href="#首先导包" class="headerlink" title="首先导包"></a>首先导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-conding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> six</span><br><span class="line"><span class="keyword">import</span> redis</span><br></pre></td></tr></table></figure>

<h3 id="定义哈希Map类"><a href="#定义哈希Map类" class="headerlink" title="定义哈希Map类"></a>定义哈希Map类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleHash</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""根据提供的原始数据，和预定义的多个salt，生成多个hash值"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, hash_func_name=<span class="string">'md5'</span>)</span>:</span></span><br><span class="line">        self.hash_func = getattr(hashlib, hash_func_name)</span><br><span class="line">        <span class="keyword">if</span> len(salts) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"please provide more than 3 element(salt) in the salts"</span>)</span><br><span class="line">        self.salts = salts</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_safe_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param data: 原始数据</span></span><br><span class="line"><span class="string">        :return: 处理成对应python版本可以被hash函数的update方法解析的数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> six.PY3:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, bytes):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, unicode):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span>  Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_hash_values</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""根据提供的原始数据, 返回多个hash函数值"""</span></span><br><span class="line">        hash_values = []</span><br><span class="line">        hash_obj = self.hash_func()</span><br><span class="line">        <span class="keyword">for</span> salt <span class="keyword">in</span> self.salts:</span><br><span class="line">            hash_obj.update(self._safe_data(data))</span><br><span class="line">            hash_obj.update(self._safe_data(salt))</span><br><span class="line">            ret = hash_obj.hexdigest()</span><br><span class="line">            hash_values.append(int(ret, <span class="number">16</span>))</span><br><span class="line">        <span class="keyword">return</span> hash_values</span><br></pre></td></tr></table></figure>

<h3 id="定义布隆过滤器"><a href="#定义布隆过滤器" class="headerlink" title="定义布隆过滤器"></a>定义布隆过滤器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""布隆过滤器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, redis_host=<span class="string">"localhost"</span>, redis_port=<span class="number">6379</span>, redis_db=<span class="number">0</span>, redis_key=<span class="string">"bloomfilter"</span>)</span>:</span></span><br><span class="line">        self.redis_host = redis_host</span><br><span class="line">        self.redis_port = redis_port</span><br><span class="line">        self.redis_db = redis_db</span><br><span class="line">        self.redis_key = redis_key</span><br><span class="line">        self.client = self._get_redis_cli()</span><br><span class="line">        self.multiple_hash = MultipleHash(salts=salts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_redis_cli</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个redis连接对象"""</span></span><br><span class="line">        pool = redis.ConnectionPool(host=self.redis_host, port=self.redis_port, db=self.redis_db)</span><br><span class="line">        client = redis.StrictRedis(connection_pool=pool)</span><br><span class="line">        <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            self.client.setbit(self.redis_key, offset, <span class="number">1</span>)  <span class="comment"># default 0, set 1 when match</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_offset</span><span class="params">(self, hash_value)</span>:</span></span><br><span class="line">        <span class="comment"># (2**9 * 2**20 * 2**3): the len of hash list 哈希表的长度</span></span><br><span class="line">        <span class="keyword">return</span> hash_value % (<span class="number">2</span>**<span class="number">9</span> * <span class="number">2</span>**<span class="number">20</span> * <span class="number">2</span>**<span class="number">3</span>)  <span class="comment"># Mb -&gt; bit</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_exists</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            v = self.client.getbit(self.redis_key, offset)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                self.save(data)  <span class="comment"># 如果不存在，保存数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="string">"asfdsafweafxc"</span>, <span class="string">"123"</span>, <span class="string">"123"</span>, <span class="string">"hello"</span>, <span class="string">"hello"</span>, <span class="string">'haha'</span>]</span><br><span class="line">    bm = BloomFilter(salts=[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>], redis_host=<span class="string">"10.0.12.191"</span>, redis_db=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bm.is_exists(d):</span><br><span class="line">            print(<span class="string">"mapping data success : %s"</span> % d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"find replace data : %s"</span> % d)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pep8的使用</title>
    <url>/python/pep8/</url>
    <content><![CDATA[<h2 id="1-介绍-Introduction"><a href="#1-介绍-Introduction" class="headerlink" title="1 介绍(Introduction)"></a>1 介绍(Introduction)</h2><p>本文档给出了包含主要Python发行版中的标准库的Python代码的编码约定。<br>随着时间的推移，随着更多的约定被识别，过去的约定被语言本身的变化所淘汰，这种风格指南也在不断发展。</p>
<a id="more"></a>
<h2 id="2-代码布局-Code-Lay-Out"><a href="#2-代码布局-Code-Lay-Out" class="headerlink" title="2 代码布局(Code Lay-Out)"></a>2 代码布局(Code Lay-Out)</h2><h3 id="2-1-缩进-Indentation"><a href="#2-1-缩进-Indentation" class="headerlink" title="2.1 缩进(Indentation)"></a>2.1 缩进(Indentation)</h3><p>每个缩进需要使用4个空格。</p>
<p>连续行所包装的元素应该要么采用Python隐式续行，即垂直对齐于圆括号、方括号和花括号，要么采用悬挂缩进。采用悬挂缩进时需考虑以下两点：第一行不应该包括参数，并且在续行中需要再缩进一级以便清楚表示。</p>
<p>正确的写法</p>
<pre><code># 同开始分界符(左括号)对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 续行多缩进一级以同其他代码区别
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 悬挂缩进需要多缩进一级
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)</code></pre><p>错误的写法</p>
<pre><code># 采用悬挂缩进时第一行不应该有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 续行并没有被区分开，因此需要再缩进一级
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre><p>对于延续行，4个空格的规则是可选使用的。</p>
<p>同样可行的例子:</p>
<pre><code># 悬挂缩进可以不采用4空格的缩进方法。
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)</code></pre><p>如果if语句太长，需要用多行书写，2个字符(例如,if)加上一个空格和一个左括号刚好是4空格的缩进，但这对多行条件语句的续行是没用的。因为这会和if语句中嵌套的其他的缩进的语句产生视觉上的冲突。这份PEP中并没有做出明确的说明应该怎样来区分条件语句和if语句中所嵌套的语句。以下几种方法都是可行的，但不仅仅只限于这几种方法：</p>
<pre><code># 不采用额外缩进
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# 增加一行注释，在编辑器中显示时能有所区分
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 在条件语句的续行增加一级缩进
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre><p>多行结束右圆/方/花括号可以单独一行书写，和上一行的缩进对齐：</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
    )</code></pre><p>也可以和多行开始的第一行的第一个字符对齐：</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
)</code></pre><p>Tab还是空格？(Tab Or Space?)</p>
<p>推荐使用空格来进行缩进。</p>
<p>Tab应该只在现有代码已经使用tab进行缩进的情况下使用，以便和现有代码保持一致。</p>
<p>Python 3不允许tab和空格混合使用。</p>
<p>Python 2的代码若有tab和空格混合使用的情况，应该把tab全部转换为只有空格。</p>
<h3 id="2-2-每行最大长度-Maximum-Line-Length"><a href="#2-2-每行最大长度-Maximum-Line-Length" class="headerlink" title="2.2 每行最大长度(Maximum Line Length)"></a>2.2 每行最大长度(Maximum Line Length)</h3><p>将所有行都限制在79个字符长度以内。</p>
<p>对于连续大段的文字（比如文档字符串(docstring)或注释），其结构上的限制更少，这些行应该被限制在72个字符长度内。</p>
<p>限制编辑器的窗口宽度能让好几个文件同时打开在屏幕上显示，在使用代码评审(code review)工具时在两个相邻窗口显示两个版本的代码效果很好。</p>
<p>很多工具的默认自动换行会破坏代码的结构，使代码更难以理解。在窗口大小设置为80个字符的编辑器中，即使在换行时编辑器可能会在最后一列放置一个记号，为避免自动换行也需要限制每行字符长度。一些基于web的工具可能根本没有自动换行的功能。</p>
<p>一些团队会强烈希望行长度比79个字符更长。当代码仅仅只由一个团队维护时，可以达成一致让行长度增加到80到100字符(实际上最大行长是99字符)，注释和文档字符串仍然是以72字符换行。</p>
<p>Python标准库比较传统，将行长限制在79个字符以内（文档字符串/注释为72个字符）。</p>
<p>一种推荐的换行方式是利用Python圆括号、方括号和花括号中的隐式续行。长行可以通过在括号内换行来分成多行。应该最好加上反斜杠来区别续行。</p>
<p>隐式续行</p>
<pre><code>a = (&apos;sdfaf&apos; 
    &apos;test&apos;)</code></pre><p>有时续行只能使用反斜杠。例如，较长的多个with语句不能采用隐式续行，只能接受反斜杠表示换行：</p>
<pre><code>with open(&apos;/path/to/some/file/you/want/to/read&apos;) as file_1, \
     open(&apos;/path/to/some/file/being/written&apos;, &apos;w&apos;) as file_2:
    file_2.write(file_1.read())</code></pre><h3 id="2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator"><a href="#2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator" class="headerlink" title="2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)"></a>2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)</h3><p>长期以来一直推荐的风格是在二元运算符之后换行。但是这样会影响代码可读性，包括两个方面：一是运算符会分散在屏幕上的不同列上，二是每个运算符会留在前一行并远离操作数。所以，阅读代码的时候眼睛必须做更多的工作来确定哪些操作数被加，哪些操作数被减：</p>
<pre><code># 错误的例子：运算符远离操作数
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)</code></pre><p>为了解决这个可读性问题，数学家及其出版商遵循相反的规定。Donald Knuth在他的“电脑和排版”系列中解释了传统的规则：“尽管在段落中的公式总是在二元运算符之后换行，但显示公式时总是在二元运算符之前换行”。</p>
<pre><code># 正确的例子：更容易匹配运算符与操作数
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)</code></pre><p>在Python代码中，只要在统一项目中约定一致，就可以在二元运算符之前或之后换行。对于新编写的代码，建议使用Knuth的风格。</p>
<h3 id="2-4-空行-Blank-Line"><a href="#2-4-空行-Blank-Line" class="headerlink" title="2.4 空行(Blank Line)"></a>2.4 空行(Blank Line)</h3><p>使用2个空行来分隔最外层的函数(function)和类(class)定义。</p>
<p>使用1个空行来分隔类中的方法(method)定义。</p>
<p>可以使用额外的空行（尽量少）来分隔一组相关的函数。在一系列相关的仅占一行的函数之间，空行也可以被省略（比如一组虚函数定义）。</p>
<p>在函数内使用空行（尽量少）使代码逻辑更清晰。</p>
<p>例子：</p>
<pre><code>def func():


    class A(object):
        pass

    def func1():
        a = A()

    def func2():
        print(&apos;aaa&apos;)
        print(&apos;bbb&apos;)</code></pre><p>Python支持control-L（如:^L）换页符作为空格；许多工具将这些符号作为分页符，因此你可以使用这些符号来分页或者区分文件中的相关区域。注意，一些编辑器和基于web的代码预览器可能不会将control-L识别为分页符，而是显示成其他符号。</p>
<h3 id="2-5-源文件编码-Source-File-Encoding"><a href="#2-5-源文件编码-Source-File-Encoding" class="headerlink" title="2.5 源文件编码(Source File Encoding)"></a>2.5 源文件编码(Source File Encoding)</h3><p>Python核心发行版中的代码应该一直使用UTF-8（Python 2中使用ASCII）。</p>
<p>使用ASCII（Python 2）或者UTF-8（Python 3）的文件不应该添加编码声明。</p>
<p>在标准库中，只有用作测试目的，或者注释或文档字符串需要提及作者名字而不得不使用非ASCII字符时，才能使用非默认的编码。否则，在字符串文字中包括非ASCII数据时，推荐使用\x, \u, \U或\N等转义符。</p>
<p>对于Python 3.0及其以后的版本中，标准库遵循以下原则（参见PEP 3131）：Python标准库中的所有标识符都必须只采用ASCII编码的标识符，在可行的条件下也应当使用英文词（很多情况下，使用的缩写和技术术语词都不是英文）。此外，字符串文字和注释应该只包括ASCII编码。只有两种例外：</p>
<p>(a) 测试情况下为了测试非ASCII编码的特性</p>
<p>(b) 作者名字。作者名字不是由拉丁字母组成的也必须提供一个拉丁音译名。</p>
<p>鼓励具有全球受众的开放源码项目采用类似的原则。</p>
<h3 id="2-6-模块引用-Imports"><a href="#2-6-模块引用-Imports" class="headerlink" title="2.6 模块引用(Imports)"></a>2.6 模块引用(Imports)</h3><p>Imports应该分行写，而不是都写在一行，例如：</p>
<pre><code># 分开写
import os
import sys

# 不要像下面一样写在一行
import sys, os</code></pre><p>这样写也是可以的：</p>
<pre><code>from subprocess import Popen, PIPE</code></pre><p>Imports应该写在代码文件的开头，位于模块(module)注释和文档字符串(docstring)之后，模块全局变量(globals)和常量(constants)声明之前。</p>
<p>Imports应该按照下面的顺序分组来写：</p>
<ol>
<li>标准库imports</li>
<li>相关第三方imports</li>
<li>本地应用/库的特定imports</li>
</ol>
<p>如：</p>
<pre><code>import re
from lxml import etree
from ak_spider.common.mongo_models import *
from ak_spider.settings import CAPTCHA_SERVER, AK_PROXY_SERVER, logger</code></pre><p>不同组的imports之前用空格隔开。</p>
<p>推荐使用绝对(absolute)imports，因为这样通常更易读，在import系统没有正确配置（比如中的路径以sys.path结束）的情况下，也会有更好的表现（或者至少会给出错误信息）：</p>
<pre><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre><p>然而，除了绝对imports，显式的相对imports也是一种可以接受的替代方式。特别是当处理复杂的包布局(package layouts)时，采用绝对imports会显得啰嗦。</p>
<pre><code>from . import sibling
from .sibling import example</code></pre><p>标准库代码应当一直使用绝对imports，避免复杂的包布局。</p>
<p>隐式的相对imports应该永不使用，并且Python 3中已经被去掉了</p>
<p>当从一个包括类的模块中import一个类时，通常可以这样写：</p>
<pre><code>from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre><p>如果和本地命名的拼写产生了冲突，应当直接import模块：</p>
<pre><code>import myclass
import foo.bar.yourclass</code></pre><p>然后使用”myclass.MyClass”和”foo.bar.yourclass.YourClass”。</p>
<p>避免使用通配符imports(from <module> import *)，因为会造成在当前命名空间出现的命名含义不清晰，给读者和许多自动化工具造成困扰。有一个可以正当使用通配符import的情形，即将一个内部接口重新发布成公共API的一部分（比如，使用备选的加速模块中的定义去覆盖纯Python实现的接口，预先无法知晓具体哪些定义将被覆盖）。</p>
<p>当使用这种方式重新发布命名时，指南后面关于公共和内部接口的部分仍然适用。</p>
<h3 id="2-7-模块级的双下划线命名-Module-level-dunder-names"><a href="#2-7-模块级的双下划线命名-Module-level-dunder-names" class="headerlink" title="2.7 模块级的双下划线命名(Module level dunder names)"></a>2.7 模块级的双下划线命名(Module level dunder names)</h3><p>模块中的“双下滑线”（变量名以两个下划线开头，两个下划线结尾）变量，比如<strong>all</strong>，<strong>author，</strong>version__等，应该写在文档字符串(docstring)之后，除了form <strong>future</strong>引用(imports)的任何其它类型的引用语句之前。Python要求模块中<strong>future</strong>的导入必须出现在除文档字符串(docstring)之外的任何其他代码之前。</p>
<p>例如：</p>
<pre><code>&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
__version__ = &apos;0.1&apos;
__author__ = &apos;Cardinal Biggles&apos;

import os
import sys</code></pre><h2 id="3-字符串引用-String-Quotes"><a href="#3-字符串引用-String-Quotes" class="headerlink" title="3 字符串引用(String Quotes)"></a>3 字符串引用(String Quotes)</h2><p>在Python中表示字符串时，不管用单引号还是双引号都是一样的。但是不推荐将这两种方式看作一样并且混用。最好选择一种规则并坚持使用。当字符串中包含单引号时，采用双引号来表示字符串，反之也是一样，这样可以避免使用反斜杠，代码也更易读。</p>
<p>对于三引号表示的字符串，使用双引号字符来表示(即用”””而不是’’’)。</p>
<h2 id="4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements"><a href="#4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements" class="headerlink" title="4 表达式和语句中的空格(Whitespace In Expressions And Statements)"></a>4 表达式和语句中的空格(Whitespace In Expressions And Statements)</h2><h3 id="4-1-一些痛点-Pet-Peeves"><a href="#4-1-一些痛点-Pet-Peeves" class="headerlink" title="4.1 一些痛点(Pet Peeves)"></a>4.1 一些痛点(Pet Peeves)</h3><p>在下列情形中避免使用过多的空白：</p>
<p>方括号，圆括号和花括号之后：</p>
<pre><code>#正确的例子:
spam(ham[1], {eggs: 2})

#错误的例子：
spam( ham[ 1 ], { eggs: 2 } )</code></pre><p>逗号，分号或冒号之前：</p>
<pre><code>#正确的例子:
if x == 4: print x, y; x, y = y, x

#错误的例子:
if x == 4 : print x , y ; x , y = y , x</code></pre><p>不过，在切片操作时，冒号和二元运算符是一样的，应该在其左右两边保留相同数量的空格（就像对待优先级最低的运算符一样）。在扩展切片操作中，所有冒号的左右两边空格数都应该相等。不过也有例外，当切片操作中的参数被省略时，应该也忽略空格。</p>
<pre><code>#正确的例子:
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]

#错误的例子:
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]</code></pre><p>在调用函数时传递参数list的括号之前：</p>
<pre><code>#正确的例子:
spam(1)

#错误的例子:
pam (1)</code></pre><p>在索引和切片操作的左括号之前：</p>
<pre><code>#正确的例子:
dct[&apos;key&apos;] = lst[index]

#错误的例子:
dct [&apos;key&apos;] = lst [index]</code></pre><p>赋值(或其他)运算符周围使用多个空格来和其他语句对齐：</p>
<pre><code>#正确的例子:
x = 1
y = 2
long_variable = 3

#错误的例子:
x             = 1
y             = 2
long_variable = 3</code></pre><h3 id="4-2-其他建议-Other-Recommendations"><a href="#4-2-其他建议-Other-Recommendations" class="headerlink" title="4.2 其他建议(Other Recommendations)"></a>4.2 其他建议(Other Recommendations)</h3><p>避免任何行末的空格。因为它通常是不可见的，它可能会令人困惑：例如反斜杠后跟空格和换行符不会作为续行标记。一些编辑器会自动去除行末空格，许多项目（如CPython本身）都有提交前的预处理钩子来自动去除行末空格。</p>
<p>在二元运算符的两边都使用一个空格：赋值运算符(=)，增量赋值运算符(+=, -= etc.)，比较运算符(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算符(and, or, not)。</p>
<p>如果使用了优先级不同的运算符，则在优先级较低的操作符周围增加空白。请你自行判断，不过永远不要用超过1个空格，永远保持二元运算符两侧的空白数量一样。</p>
<pre><code>#正确的例子:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

#错误的例子:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)    </code></pre><p>使用=符号来表示关键字参数或参数默认值时，不要在其周围使用空格。</p>
<pre><code>#正确的例子:
def complex(real, imag=0.0):
return magic(r=real, i=imag)

#错误的例子:
def complex(real, imag = 0.0):
return magic(r = real, i = imag)</code></pre><p>函数注解中的:也遵循一般的:加空格的规则，在-&gt;两侧各使用一个空格。</p>
<pre><code>#正确的例子:
def munge(input: AnyStr): ...
def munge() -&gt; AnyStr: ...

#错误的例子:
def munge(input:AnyStr): ...
def munge()-&gt;PosInt: ...</code></pre><p>在组合使用函数注解和参数默认值时，需要在=两侧各使用一个空格（只有当这个参数既有函数注解，又有默认值的时候）。</p>
<pre><code>#正确的例子:
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

#错误的例子:
def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...</code></pre><p>复合语句（即将多行语句写在一行）一般是不鼓励使用的。</p>
<pre><code>#正确的例子:
if foo == &apos;blah&apos;:
do_blah_thing()
do_one()
do_two()
do_three()

#最好不要这样:
if foo == &apos;blah&apos;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre><p>有时也可以将短小的if/for/while中的语句写在一行，但对于有多个分句的语句永远不要这样做。也要避免将多行都写在一起。</p>
<pre><code>#最好不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
for x in lst: total += x
while t &lt; 10: t = delay()

#绝对不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
list, like, this)

if foo == &apos;blah&apos;: one(); two(); three()</code></pre><h2 id="5-何时在末尾加逗号-When-to-use-trailing-commas"><a href="#5-何时在末尾加逗号-When-to-use-trailing-commas" class="headerlink" title="5 何时在末尾加逗号(When to use trailing commas)"></a>5 何时在末尾加逗号(When to use trailing commas)</h2><p>末尾逗号通常是可选的，除非在定义单元素元组(tuple)时是必需的（而且在Python 2中，它们具有print语句的语义）。为了清楚起见，建议使用括号（技术上来说是冗余的）括起来。</p>
<pre><code>#正确的例子:
FILES = (&apos;setup.cfg&apos;,)

#也正确，但令人困惑:
FILES = &apos;setup.cfg&apos;,</code></pre><p>当使用版本控制系统时，在将来有可能扩展的列表末尾添加冗余的逗号是有好处的。具体的做法是将每一个元素写在单独的一行，并在行尾添加逗号，右括号单独占一行。但是，与有括号在同一行的末尾元素后面加逗号是没有意义的（上述的单元素元组除外）。</p>
<pre><code>#正确的例子:
FILES = [
    &apos;setup.cfg&apos;,
    &apos;tox.ini&apos;,
    ]
initialize(FILES,
           error=True,
           )

#错误的例子:
FILES = [&apos;setup.cfg&apos;, &apos;tox.ini&apos;,]
initialize(FILES, error=True,)</code></pre><h2 id="6-注释-Comments"><a href="#6-注释-Comments" class="headerlink" title="6 注释(Comments)"></a>6 注释(Comments)</h2><p>和代码矛盾的注释还不如没有。当代码有改动时，一定要优先更改注释使其保持最新。</p>
<p>注释应该是完整的多个句子。如果注释是一个短语或一个句子，其首字母应该大写，除非开头是一个以小写字母开头的标识符（永远不要更改标识符的大小写）。</p>
<p>如果注释很短，结束的句号可以被忽略。块注释通常由一段或几段完整的句子组成，每个句子都应该以句号结束。</p>
<p>你应该在句尾的句号后再加上2个空格。</p>
<p>使用英文写作，参考Strunk和White的《The Elements of Style》</p>
<p>来自非英语国家的Python程序员们，请使用英文来写注释，除非你120%确定你的代码永远不会被不懂你所用语言的人阅读到。</p>
<h3 id="6-1-块注释（Block-Comments）"><a href="#6-1-块注释（Block-Comments）" class="headerlink" title="6.1 块注释（Block Comments）"></a>6.1 块注释（Block Comments）</h3><p>块注释一般写在对应代码之前，并且和对应代码有同样的缩进级别。块注释的每一行都应该以#和一个空格开头（除非该文本是在注释内缩进对齐的）。</p>
<p>块注释中的段落应该用只含有单个#的一行隔开。</p>
<h3 id="6-2-行内注释（Inline-Comments）"><a href="#6-2-行内注释（Inline-Comments）" class="headerlink" title="6.2 行内注释（Inline Comments）"></a>6.2 行内注释（Inline Comments）</h3><p>尽量少用行内注释。</p>
<p>行内注释是和代码语句写在一行内的注释。行内注释应该至少和代码语句之间有两个空格的间隔，并且以#和一个空格开始。</p>
<p>行内注释通常不是必要的，在代码含义很明显时甚至会让人分心。请不要这样做：</p>
<pre><code>x = x + 1                 # x自加</code></pre><p>但这样做是有用的：</p>
<pre><code>x = x + 1                 # 边界补偿</code></pre><h3 id="6-3-文档字符串-Documentation-Strings"><a href="#6-3-文档字符串-Documentation-Strings" class="headerlink" title="6.3 文档字符串(Documentation Strings)"></a>6.3 文档字符串(Documentation Strings)</h3><p>要知道如何写出好的文档字符串（docstring），请参考PEP 257</p>
<p>所有的公共模块，函数，类和方法都应该有文档字符串。对于非公共方法，文档字符串不是必要的，但你应该留有注释说明该方法的功能，该注释应当出现在def的下一行。</p>
<p>PEP 257描述了好的文档字符应该遵循的规则。其中最重要的是，多行文档字符串以单行”””结尾，不能有其他字符，例如：</p>
<pre><code>&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre><p>对于仅有一行的文档字符串，结尾处的”””应该也写在这一行。</p>
<h2 id="7-命名约定（Naming-Conventions）"><a href="#7-命名约定（Naming-Conventions）" class="headerlink" title="7 命名约定（Naming Conventions）"></a>7 命名约定（Naming Conventions）</h2><p>Python标准库的命名约定有一些混乱，因此我们永远都无法保持一致。但如今仍然存在一些推荐的命名标准。新的模块和包（包括第三方框架）应该采用这些标准，但若是已经存在的包有另一套风格的话，还是应当与原有的风格保持内部一致。</p>
<h3 id="7-1-首要原则（Overriding-Principle）"><a href="#7-1-首要原则（Overriding-Principle）" class="headerlink" title="7.1 首要原则（Overriding Principle）"></a>7.1 首要原则（Overriding Principle）</h3><p>对于用户可见的公共部分API，其命名应当表达出功能用途而不是其具体的实现细节。</p>
<h3 id="7-2-描述：命名风格（Descriptive-Naming-Styles）"><a href="#7-2-描述：命名风格（Descriptive-Naming-Styles）" class="headerlink" title="7.2 描述：命名风格（Descriptive: Naming Styles）"></a>7.2 描述：命名风格（Descriptive: Naming Styles）</h3><p>存在很多不同的命名风格，最好能够独立地从命名对象的用途认出采用了哪种命名风格。</p>
<p>通常区分以下命名样式：</p>
<ul>
<li>b (单个小写字母)</li>
<li>B (单个大写字母)</li>
<li>lowercase(小写)</li>
<li>lower_case_with_underscores(带下划线小写)</li>
<li>UPPERCASE(大写)</li>
<li>UPPER_CASE_WITH_UNDERSCORES(带下划线大写)</li>
<li>CapitalizedWords (也叫做CapWords或者CamelCase – 因为单词首字母大写看起来很像驼峰)。也被称作StudlyCaps。注意：当CapWords里包含缩写时，将缩写部分的字母都大写。HTTPServerError比HttpServerError要好。</li>
<li>mixedCase (注意：和CapitalizedWords不同在于其首字母小写！)</li>
<li>Capitalized_Words_With_Underscores (这种风格超丑！)</li>
</ul>
<p>也有风格使用简短唯一的前缀来表示一组相关的命名。这在Python中并不常见，但为了完整起见这里也捎带提一下。比如，os.stat()函数返回一个tuple，其中的元素名原本为st_mode,st-size,st_mtime等等。（这样做是为了强调和POSIX系统调用结构之间的关系，可以让程序员更熟悉。）</p>
<p>X11库中的公共函数名都以X开头。在Python中这样的风格一般被认为是不必要的，因为属性和方法名之前已经有了对象名的前缀，而函数名前也有了模块名的前缀。</p>
<p>此外，要区别以下划线开始或结尾的特殊形式（可以和其它的规则结合起来）：</p>
<p>_single_leading_underscore: 以单个下划线开头是”内部使用”的弱标志。 比如， from M import *不会import下划线开头的对象。</p>
<p>single_trailing_underscore_: 以单个下划线结尾用来避免和Python关键词产生冲突，例如:</p>
<pre><code>Tkinter.Toplevel(master, class_=&apos;ClassName&apos;)</code></pre><p><strong>double_leading_underscore: 以双下划线开头的风格命名类属性表示触发命名修饰（在FooBar类中，</strong>boo命名会被修饰成_FooBar__boo;）。</p>
<h3 id="7-3-规范：命名约定-Prescriptive-Naming-Conventions"><a href="#7-3-规范：命名约定-Prescriptive-Naming-Conventions" class="headerlink" title="7.3 规范：命名约定(Prescriptive: Naming Conventions)"></a>7.3 规范：命名约定(Prescriptive: Naming Conventions)</h3><h4 id="7-3-1-需要避免的命名-Names-To-Avoid"><a href="#7-3-1-需要避免的命名-Names-To-Avoid" class="headerlink" title="7.3.1 需要避免的命名(Names To Avoid)"></a>7.3.1 需要避免的命名(Names To Avoid)</h4><p>不要使用字符’l’（L的小写的字母），’O’（o大写的字母），或者’I’（i的大写的字母）来作为单个字符的变量名。</p>
<p>在一些字体中，这些字符和数字1和0无法区别开来。比如，当想使用’l’时，使用’L’代替。</p>
<h4 id="7-3-2-ASCII兼容性-ASCII-Compatibility"><a href="#7-3-2-ASCII兼容性-ASCII-Compatibility" class="headerlink" title="7.3.2 ASCII兼容性(ASCII Compatibility)"></a>7.3.2 ASCII兼容性(ASCII Compatibility)</h4><p>标准库中使用的标识符必须与ASCII兼容(参见PEP 3131中的<a href="https://www.python.org/dev/peps/pep-3131/#policy-specification" target="_blank" rel="noopener">policy</a>这一节) 。</p>
<h4 id="7-3-3-包和模块命名-Package-And-Module-Names"><a href="#7-3-3-包和模块命名-Package-And-Module-Names" class="headerlink" title="7.3.3 包和模块命名(Package And Module Names)"></a>7.3.3 包和模块命名(Package And Module Names)</h4><p>模块命名应短小，且为全小写。若下划线能提高可读性，也可以在模块名中使用。Python包命名也应该短小，且为全小写，但不应使用下划线。</p>
<p>当使用C或C++写的扩展模块有相应的Python模块提供更高级的接口时（比如，更加面向对象），C/C++模块名以下划线开头（例如，_sociket）</p>
<h4 id="7-3-4-类命名-Class-Names"><a href="#7-3-4-类命名-Class-Names" class="headerlink" title="7.3.4 类命名(Class Names)"></a>7.3.4 类命名(Class Names)</h4><p>类命名应该使用驼峰（CapWords）的命名约定。</p>
<p>当接口已有文档说明且主要是被用作调用时，也可以使用函数的命名约定。</p>
<p>注意对于内建命名(builtin names)有一个特殊的约定：大部分内建名都是一个单词（或者两个一起使用的单词），驼峰(CapWords)的约定只对异常命名和内建常量使用。</p>
<h4 id="7-3-5-类型变量命名-Type-variable-names"><a href="#7-3-5-类型变量命名-Type-variable-names" class="headerlink" title="7.3.5 类型变量命名(Type variable names)"></a>7.3.5 类型变量命名(Type variable names)</h4><p>PEP 484中引入的类型变量名称通常应使用简短的驼峰命名: T，AnyStr，Num。 建议将后缀_co或_contra添加到用于声明相应的协变(covariant)和逆变(contravariant)的行为。例如：</p>
<pre><code>from typing import TypeVar

VT_co = TypeVar(&apos;VT_co&apos;, covariant=True)
KT_contra = TypeVar(&apos;KT_contra&apos;, contravariant=True)</code></pre><h4 id="7-3-6-异常命名-Exception-Names"><a href="#7-3-6-异常命名-Exception-Names" class="headerlink" title="7.3.6 异常命名(Exception Names)"></a>7.3.6 异常命名(Exception Names)</h4><p>由于异常实际上也是类，因此类命名约定也适用与异常。不同的是，如果异常实际上是抛出错误的话，异常名前应该加上”Error”的前缀。</p>
<h4 id="7-3-7-全局变量命名-Global-Variable-Names"><a href="#7-3-7-全局变量命名-Global-Variable-Names" class="headerlink" title="7.3.7 全局变量命名(Global Variable Names)"></a>7.3.7 全局变量命名(Global Variable Names)</h4><p>（在此之前，我们先假定这些变量都仅在同一个模块内使用。）这些约定同样也适用于函数命名。</p>
<p>对于引用方式设计为from M import *的模块，应该使用<strong>all</strong>机制来避免import全局变量，或者采用下划线前缀的旧约定来命名全局变量，从而表明这些变量是“模块非公开的”。</p>
<h4 id="7-3-8-函数命名-Function-Names"><a href="#7-3-8-函数命名-Function-Names" class="headerlink" title="7.3.8 函数命名(Function Names)"></a>7.3.8 函数命名(Function Names)</h4><p>函数命名应该都是小写，必要时使用下划线来提高可读性。</p>
<p>只有当已有代码风格已经是混合大小写时（比如threading.py），为了保留向后兼容性才使用混合大小写。</p>
<h4 id="7-3-9-函数和方法参数-Function-And-Method-Arguments"><a href="#7-3-9-函数和方法参数-Function-And-Method-Arguments" class="headerlink" title="7.3.9 函数和方法参数(Function And Method Arguments)"></a>7.3.9 函数和方法参数(Function And Method Arguments)</h4><p>实例方法的第一参数永远都是self。</p>
<p>类方法的第一个参数永远都是cls。</p>
<p>在函数参数名和保留关键字冲突时，相对于使用缩写或拼写简化，使用以下划线结尾的命名一般更好。比如，class_比clss更好。（或许使用同义词避免这样的冲突是更好的方式。）</p>
<h4 id="7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables"><a href="#7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables" class="headerlink" title="7.3.10 方法命名和实例变量(Method Names And Instance Variables)"></a>7.3.10 方法命名和实例变量(Method Names And Instance Variables)</h4><p>使用函数命名的规则：小写单词，必要时使用下划线分开以提高可读性。</p>
<p>仅对于非公开方法和变量命名在开头使用一个下划线。</p>
<p>避免和子类的命名冲突，使用两个下划线开头来触发Python的命名修饰机制。</p>
<p>Python类名的命名修饰规则：如果类Foo有一个属性叫<strong>a，不能使用Foo.</strong>a的方式访问该变量。（有用户可能仍然坚持使用Foo._Foo__a的方法访问。）一般来说，两个下划线开头的命名方法仅用于避免与设计为子类的类中的属性名冲突。</p>
<h4 id="7-3-11-常量-Constants"><a href="#7-3-11-常量-Constants" class="headerlink" title="7.3.11 常量(Constants)"></a>7.3.11 常量(Constants)</h4><p>常量通常是在模块级别定义的，使用全部大写并用下划线将单词分开。如：MAX_OVERFLOW和TOTAL 。</p>
<h4 id="7-3-12-继承的设计-Designing-For-Inheritance"><a href="#7-3-12-继承的设计-Designing-For-Inheritance" class="headerlink" title="7.3.12 继承的设计(Designing For Inheritance)"></a>7.3.12 继承的设计(Designing For Inheritance)</h4><p>记得永远区别类的方法和实例变量（属性）应该是公开的还是非公开的。如果有疑虑的话，请选择非公开的；因为之后将非公开属性变为公开属性要容易些。</p>
<p>公开属性是那些你希望和你定义的类无关的客户来使用的，并且确保不会出现向后不兼容的问题。非公开属性是那些不希望被第三方使用的部分，你可以不用保证非公开属性不会变化或被移除。</p>
<p>我们在这里没有使用“私有（private）”这个词，因为在Python里没有什么属性是真正私有的（这样设计省略了大量不必要的工作）。</p>
<p>另一类属性属于子类API的一部分（在其他语言中经常被称为”protected”）。一些类是为继承设计的，要么扩展要么修改类的部分行为。当设计这样的类时，需要谨慎明确地决定哪些属性是公开的，哪些属于子类API，哪些真的只会被你的基类调用。</p>
<p>请记住以上几点，下面是Python风格的指南：</p>
<ul>
<li>公开属性不应该有开头下划线。</li>
<li>如果公开属性的名字和保留关键字有冲突，在你的属性名尾部加上一个下划线。这比采用缩写和简写更好。（然而，和这条规则冲突的是，‘cls’对任何变量和参数来说都是一个更好地拼写，因为大家都知道这表示class，特别是在类方法的第一个参数里。）</li>
<li>对于简单的公共数据属性，最后仅公开属性名字，不要公开复杂的调用或设值方法。请记住，如果你发现一个简单的数据属性需要增加功能行为时，Python为功能增强提供了一个简单的途径。这种情况下，使用Properties注解将功能实现隐藏在简单数据属性访问语法之后。注意 1：Properties注解仅仅对新风格类有用。<br>注意 2：尽量保证功能行为没有副作用，尽管缓存这种副作用看上去并没有什么大问题。<br>注意 3: 对计算量大的运算避免试用properties；属性的注解会让调用者相信访问的运算量是相对较小的。</li>
<li>如果你的类将被子类继承的话，你有一些属性并不想让子类访问，考虑将他们命名为两个下划线开头并且结尾处没有下划线。这样会触发Python命名修饰算法，类名会被修饰添加到属性名中。这样可以避免属性命名冲突，以免子类会不经意间包含相同的命名。注意 1：注意命名修饰仅仅是简单地将类名加入到修饰名中，所以如果子类有相同的类名合属性名，你可能仍然会遇到命名冲突问题。<br>注意 2：命名修饰可以有特定用途，比如在调试时，__getattr__()比较不方便。然而命名修饰算法的可以很好地记录，并且容意手动执行。<br>注意 3：不是所有人都喜欢命名修饰。需要试着去平衡避免偶然命名冲突的需求和高级调用者使用的潜在可能性。</li>
</ul>
<h3 id="7-4-公开和内部接口-Public-And-Internal-Interfaces"><a href="#7-4-公开和内部接口-Public-And-Internal-Interfaces" class="headerlink" title="7.4 公开和内部接口(Public And Internal Interfaces)"></a>7.4 公开和内部接口(Public And Internal Interfaces)</h3><p>任何向后兼容性保证仅对公开接口适用。相应地，用户能够清楚分辨公开接口和内部接口是很重要的。</p>
<p>文档化的接口被认为是公开的，除非文档中明确申明了它们是临时的或者内部接口，不保证向后兼容性。所有文档中未提到的接口应该被认为是内部的。</p>
<p>为了更好审视公开接口和内部接口，模块应该在<strong>all属性中明确申明公开API是哪些。将</strong>all__设为空list表示该模块中没有公开API。</p>
<p>即使正确设置了__all属性，内部接口（包，模块，类，函数，属性或其他命名）也应该以一个下划线开头。</p>
<p>如果接口的任一一个命名空间（包，模块或类）是内部的，那么该接口也应该是内部的</p>
<p>引用的命名应该永远被认为是实现细节。其他模块不应当依赖这些非直接访问的引用命名，除非它们在文档中明确地被写为模块的API，例如os.path或者包的<strong>init</strong>模块，那些从子模块展现的功能。</p>
<h2 id="8-编程建议-Programming-Recommendations"><a href="#8-编程建议-Programming-Recommendations" class="headerlink" title="8 编程建议(Programming Recommendations)"></a>8 编程建议(Programming Recommendations)</h2><p>1 代码应该以不影响其他Python实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。</p>
<p>例如，不要依赖于 CPython 在字符串拼接时的优化实现，像这种语句形式a += b和a = a + b。即使是 CPython（仅对某些类型起作用） 这种优化也是脆弱的，不是在所有的实现中都不使用引用计数。在库中性能敏感的部分，用’’.join形式来代替。这会确保在所有不同的实现中字符串拼接是线性时间的。</p>
<p>2 与单例作比较，像None应该用is或is not，从不使用==操作符。</p>
<p>同样的，当心if x is not None这样的写法，你是不知真的要判断x不是None。例如，测试一个默认值为None的变量或参数是否设置成了其它值，其它值有可能是某种特殊类型（如容器），这种特殊类型在逻辑运算时其值会被当作Flase来看待。</p>
<p>用is not操作符而不是not … is。虽然这两个表达式是功能相同的，前一个是更可读的，是首选。</p>
<p>推荐的写法:</p>
<pre><code>if foo is not None:</code></pre><p>不推荐的写法:</p>
<pre><code>if not foo is None:</code></pre><p>3 用富比较实现排序操作的时候，最好实现所有六个比较操作符（ __eq__ 、 __ne__ 、 __lt__ , __le__ , __gt__ , __ge__），而不是依靠其他代码来进行特定比较。</p>
<p>为了最大限度的减少工作量，functools.total_ordering()装饰器提供了一个工具去生成缺少的比较方法。</p>
<p>PEP 207 说明了 Python 假定的所有反射规则。因此，解释器可能使用y &gt; x替换x &lt; y，使用y &gt;= x替换x &lt;= y，也可能交换x == y和x != y的操作数。sort()和min()操作肯定会使用&lt;操作符，max()函数肯定会使用&gt;操作符。当然，最好是六个操作符都实现，以便在其他情况下不会出现混淆。</p>
<p>4 始终使用def语句来代替直接绑定了一个lambda表达式的赋值语句。</p>
<p>推荐的写法:</p>
<pre><code>def f(x): return 2*x</code></pre><p>不推荐的写法:</p>
<pre><code>f = lambda x: 2*x</code></pre><p>第一个表单意味着生成的函数对象的名称是’f’而不是通用的’<lambda>‘。通常这对异常追踪和字符串表述是更有用的。使用赋值语句消除了使用lambda表达式可以提供，而一个显式的def语句不能提供的唯一好处，如，lambda能镶嵌在一个很长的表达式里。</p>
<p>5 异常类应派生自Exception而不是BaseException。直接继承BaseException是为Exception保留的，从BaseException继承并捕获异常这种做法几乎总是错的。</p>
<p>设计异常的层次结构，应基于那些可能出现异常的代码，而不是引发异常的位置。编码的时候，以回答“出了什么问题？”为目标，而不是仅仅指出“这里出现了问题”（见 PEP 3151 一个内建异常结构层次的例子）。</p>
<p>类的命名约定适用于异常，如果异常类是一个错误，你应该给异常类加一个后缀Error。用于非本地流程控制或者其他形式的信号的非错误异常不需要一个特殊的后缀。</p>
<p>6 适当的使用异常链。在 Python 3 里，应该使用raise X from Y来指示显式替换，而不会丢失原始的追溯。</p>
<p>当有意替换一个内部的异常时（在 Python 2 用raise X，Python 3.3+ 用raise X from None），请确保将相关详细信息转移到新异常中（例如，将KeyError转换为AttributeError时保留属性名称，或将原始异常的文本嵌入到新的异常消息中）。</p>
<p>7 在 Python 2 里抛出异常时，用raise ValueError(‘message’)代替旧式的raise ValueError, ‘message’。</p>
<p>在 Python 3 之后的语法里，旧式的异常抛出方式是非法的。</p>
<p>使用括号形式的异常意味着，当你传给异常的参数过长或者包含字符串格式化时，你就不需要使用续行符了，这要感谢括号！</p>
<p>8 捕获异常时，尽可能使用明确的异常，而不是用一个空的except:语句。</p>
<p>例如，用：</p>
<pre><code>try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre><p>一个空的except:语句将会捕获到SystemExit和KeyboardInterrupt异常，很难区分程序的中断到底是Ctrl+C还是其他问题引起的。如果你想捕获程序的所有错误，使用except Exception:(空except:等同于except BaseException)。</p>
<p>一个好的经验是限制使用空except语句，除了这两种情况：</p>
<ul>
<li>如果异常处理程序会打印出或者记录回溯信息；至少用户意识到错误的存在。</li>
<li>如果代码需要做一些清理工作，但后面用raise向上抛出异常。try .. finally是处理这种情况更好的方式。</li>
</ul>
<p>9 绑定异常给一个名字时，最好使用 Python 2.6 里添加的明确的名字绑定语法：</p>
<pre><code>try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre><p>Python 3 只支持这种语法，避免与基于逗号的旧式语法产生二义性。</p>
<p>10 捕获操作系统错误时，最好使用 Python 3.3 里引进的明确的异常结构层次，而不是内省的errno值。</p>
<p>11 另外，对于所有try / except子句，将try子句限制为必需的绝对最小代码量。同样，这样可以避免屏蔽错误。</p>
<p>推荐的写法：</p>
<pre><code>try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)</code></pre><p>不推荐的写法：</p>
<pre><code>try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre><p>12 当某个资源仅被特定代码段使用，用with语句确保其在使用后被立即干净的清除了，try/finally也是也接受的。</p>
<p>13 当它们做一些除了获取和释放资源之外的事的时候，上下文管理器应该通过单独的函数或方法调用。例如：</p>
<p>推荐的写法:</p>
<pre><code>with conn.begin_transaction():
    do_stuff_in_transaction(conn)</code></pre><p>不推荐的写法：</p>
<pre><code>with conn:
    do_stuff_in_transaction(conn)</code></pre><p>第二个例子没有提供任何信息来表明<strong>enter</strong>和<strong>exit</strong>方法在完成一个事务后做了一些除了关闭连接以外的其它事。在这种情况下明确是很重要的。</p>
<p>14 坚持使用return语句。函数内的return语句都应该返回一个表达式，或者None。如果一个return语句返回一个表达式，另一个没有返回值的应该用return None清晰的说明，并且在一个函数的结尾应该明确使用一个return语句（如果有返回值的话）。</p>
<p>推荐的写法：</p>
<pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x &lt; 0:
        return None
    return math.sqrt(x)</code></pre><p>不推荐的写法：</p>
<pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)

def bar(x):
    if x &lt; 0:
        return
    return math.sqrt(x)</code></pre><p>15 用字符串方法代替字符串模块。</p>
<p>字符串方法总是快得多，并且与unicode字符串共享相同的API。如果需要与2.0以下的Python的向后兼容，则覆盖此规则。</p>
<p>16 用’’.startswith()和’’.endswith()代替字符串切片来检查前缀和后缀。</p>
<p>startswith()和endswith()是更简洁的，不容易出错的。例如：</p>
<pre><code>#推荐的写法：
if foo.startswith(&apos;bar&apos;):

#不推荐的写法：
if foo[:3] == &apos;bar&apos;:</code></pre><p>17 对象类型的比较应该始终使用isinstance()而不是直接比较。</p>
<pre><code>#推荐的写法：
if isinstance(obj, int):

#不推荐的写法：
if type(obj) is type(1):</code></pre><p>当比较一个对象是不是字符串时，记住它有可能也是一个 unicode 字符串！在 Python 2 里面，str和unicode有一个公共的基类叫basestring，因此你可以这样做：</p>
<pre><code>if isinstance(obj, basestring):</code></pre><p>注意，在 Python 3 里面，unicode和basestring已经不存在了（只有str），byte对象不再是字符串的一种（被一个整数序列替代）。</p>
<p>18 对于序列（字符串、列表、元组）来说，空的序列为False：</p>
<p>正确的写法：</p>
<pre><code>if not seq:
if seq:</code></pre><p>错误的写法：</p>
<pre><code>if len(seq):
if not len(seq):</code></pre><p>19 不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，一些编辑器（或者，reindent.py）会将其裁剪掉。</p>
<p>20 不要用==比较True和False。</p>
<pre><code>#推荐的写法：
if greeting:

#不推荐的写法：
if greeting == True:

#更加不推荐的写法：
if greeting is True:</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>
