<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis缓存</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="redis关于缓存的一些问题"><a href="#redis关于缓存的一些问题" class="headerlink" title="redis关于缓存的一些问题"></a>redis关于缓存的一些问题</h2><p>&emsp;&emsp; 缓存的作用：前台发送获取数据的请求，后台先查询缓存是否有需要的数据，存在则直接返回结果，不存在则从数据库中查询，查询到数据则更新缓存，返回结果，没有查询到返回定义的状态信息；</p><p>&emsp;&emsp;业务场景中，当我们需要设计一个缓存系统时，不得不考虑缓存所面对的一些问题</p><ul><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩<a id="more"></a><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3></li><li>描述：</li></ul><p>&emsp;&emsp;缓存穿透是指缓存和数据库中都没有数据，用户不断的发送请求，由于缓存是不命中被动写入的，而出于容错考虑，存储层数据库查不到数据则不写入缓存，这将导致每个请求都会进行数据库的查询，失去了缓存的意义；</p><ul><li>场景：</li></ul><p>&emsp;&emsp; 可能会有人利用不存在的key频繁的请求数据，导致数据库压力过大甚至直接挂掉；</p><ul><li>解决方案：</li></ul><p>&emsp;&emsp; 1、接口层进行key的校验，比如用户鉴权校验，用户ID校验；能够确定不存在key的直接进行拦截；</p><p>&emsp;&emsp; 2、对不存在的key直接设置空值，设置过期时间，避免用户短时间用同一个key频繁请求；</p><p>&emsp;&emsp; 3、<a href="https://blog.leslie168.com/数据库/redis/python版布隆过滤器/">使用布隆过滤器</a></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li>描述：</li></ul><p>&emsp;&emsp; 缓存击穿是指缓存中没有的数据但是存储层数据库中有的数据，一般出现的情况是缓存时间到期了，这时由于并发用户请求太多，同时读取缓存没有数据，又同时去查询数据库，导致数据库压力过大；</p><ul><li>解决方案：</li></ul><p>&emsp;&emsp; 1、设置热点数据不过期或加大过期时间；</p><p>&emsp;&emsp; 2、接口限流，熔断，降级；重要的接口做好限流策略，防止用户恶意刷接口；当接口中的某些服务不可用时，进行熔断，失败快速返回机制；</p><p>&emsp;&emsp; 3、加互斥锁；第一个读取缓存的请求发现没有数据则获取锁，查询数据库更新缓存后释放锁并返回结果，则其他线程请求获取锁失败则等待并重新从缓存中读取数据；</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li>描述：</li></ul><p>&emsp;&emsp; 缓存雪崩是指缓存中的数据大批量到过期时间，而查询数据量过大，引起数据库压力过大甚至宕机；和缓存击穿的区别在于缓存击穿是并发查询同一条数据，缓存雪崩是大批量不同数据到过期时间失效从而查询数据库；</p><ul><li>解决方案：</li></ul><p>&emsp;&emsp; 1、缓存数据的过期时间随机设定，防止同一时间大批量的数据过期失效；</p><p>&emsp;&emsp; 2、分布式部署缓存的话，将热点数据均匀分布在不同的缓存数据库中；</p><p>&emsp;&emsp; 3、设置热点数据不过期；</p>]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="redis数据库基础知识"><a href="#redis数据库基础知识" class="headerlink" title="redis数据库基础知识"></a>redis数据库基础知识</h2><h3 id="redis常用的5种数据类型"><a href="#redis常用的5种数据类型" class="headerlink" title="redis常用的5种数据类型"></a>redis常用的5种数据类型</h3><ul><li>string 字符串（可以为整形、浮点型和字符串，统称为元素）</li><li>list 列表（实现队列,元素不唯一，先入先出原则）</li><li>set 集合（各不相同的元素）</li><li>hash hash散列值（hash的key必须是唯一的）</li><li>sort set 有序集合</li></ul><h3 id="redis不常用的三种类型"><a href="#redis不常用的三种类型" class="headerlink" title="redis不常用的三种类型"></a>redis不常用的三种类型</h3><a id="more"></a><ul><li>geospatial</li></ul><p>&emsp;&emsp;该功能可以推算出地理位置信息，两地之间的距离；</p><ul><li>hyperloglog</li></ul><p>&emsp;&emsp;基数: 数学上集合的元素个数，不能重复；</p><p>&emsp;&emsp; 该数据结构就是基于基数统计的算法，主要应用场景是计算网站的访问量；</p><ul><li>bitmap</li></ul><p>&emsp;&emsp; 位图，通过最小单位bit来进行0或1的设置，表示某个元素对应的值或是状态；常用于统计用户的二元性信息，比如是否登录，是否打卡，性别等等；</p><h3 id="redis到底是单线程还是多线程"><a href="#redis到底是单线程还是多线程" class="headerlink" title="redis到底是单线程还是多线程"></a>redis到底是单线程还是多线程</h3><p>redis不能简单的说是单线程的，redis是单线程模型，指的是执行命令的核心模块是单线程的，就整个redis实例而言，在4.0之后的版本中引入了惰性删除，也叫异步删除，这是由额外的线程执行的，例如删除一个key,同步的话del key,异步的话就是unlink key;</p><p>这样处理的优点就是不会使redis的主线程卡顿，把这些删除操作交给后台线程来执行；持久化，集群数据同步等等都是由额外的子线程执行的；</p><h3 id="redis单线程高效的原因"><a href="#redis单线程高效的原因" class="headerlink" title="redis单线程高效的原因"></a>redis单线程高效的原因</h3><ul><li>基于内存操作</li></ul><p>&emsp;&emsp;redis所有的数据都是存在内存中的，所有的运算都是内存级别的，所以性能比较高；</p><ul><li>数据结构简单</li></ul><p>&emsp;&emsp; redis的数据结构都是简单的基础类型的数据结构，这些类型数据结构的查询和操作的时间复杂度都是O(1)；</p><ul><li>I/O多路复用的设计模式</li></ul><p>&emsp;&emsp;redis使用i/o多路复用来监听多个socket连接客户端，这样就可以使用单线程来处理多个情况；减少了线程切换和资源竞争的消耗，从而提高了效率；</p><h3 id="redis的性能瓶颈"><a href="#redis的性能瓶颈" class="headerlink" title="redis的性能瓶颈"></a>redis的性能瓶颈</h3><p>redis是基于内存操作的，它的性能瓶颈来自于内存和网络带宽，而不是cpu，既然cpu不是主要原因，那么采用单线程模式是非常合适的；</p><h3 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h3><ul><li><a href="https://blog.leslie168.com/数据库/redis/redis缓存/">缓存</a></li><li>排行榜</li><li>任务队列</li><li>计数(利用redis的原子递增)</li><li>处理带有过期时间的任务</li></ul><h3 id="redis的回收策略"><a href="#redis的回收策略" class="headerlink" title="redis的回收策略"></a>redis的回收策略</h3><ul><li><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p></li><li><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p></li><li><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p>no-enviction（驱逐）：禁止驱逐数据，不回收</p></li></ul><p>使用策略规则：</p><p>&emsp;&emsp; 1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru；</p><p>&emsp;&emsp; 2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random；</p>]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>myql查询语句优化</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="Sql语句优化和索引"><a href="#Sql语句优化和索引" class="headerlink" title="Sql语句优化和索引"></a>Sql语句优化和索引</h2><h3 id="Innerjoin和左连接，右连接，子查询"><a href="#Innerjoin和左连接，右连接，子查询" class="headerlink" title="Innerjoin和左连接，右连接，子查询"></a>Innerjoin和左连接，右连接，子查询</h3><ul><li><p>inner join内连接也叫等值连接是，left/rightjoin是外连接。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A LEFT JOIN B ON <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id =<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id;</span><br><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A RIGHT JOIN ON B <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id= <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id;</span><br><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A INNER JOIN ON <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id =<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id;</span><br></pre></td></tr></table></figure><p>经过来之多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A,B WHERE <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id = <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id;</span><br></pre></td></tr></table></figure><p>推荐：能用inner join连接尽量使用inner join连接</p><a id="more"></a></li><li><p>子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">Select</span>* <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> id&gt;=<span class="number">3000</span> <span class="keyword">and</span> A.<span class="built_in">uuid</span>=B.<span class="built_in">uuid</span>);</span><br></pre></td></tr></table></figure><p>A表的数据为十万级表，B表为百万级表，在本机执行差不多用2秒左右，我们可以通过explain可以查看到子查询是一个相关子查询(DEPENDENCE SUBQUERY);Mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。<br>一种简单的优化就是用innerjoin的方法来代替子查询，查询语句改为：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">Select</span>* <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">using</span>(<span class="built_in">uuid</span>) <span class="keyword">where</span> b.<span class="built_in">uuid</span>&gt;=<span class="number">3000</span>;</span><br></pre></td></tr></table></figure><p>这个语句执行测试不到一秒；</p></li><li><p>在使用ON 和 WHERE 的时候，记得它们的顺序，如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A LEFT JOIN B ON <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id =<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id WHERE B.NAME=’XXX’</span><br></pre></td></tr></table></figure><p>执行过程会先执行ON 后面先过滤掉B表的一些行数。然而WHERE是后再过滤他们两个连接产生的记录。<br>不过在这里提醒一下大家：ON后面的条件只能过滤出B表的条数，但是连接返回的记录的行数还是A表的行数是一样。如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A LEFT JOIN B ON <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id =<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id;</span><br></pre></td></tr></table></figure><p>返回的记录数是A表的条数，ON后面的条件只起到过滤B表的记录数，而</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SELECT <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>name,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>name FROM A ,B WHERE <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>id = <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>id</span><br></pre></td></tr></table></figure><p>返回的条数，是笛卡尔积后，符合A.id = B.id这个条件的记录</p></li><li><p>使用JOIN时候，应该用小的结果驱动打的结果（left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向），同事尽量把牵涉到多表联合的查询拆分多个query(多个表查询效率低，容易锁表和阻塞)。如：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B ona.id=B.ref_id <span class="keyword">where</span> B.ref_id&gt;<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> A wehre <span class="keyword">id</span> &gt;<span class="number">10</span>) T1 <span class="keyword">left</span> <span class="keyword">join</span> B onT1.id=B.ref_id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="建立索引-加快查询性能"><a href="#建立索引-加快查询性能" class="headerlink" title="建立索引,加快查询性能."></a>建立索引,加快查询性能.</h3><h3 id="limit千万级分页的时候优化"><a href="#limit千万级分页的时候优化" class="headerlink" title="limit千万级分页的时候优化"></a>limit千万级分页的时候优化</h3><ul><li>在我们平时用limit,如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>这样在表数据很少的时候，看不出什么性能问题，倘若到达千万级，如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> limit10000000,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>虽然都是只查询10记录，但是这个就性能就让人受不了了。所以为什么当表数据很大的时候，我们还继续用持久层框架如hibernate,ibatis就会有一些性能问题，除非持久层框架对这些大数据表做过优化。</li><li>在遇见上面的情况，我们可以用另外一种语句优化，如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span>&gt;=(<span class="keyword">Select</span> idfrom a <span class="keyword">limit</span> <span class="number">10000000</span>,<span class="number">1</span>) <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>确实这样快了很多，不过前提是，id字段建立了索引。也许这个还不是最优的，其实还可以这样写：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">10000000</span><span class="keyword">and</span> <span class="number">10000010</span>;</span><br></pre></td></tr></table></figure>这样的效率更加高。</li></ul><h3 id="尽量避免Select-命令"><a href="#尽量避免Select-命令" class="headerlink" title="尽量避免Select * 命令"></a>尽量避免Select * 命令</h3><p>从表中读取越多的数据，查询会变得更慢。它会增加磁盘的操作时间，还是在数据库服务器与web服务器是独立分开的情况下，你将会经历非常漫长的网络延迟。仅仅是因为数据不必要的在服务器之间传输</p><h3 id="尽量不要使用BY-RAND-命令"><a href="#尽量不要使用BY-RAND-命令" class="headerlink" title="尽量不要使用BY RAND()命令"></a>尽量不要使用BY RAND()命令</h3><p>如果您真需要随机显示你的结果，有很多更好的途径实现。而这个函数可能会为表中每一个独立的行执行BY RAND()命令—这个会消耗处理器的处理能力，然后给你仅仅返回一行</p><h3 id="利用limit-1取得唯一行"><a href="#利用limit-1取得唯一行" class="headerlink" title="利用limit 1取得唯一行"></a>利用limit 1取得唯一行</h3><p>有时要查询一张表时，你要知道需要看一行，你可能去查询一条独特的记录。你可以使用limit 1.来终止数据库引擎继续扫描整个表或者索引,如：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> A  <span class="keyword">where</span> namelike ‘%xxx’ <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样只要查询符合like ‘%xxx’的记录，那么引擎就不会继续扫描表或者索引了。</p><h3 id="尽量少排序"><a href="#尽量少排序" class="headerlink" title="尽量少排序"></a>尽量少排序</h3><p>排序操作会消耗较多的CPU资源，所以减少排序可以在缓存命中率高等</p><h3 id="尽量少OR"><a href="#尽量少OR" class="headerlink" title="尽量少OR"></a>尽量少OR</h3><p>当where子句中存在多个条件以“或”并存的时候，Mysql的优化器并没有很好的解决其执行计划优化问题，再加上mysql特有的sql与Storage分层架构方式，造成了其性能比较地下，很多时候使用union all或者union(必要的时候)的方式代替“or”会得到更好的效果。</p><h3 id="尽量用union-all-代替union"><a href="#尽量用union-all-代替union" class="headerlink" title="尽量用union all 代替union"></a>尽量用union all 代替union</h3><p>union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union.</p><h3 id="避免类型转换"><a href="#避免类型转换" class="headerlink" title="避免类型转换"></a>避免类型转换</h3><p>这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换。人为的上通过转换函数进行转换，直接导致mysql无法使用索引。如果非要转型，应该在传入参数上进行转换</p><h3 id="不要在列上进行运算"><a href="#不要在列上进行运算" class="headerlink" title="不要在列上进行运算"></a>不要在列上进行运算</h3><p>如下面:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * fromusers <span class="keyword">where</span> <span class="keyword">YEAR</span>(adddate)&lt;<span class="number">2007</span>;</span><br></pre></td></tr></table></figure><p>将在每个行进行运算，这些导致索引失效进行全表扫描，因此我们可以改成：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Select * <span class="keyword">from</span><span class="built_in"> users </span>where adddate&lt;’2007-01-01’;</span><br></pre></td></tr></table></figure><h3 id="尽量不要使用NOT-IN和-lt-gt-操作"><a href="#尽量不要使用NOT-IN和-lt-gt-操作" class="headerlink" title="尽量不要使用NOT IN和&lt;&gt;操作"></a>尽量不要使用NOT IN和&lt;&gt;操作</h3><ul><li><p>NOT IN和&lt;&gt;操作都不会使用索引，而是将会进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可以使用id&gt;3 or id &lt;3;如果NOT EXISTS是子查询，还可以尽量转化为外连接或者等值连接，要看具体sql的业务逻辑。</p></li><li><p>把NOT IN转化为LEFT JOIN如：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo <span class="keyword">WHERE</span> CustomerIDNOT <span class="keyword">in</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo );</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo <span class="keyword">LEFT</span> JOINsalesinfoON customerinfo.CustomerID=salesinfo. CustomerID WHEREsalesinfo.CustomerID <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="使用批量插入节省交互（最好是使用存储过程）"><a href="#使用批量插入节省交互（最好是使用存储过程）" class="headerlink" title="使用批量插入节省交互（最好是使用存储过程）"></a>使用批量插入节省交互（最好是使用存储过程）</h3></li></ul><h3 id="锁定表"><a href="#锁定表" class="headerlink" title="锁定表"></a>锁定表</h3><p>尽管事务是维护数据库完整性的一个非常好的方法,但却因为它的独占性,有时会影响数据库的性能,尤其是在很多的应用系统中.由于事务执行的过程中,数据库将会被锁定,因此其他的用户请求只能暂时等待直到该事务结算.如果一个数据库系统只有少数几个用户来使用,事务造成的影响不会成为一个太大问题;但假设有成千上万的用户同时访问一个数据库系统,例如访问一个电子商务网站,就会产生比较严重的响应延迟.其实有些情况下我们可以通过锁定表的方法来获得更好的性能.如:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> inventory write</span><br><span class="line"><span class="keyword">Select</span> quanity <span class="keyword">from</span> inventory whereitem=’book’;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">Update</span> inventory <span class="keyword">set</span> quantity=<span class="number">11</span> whereitem=’book’;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到列表中。包含有write关键字的LOCK TABLE语句可以保证在UNLOCK TABLES命令被执行之前，不会有其他的访问来对inventory进行插入，更新或者删除的操作。</p><h3 id="对多表关联的查询，建立视图"><a href="#对多表关联的查询，建立视图" class="headerlink" title="对多表关联的查询，建立视图"></a>对多表关联的查询，建立视图</h3><p>对多表的关联可能会有性能上的问题，我们可以对多表建立视图，这样操作简单话，增加数据安全性，通过视图，用户只能查询和修改指定的数据。且提高表的逻辑独立性，视图可以屏蔽原有表结构变化带来的影响</p>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><a id="more"></a><p>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p><p>从应用层次来分：普通索引，唯一索引，复合索引。</p><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li><li>非聚簇索引： 不是聚簇索引，就是非聚簇索引</li></ul><p>根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p><p>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。</p><ul><li>先计算完整列的选择性 : select count(distinct col_1)/count(1) from table_1</li><li>再计算不同前缀长度的选择性 : select count(distinct left(col_1,4))/count(1) from table_1</li><li>找到最优长度之后，创建前缀索引 : create index idx_front on table_1 (col_1(4))</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。</p><ul><li>有了索引下推优化，可以在减少回表次数</li><li>在InnoDB中只针对二级索引有效</li></ul><p>官方文档中给的例子和解释如下：</p><p>在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’</p><ul><li>如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件</li><li>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><p>使用!= 或者 &lt;&gt; 导致索引失效</p></li><li><p>类型不一致导致的索引失效</p></li><li><p>函数导致的索引失效</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果使用函数在索引列，这是不走索引的。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">WHERE</span> <span class="built_in">DATE</span>(create_time) = <span class="string">'2020-09-03'</span>;</span><br></pre></td></tr></table></figure></li><li><p>运算符导致的索引失效</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="symbol">`user`</span> <span class="keyword">WHERE</span> age - <span class="number">1</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>OR引起的索引失效</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="symbol">`user`</span> <span class="keyword">WHERE</span> <span class="symbol">`name`</span> = <span class="string">'张三'</span> <span class="keyword">OR</span> height = <span class="string">'175'</span>;</span><br></pre></td></tr></table></figure><p>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p></li><li><p>模糊搜索导致的索引失效</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="symbol">`user`</span> <span class="keyword">WHERE</span> <span class="symbol">`name`</span> <span class="keyword">LIKE</span> <span class="string">'%冰'</span>;</span><br></pre></td></tr></table></figure><p>当%放在匹配字段前是不走索引的，放在后面才会走索引。</p></li><li><p>NOT IN、NOT EXISTS导致索引失效</p></li></ul>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/python/%E5%9F%BA%E7%A1%80/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="Python的参数传递是值传递还是引用传递"><a href="#Python的参数传递是值传递还是引用传递" class="headerlink" title="Python的参数传递是值传递还是引用传递"></a>Python的参数传递是值传递还是引用传递</h2><p>Python的参数传递有：</p><ul><li>位置参数</li><li>默认参数，</li><li>可变参数,</li><li>关键字参数</li></ul><p>函数的传值到底是值传递还是引用传递，要分情况</p><ul><li><p>不可变参数用值传递：<br>像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象</p></li><li><p>可变参数是用引用传递的：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变.</p></li></ul><a id="more"></a><h2 id="Python是如何进行内存管理的"><a href="#Python是如何进行内存管理的" class="headerlink" title="Python是如何进行内存管理的"></a>Python是如何进行内存管理的</h2><h3 id="对象的引用计数机制"><a href="#对象的引用计数机制" class="headerlink" title="对象的引用计数机制"></a>对象的引用计数机制</h3><p>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。</p><ul><li><p>引用计数增加的情况：</p><ul><li>一个对象分配一个新名称</li><li>将其放入一个容器中（如列表、元组或字典）</li></ul></li><li><p>引用计数减少的情况：</p><ul><li>使用del语句对对象别名显示的销毁</li><li>引用超出作用域或被重新赋值</li></ul></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</p><h3 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h3><p>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统:</p><ul><li>Pymalloc机制：为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。</li><li>对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。</li></ul><h2 id="写出你认为最Pythonic的代码"><a href="#写出你认为最Pythonic的代码" class="headerlink" title="写出你认为最Pythonic的代码"></a>写出你认为最Pythonic的代码</h2><p>下面是一些比较好的例子</p><p>交互变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非Pythonic</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"><span class="comment"># pythonic:</span></span><br><span class="line">a,b=b,a</span><br></pre></td></tr></table></figure><p>判断其值真假</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'Tim'</span></span><br><span class="line">langs = [<span class="string">'AS3'</span>, <span class="string">'Lua'</span>, <span class="string">'C'</span>]</span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'Tim'</span>, <span class="string">'sex'</span>: <span class="string">'Male'</span>, <span class="string">'age'</span>:<span class="number">23</span> &#125;  </span><br><span class="line"><span class="comment"># 非Pythonic</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">''</span> <span class="keyword">and</span> len(langs) &gt; <span class="number">0</span> <span class="keyword">and</span> info != &#123;&#125;:</span><br><span class="line">    print(<span class="string">'All True!'</span>) </span><br><span class="line"><span class="comment"># pythonic:</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">and</span> langs <span class="keyword">and</span> info:</span><br><span class="line">    print(<span class="string">'All True!'</span>)</span><br></pre></td></tr></table></figure><p>列表推导式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>zip创建键值对</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = [<span class="string">'Name'</span>, <span class="string">'Sex'</span>, <span class="string">'Age'</span>]</span><br><span class="line">values = [<span class="string">'Jack'</span>, <span class="string">'Male'</span>, <span class="number">23</span>]</span><br><span class="line">dict(zip(keys,values))</span><br></pre></td></tr></table></figure><h2 id="csrf是什么？如何防范？"><a href="#csrf是什么？如何防范？" class="headerlink" title="csrf是什么？如何防范？"></a>csrf是什么？如何防范？</h2><p>CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：</p><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><p>CSRF攻击攻击原理及过程如下：</p><pre><code>1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；


5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</code></pre><p>防御CSRF攻击：</p><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>list去重和单例</title>
    <url>/python/%E5%9F%BA%E7%A1%80/list%E5%8E%BB%E9%87%8D%E5%92%8C%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="python里面re模块match-和search-的区别"><a href="#python里面re模块match-和search-的区别" class="headerlink" title="python里面re模块match()和search()的区别"></a>python里面re模块match()和search()的区别</h2><ul><li>match()函数指检测re是不是在str的开始位置匹配</li><li>search()会扫描整个str查找匹配，会扫描整个字符串并返回第一个成功的匹配</li></ul><p>也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，返回none</p><h2 id="python传递可变默认参数类型，默认指向同一个引用"><a href="#python传递可变默认参数类型，默认指向同一个引用" class="headerlink" title="python传递可变默认参数类型，默认指向同一个引用"></a>python传递可变默认参数类型，默认指向同一个引用</h2><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,l=[])</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(x):  </span><br><span class="line">        l.append(i*i)  </span><br><span class="line">    print(l)  </span><br><span class="line">f(<span class="number">2</span>)<span class="comment">#[0,1]  </span></span><br><span class="line">f(<span class="number">3</span>,[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])<span class="comment">#[3,2,1,0,1,4]  </span></span><br><span class="line">f(<span class="number">3</span>)<span class="comment">#[0,1,0,1,4]</span></span><br></pre></td></tr></table></figure><h2 id="列表的去重方法"><a href="#列表的去重方法" class="headerlink" title="列表的去重方法"></a>列表的去重方法</h2><ul><li>集合方法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">a = []  </span><br><span class="line"><span class="comment"># 列表去重方法一：集合方法  </span></span><br><span class="line">b = set(li)  </span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></li><li>遍历统计次数，删除重复选项<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:  </span><br><span class="line">    <span class="keyword">while</span> li.count(i) &gt; <span class="number">1</span>:  </span><br><span class="line">        <span class="keyword">del</span> li[li.index(i)]  </span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure></li><li>遍历列表，添加新列表对比<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:  </span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> li:  </span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> a:  </span><br><span class="line">            a.append(i)  </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></li><li>先对元素进行排序，然后从列表的最后开始扫描<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line"><span class="keyword">if</span> list:  </span><br><span class="line">    list.sort()  </span><br><span class="line">    last = list[<span class="number">-1</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):  </span><br><span class="line">        <span class="keyword">if</span> last == list[i]:  </span><br><span class="line">            <span class="keyword">del</span> list[i]  </span><br><span class="line">        <span class="keyword">else</span>:last = list[i]  </span><br><span class="line">  </span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure></li><li>利用map的fromkeys来自动过滤重复值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()  </span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure></li></ul><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>所谓单例，是指一个类的实例从始至终只能被创建一次。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果想使得某个类从始至终最多只有一个实例，使用__new__方法会很简单。Python中类是通过__new__来创建实例的：  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    _instance = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:  </span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)  </span><br><span class="line">        <span class="keyword">return</span> cls._instance  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span>  </span><br><span class="line">    a = <span class="number">1</span>  </span><br><span class="line">one=MyClass()  </span><br><span class="line">two=MyClass()  </span><br><span class="line">print(id(one),id(two))</span><br></pre></td></tr></table></figure><p>结果：id相同<br>在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，<br>如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有时候我们并不关心生成的实例是否具有同一id，而只关心其状态和行为方式。  </span></span><br><span class="line"><span class="comment"># 我们可以允许许多个实例被创建，但所有的实例都共享状态和行为方式：  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span>     </span><br><span class="line">    _shared_state=&#123;&#125;     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span>       </span><br><span class="line">        obj=super(Borg,cls).__new__(cls,*args,**kwargs)       </span><br><span class="line">        obj.__dict__=cls._shared_state       </span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><blockquote><p>将所有实例的<strong>dict</strong>指向同一个字典，这样实例就共享相同的方法和属性。</p></blockquote><blockquote><p>对任何实例的名字属性的设置，无论是在<strong>init</strong>中修改还是直接修改，所有的实例都会受到影响。</p></blockquote><blockquote><p>不过实例的id是不同的。要保证类实例能共享属性，但不和子类共享，注意使用cls._shared_state,</p></blockquote><blockquote><p>而不是Borg._shared_state。<br>因为实例是不同的id，所以每个实例都可以做字典的key：</p></blockquote><p>如果这种行为不是你想要的，可以为Borg类添加<strong>eq</strong>和<strong>hash</strong>方法，<br>使其更接近于单例模式的行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span>     </span><br><span class="line">    _shared_state=&#123;&#125;     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span>       </span><br><span class="line">        obj=super(Borg,cls).__new__(cls,*args,**kwargs)       </span><br><span class="line">        obj.__dict__=cls._shared_state       </span><br><span class="line">        <span class="keyword">return</span> obj     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self,other)</span>:</span>       </span><br><span class="line">        <span class="keyword">try</span>:         </span><br><span class="line">            <span class="keyword">return</span> self.__dict__ <span class="keyword">is</span> other.__dict__       </span><br><span class="line">        <span class="keyword">except</span>:         </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(Borg)</span>:</span>       </span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line">    a=Example()     </span><br><span class="line">    b=Example()     </span><br><span class="line">    c=Example()     </span><br><span class="line">    adict=&#123;&#125;     </span><br><span class="line">    j=<span class="number">0</span>    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a,b,c:       </span><br><span class="line">        adict[i]=j       </span><br><span class="line">        j+=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a,b,c:       </span><br><span class="line">        print(adict[i])  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的实例都能当一个key使用了。</span></span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>当你编写一个类的时候，某种机制会使用类名字，基类元组，类字典来创建一个类对象。新型类中这种机制默认为type，而且这种机制是可编程的，称为元类<strong>metaclass</strong> 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span>     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,bases,class_dict)</span>:</span>       </span><br><span class="line">        super(Singleton,self).__init__(name,bases,class_dict)       </span><br><span class="line">        self._instance=<span class="literal">None</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,*args,**kwargs)</span>:</span>       </span><br><span class="line">        <span class="keyword">if</span> self._instance <span class="keyword">is</span> <span class="literal">None</span>:         </span><br><span class="line">            self._instance=super(Singleton,self).__call__(*args,**kwargs)    </span><br><span class="line">        <span class="keyword">return</span> self._instance   </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>       </span><br><span class="line">        __metaclass__=Singleton         </span><br><span class="line">    a=A()     </span><br><span class="line">    b=A()     </span><br><span class="line">    <span class="keyword">print</span> (id(a),id(b))  </span><br><span class="line"><span class="comment"># 结果：  </span></span><br><span class="line"><span class="comment"># 34248016 34248016  </span></span><br><span class="line"><span class="comment"># id是相同的。 </span></span><br><span class="line">``` </span><br><span class="line">- 例子中我们构造了一个Singleton元类，并使用__call__方法使其能够模拟函数的行为。  </span><br><span class="line">- 构造类A时，将其元类设为Singleton，那么创建类对象A时，行为发生如下：  </span><br><span class="line">- A=Singleton(name,bases,class_dict),A其实为Singleton类的一个实例。  </span><br><span class="line">- 创建A的实例时，A()=Singleton(name,bases,class_dict)()=Singleton(name,bases,class_dict).\_\_call__()，这样就将A的所有实例都指向了A的属性_instance上，这种方法与方法<span class="number">1</span>其实是相同的。  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 方法四</span></span><br><span class="line">python中的模块module在程序中只被加载一次，本身就是单例的。可以直接写一个模块，将你需要的方法和属性，写在模块中当做函数和模块作用域的全局变量即可，根本不需要写类。 </span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_singleton</span><span class="params">(object)</span>:</span>     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span><span class="params">(TypeError)</span>:</span>       </span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self,name,value)</span>:</span>       </span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.__dict__:         </span><br><span class="line">            <span class="keyword">raise</span> self.ConstError       </span><br><span class="line">            self.__dict__[name]=value     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self,name)</span>:</span>       </span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.__dict__:         </span><br><span class="line">            <span class="keyword">raise</span> self.ConstError       </span><br><span class="line">        <span class="keyword">raise</span> NameError   </span><br><span class="line"><span class="keyword">import</span> sys   </span><br><span class="line">sys.modules[__name__]=_singleton()   </span><br><span class="line"><span class="comment"># python并不会对sys.modules进行检查以确保他们是模块对象，  </span></span><br><span class="line"><span class="comment"># 我们利用这一点将模块绑定向一个类对象，而且以后都会绑定向同一个对象了。  </span></span><br><span class="line"><span class="comment"># 将代码存放在single.py中：</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import single   </span><br><span class="line">single.<span class="attribute">a</span>=1  </span><br><span class="line">single.<span class="attribute">a</span>=2   </span><br><span class="line">  </span><br><span class="line">ConstError  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; del single.a  </span><br><span class="line">ConstError</span><br></pre></td></tr></table></figure><h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的方法：  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span><span class="params">(object)</span>:</span>     </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">singleton=singleton()   </span><br><span class="line"><span class="comment"># 将名字singleton绑定到实例上，singleton就是它自己类的唯一对象了</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp和udp的区别</title>
    <url>/python/%E5%9F%BA%E7%A1%80/tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="tcp的特点"><a href="#tcp的特点" class="headerlink" title="tcp的特点"></a>tcp的特点</h2><ul><li>面向连接， 数据发送之前先建立连接，那么这样能保证对方的ip地址是有效的</li><li>应答机制， 对方收到数据以后会进行回复</li><li>超时重传， 数据在发送过程中，如果对方一直没有回复，那么会隔一段时间再次发送数据，如果对方一直没有回复，那么就会认为对方掉线了。</li><li>错误校验， 发送的数据和接收的数据会进行比较，如果数据不一致，会删除数据重新发送，如果是重复数据也会删除。</li><li>流量控制， 如果接收方没有及时接收数据，那么发送方就不会一直发送数据，比如先发1M数据，等接收方开始接收数据的时候才开始继续发送数据。<a id="more"></a></li></ul><h2 id="tcp和udp的对比"><a href="#tcp和udp的对比" class="headerlink" title="tcp和udp的对比"></a>tcp和udp的对比</h2><ul><li>tcp面向连接，udp不面向连接，直接发送数据</li><li>tcp能保证数据的准确性和有效性，udp保证不了</li><li>tcp有超时重传机制，udp没有</li><li>tcp有流量控制（果接收方没有及时接收数据，那么发送方就不会一直发送数据，），udp没有</li><li>tcp因为需要建立连接，需要资源开销，udp 不需要建立连接，没有太多资源开销，那么这样tcp的传输数据不如udp</li><li>tcp不适合做广播，udp适合做广播</li></ul><h2 id="tcp注意点"><a href="#tcp注意点" class="headerlink" title="tcp注意点"></a>tcp注意点</h2><ul><li><p>tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器</p></li><li><p>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</p></li><li><p>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</p></li><li><p>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</p></li><li><p>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</p></li><li><p>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</p></li><li><p>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</p></li><li><p>关闭accept返回的套接字意味着这个客户端已经服务完毕</p></li><li><p>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</p></li></ul><h2 id="tcp的三次握手和四次挥手"><a href="#tcp的三次握手和四次挥手" class="headerlink" title="tcp的三次握手和四次挥手"></a>tcp的三次握手和四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul>]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>-python</tag>
      </tags>
  </entry>
  <entry>
    <title>进程线程协程</title>
    <url>/python/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h2><p>多任务就是操作系统同时运行多个任务。</p><ul><li>并发：指的是任务数多余CPU核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换的速度相当快，看上去一起执行而已）</li><li>并行：指的是任务数小于等于CPU核数，即任务真的是一起执行的</li></ul><a id="more"></a><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程就是程序中代码的一个执行分支，默认只有一个代码执行分支，也就说是主线程，开辟多个线程好比开辟多个代码的执行分支，能够完成多个任务一起值。 线程是cpu调度的基本单位。</p><ul><li>线程的使用 导入threading模块</li><li>多线程执行顺序是无序的</li><li>主线程会等待所有子线程执行完成以后程序再退出<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">    xxx = threading.Thread(target=yyy)</span><br><span class="line"><span class="comment"># 设置守护主线程，主线程退出后，子线程直接销毁</span></span><br><span class="line">    xxx.setDaemon(<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 线程的启动</span></span><br><span class="line">    xxx.start()</span><br></pre></td></tr></table></figure></li></ul><p>1.每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。</p><p>2.无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p><p>3.在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据</p><p>4.缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p><p>互斥锁为资源引入了一个状态：锁定/非锁定</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止</p><p>锁的好处：</p><ul><li>确保了某段关键代码只能有一个线程从头到尾完整地执行</li></ul><p>锁的坏处：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li><li>由于可以存在多个锁，不同的线程有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><p>避免死锁</p><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>程序：是一个静止的</p><p>进程：一个程序运行起来后，代码+用到的资源称之为进程，她是操作系统分配资源的基本单位。</p><p>进程的状态：</p><ul><li>就绪态 ： 运行的条件都已经慢去，正在等待CPU执行</li><li>执行态 ： CPU正在执行其功能</li><li>等待态 ： 等待某些条件满足，例如一个程序sleep了，此时就是等待态了</li></ul><p>通俗来说一个运行起来的软件或者程序叫做进程，每启动一个进程都会向操作系统索要运行资源，所以进程是操作系统资源分配的基本单位，进程只提供资源，真正干活的是进程中的线程。</p><p>你可以把进程想成公司（提供资源），员工可以想成线程（真正干活的人）。线程是依附在进程里面的，没有进程就没有线程，默认请求下一个进程只有一个线程（主线程）。</p><p>进程之间不共享全局变量</p><h4 id="进程和线程对比"><a href="#进程和线程对比" class="headerlink" title="进程和线程对比"></a>进程和线程对比</h4><ul><li><p>进程：一个运行起来的程序或者软件就叫做进程，没启动一个进程都会想操作系统索要运行资源，进程只提供资源，真正干活的是线程，进程是操作系统资源分配的基本单位，进程可以理解成公司（公司提供资源）</p></li><li><p>线程：线程是运行程序中（进程）执行分支，默认情况下进程中只有一个线程（主线程），多个分支可以完成多个任务一起执行。 线程是cup调度基本单位</p></li><li><p>进程之间不共享全局变量， 线程之间共享全局变量</p></li><li><p>多进程开发比多线程开发的程序稳定性和健壮性要强，因为某个进程挂掉不会影响其它进程的运行，如果是多线程模式开发，进程挂掉，进程中所有的线程都会消耗</p></li></ul><h4 id="消息队列queue"><a href="#消息队列queue" class="headerlink" title="消息队列queue"></a>消息队列queue</h4><p>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；</p><pre><code>Queue.qsize()：返回当前队列包含的消息数量；

Queue.empty()：如果队列为空，返回True，反之False ；

Queue.full()：如果队列满了，返回True,反之False；</code></pre><p>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；</p></li><li><p>如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；</p></li><li><p>Queue.get_nowait()：相当Queue.get(False)；</p></li></ul><p>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；</p></li><li><p>如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；</p></li><li><p>Queue.put_nowait(item)：相当Queue.put(item, False)；</p></li></ul><p>导入消息队列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># 初始化一个Queue对象</span></span><br><span class="line">queue = Queue() 里面参数为空代表没有上限</span><br></pre></td></tr></table></figure><p>进程池pool</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入进程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 创建进程池</span></span><br><span class="line">po = Pool(<span class="number">5</span>)  参数<span class="number">5</span>表示最大进程数为<span class="number">5</span></span><br></pre></td></tr></table></figure><p>multiprocessing.Pool常用函数解析：</p><ul><li>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</li><li>close()：关闭Pool，使其不再接受新的任务；</li><li>terminate()：不管任务是否完成，立即终止；</li><li>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</li><li>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程:</p><p>又称为微线程，也是用户基线程，可以在不开劈线程的基础上完成多个任务交替值，程序员可以控制执行顺序</p><p>如何理解:</p><p>如果在函数里面只看一个yield关键字，那么可以理解程是协程</p><p>学习协程的目的:</p><p>在单线程的基础上完成多个任务，可以使用这个协程，多个任务一定是交替执行的</p><p>gevent的使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="comment"># 打补丁</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="comment"># 打补丁， 让gevent能够失败系统的耗时操作，完成协程之间自动进行切换</span></span><br><span class="line"><span class="comment"># 提示： 打补丁的代码一定要先执行</span></span><br><span class="line"><span class="comment"># 提示： gevent封装的greenlet框架</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="comment"># 创建协程指派对应的任务</span></span><br><span class="line">g1 = gevent.spawn(work1)</span><br><span class="line">g2 = gevent.spawn(work2)</span><br><span class="line"><span class="comment"># 主线程不会等待所有的协程把任务执行完成以后程序在退出。</span></span><br><span class="line"><span class="comment"># 等待协程把任务执行完成以后程序在退出</span></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，知道所有元素被访问完结束。迭代器只能往前不能后退。</p><p>可迭代对象有：</p><p>列表、字典、元组、字符串、集合、range、</p><p>判断是否是可迭代对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = isinstance（object, Iterable）</span><br></pre></td></tr></table></figure><p>自定义可迭代对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable , Iterator </span><br><span class="line">```   </span><br><span class="line">在类里面提供__iter__和__next__方法创建的对象就是迭代器，迭代器记录当前遍历位置及获取下一个位置的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成器</span></span><br><span class="line">生成器就是一种特殊的迭代器</span><br><span class="line"></span><br><span class="line">生成器的创建方式：</span><br><span class="line">- 和列表生成式类似，只不过把列表的[ ]改成了( )</span><br><span class="line">```python</span><br><span class="line">g1 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><ul><li><p>函数里面如果存在yield关键字，那么就表示是一个生成器<br>启动生成器的时候如果有代码执行遇到yield那么代码会暂停，下次在启动生成器的时候会在暂停的位置上继续往下执行</p><p>生成器中使用return关键字语法上没有问题<br>在生成器执行完return操作，就会停止迭代，跑着停止迭代异常</p></li><li><p>return关键字： 只能返回一次结果</p></li><li><p>yield关键字：代码执行到yield会暂停，再次启动生成器会继续往下执行，每启动一次生成器都会返回一个值，yield会返回多个值</p></li></ul><p>使用send方法可以给生成器传入参数</p><p>第一个启动生成器一般都是用next函数，如果使用send方法启动生成器需要传入参数会None，再次启动生成器可以传入非空的数据可以不是None</p><h2 id="全局解释器锁-GIL"><a href="#全局解释器锁-GIL" class="headerlink" title="全局解释器锁(GIL)"></a>全局解释器锁(GIL)</h2><p>作用：保证用一时刻只有一个线程可以执行代码</p><p>Python中的多线程是假的</p><p>原因：</p><p>Python的解释器由c写的cpython，而cpython中就存在GIL<br>python解释器：cpython jpython pypython</p><p>解决的办法：</p><ul><li>更换解释器，比如使用jpython解释器</li><li>使用多进程来完成多任务的操作</li></ul><p>在程序当中，如果需要大量消耗内存的，比如进行科学计算时，使用多进程要比多线程快；在进行IO操作（中间有时间阻塞的操作）时，多线程要比多进程快。</p>]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp_socket</title>
    <url>/python/tcp/socket/tcp-socket/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="用python实现tcp-socket服务端与客户端的通信"><a href="#用python实现tcp-socket服务端与客户端的通信" class="headerlink" title="用python实现tcp socket服务端与客户端的通信"></a>用python实现tcp socket服务端与客户端的通信</h2><h4 id="tcp客户端"><a href="#tcp客户端" class="headerlink" title="tcp客户端"></a>tcp客户端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="comment"># 准备发送数据</span></span><br><span class="line">    send_data = input(<span class="string">"要发送的数据："</span>).encode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    client_socket.send(send_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">        recv_data = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">'utf8'</span>)</span><br><span class="line">        print(recv_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建socket</span></span><br><span class="line">    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    client_socket.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8989</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 发送数据</span></span><br><span class="line">            send_msg(client_socket)</span><br><span class="line">            <span class="comment"># 接收数据</span></span><br><span class="line">            recv_process = threading.Thread(target=recv_msg, args=(client_socket,))</span><br><span class="line">            recv_process.start()</span><br><span class="line">            recv_process.join()</span><br><span class="line">            <span class="comment"># recv_msg(client_socket)</span></span><br><span class="line">            flag = input(<span class="string">"是否结束会话(yes or no):"</span>)</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="string">'yes'</span>:</span><br><span class="line">                <span class="comment"># 关闭socket</span></span><br><span class="line">                client_socket.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">'客户端出现异常'</span>, traceback.format_exc())</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="tcp服务端"><a href="#tcp服务端" class="headerlink" title="tcp服务端"></a>tcp服务端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="comment"># 接收客户端的数据</span></span><br><span class="line">    recv_data = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf8"</span>)</span><br><span class="line">    print(recv_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="comment"># 返回给客户端的数据</span></span><br><span class="line">    send_data = input(<span class="string">"返回给客户端的数据："</span>).encode(<span class="string">'utf8'</span>)</span><br><span class="line">    client_socket.send(send_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建socket</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 设置socket选项， 立即释放端口</span></span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 绑定端口</span></span><br><span class="line">    server_socket.bind((<span class="string">''</span>, <span class="number">8989</span>))</span><br><span class="line">    <span class="comment"># 设置监听</span></span><br><span class="line">    server_socket.listen(<span class="number">128</span>)</span><br><span class="line">    <span class="comment"># 创建服务于客户端的socket</span></span><br><span class="line">    client_socket, ip_port = server_socket.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 返回给客户端的数据</span></span><br><span class="line">            send_msg(client_socket)</span><br><span class="line">            <span class="comment"># 接收客户端的数据</span></span><br><span class="line">            recv_process = threading.Thread(target=recv_msg, args=(client_socket,))</span><br><span class="line">            recv_process.start()</span><br><span class="line">            <span class="comment"># recv_msg(client_socket)</span></span><br><span class="line">            recv_process.join()</span><br><span class="line">            <span class="comment"># 关闭服务客户端的socket</span></span><br><span class="line">            client_socket.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 关闭服务客户端的socket</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">"服务器出现异常："</span>, traceback.format_exc())</span><br><span class="line">    <span class="comment"># 关闭监听的socket, 不再接收客户端的连接</span></span><br><span class="line">    server_socket.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>tcp</category>
        <category>socket</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tcp</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/python/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><h2 id="python中的几种排序方法"><a href="#python中的几种排序方法" class="headerlink" title="python中的几种排序方法"></a>python中的几种排序方法</h2><p>使用python来实现数据的几种排序方法，包括冒泡排序，直接选择排序，直接插入排序，快排，归并排序，二分法查找，堆排序等</p><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)<span class="number">-1</span>):</span><br><span class="line">        current_status = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(list) - i <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> list[j] &gt; list[j + <span class="number">1</span>]:</span><br><span class="line">                list[j], list[j + <span class="number">1</span>] = list[j + <span class="number">1</span>], list[j]</span><br><span class="line">                current_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-直接选择排序"><a href="#2-直接选择排序" class="headerlink" title="2. 直接选择排序"></a>2. 直接选择排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list) - <span class="number">1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(list)):</span><br><span class="line">            <span class="keyword">if</span> list[j] &lt; list[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        list[i], list[min_index] = list[min_index], list[i]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h4 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(list)):</span><br><span class="line">        min_value = list[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> list[j] &gt; min_value:</span><br><span class="line">            list[j + <span class="number">1</span>] = list[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        list[j + <span class="number">1</span>] = min_value</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(list, left, right)</span>:</span></span><br><span class="line">    tmp = list[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> list[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        list[left] = list[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> list[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        list[right] = list[left]</span><br><span class="line">    list[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(list, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(list, left, right)</span><br><span class="line">        quick_sort(list, left, mid - <span class="number">1</span>)</span><br><span class="line">        quick_sort(list, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h4 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(list, low, mid, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    两段需要归并的序列从左到右遍历， 逐一比较，小的就放到tmp里</span></span><br><span class="line"><span class="string">    :param list:</span></span><br><span class="line"><span class="string">    :param low:</span></span><br><span class="line"><span class="string">    :param mid:</span></span><br><span class="line"><span class="string">    :param high:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tmp = []</span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> list[i] &lt; list[j]:</span><br><span class="line">            tmp.append(list[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(list[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp.append(list[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        tmp.append(list[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    list[low: high + <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(list, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        merge_sort(list, low, mid)</span><br><span class="line">        merge_sort(list, mid + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">return</span> merge(list, low, mid, high)</span><br></pre></td></tr></table></figure><h4 id="6-二分法查找"><a href="#6-二分法查找" class="headerlink" title="6. 二分法查找"></a>6. 二分法查找</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 二分法查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_sort</span><span class="params">(list, a)</span>:</span></span><br><span class="line">    list.sort()</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = math.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> list[mid] &lt; a:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> list[mid] &gt; a:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(list, left, right)</span>:</span></span><br><span class="line">    i = left</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    tmp = list[i]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> j &lt; right <span class="keyword">and</span> list[j] &lt; list[j + <span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmp &lt; list[i]:</span><br><span class="line">            list[i] = list[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    list[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span> - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift(list, i, n <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        list[<span class="number">0</span>], list[i] = list[i], list[<span class="number">0</span>]</span><br><span class="line">        sift(list, <span class="number">0</span>, i - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = list(range(<span class="number">10</span>))</span><br><span class="line">    random.shuffle(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h4 id="字符串全排序"><a href="#字符串全排序" class="headerlink" title="字符串全排序"></a>字符串全排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(s=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [s]</span><br><span class="line">    l1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> fun1(s[<span class="number">0</span>:i] + s[i+<span class="number">1</span>:]):</span><br><span class="line">            l1.append(s[i] + j)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a = fun1(<span class="string">'abc'</span>)</span><br><span class="line">    print(len(a), a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    list2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(list1) + <span class="number">1</span>):</span><br><span class="line">        iter = itertools.combinations(list1, i)</span><br><span class="line">        list2.append(list(iter))</span><br><span class="line">    print(list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># main()</span></span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql导入导出数据</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="mysql导入导出数据"><a href="#mysql导入导出数据" class="headerlink" title="mysql导入导出数据"></a>mysql导入导出数据</h2><p>mysql数据库导出数据的命令</p><ul><li>mysqldump -u用戶名 -p密码 -d 数据库名 表名 &gt; 脚本名;</li></ul><p>1、导出整个数据库结构和数据</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456 <span class="keyword">database</span> &gt; dump.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><p>2、导出单个数据表结构和数据</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  <span class="keyword">database</span> <span class="keyword">table</span> &gt; dump.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>3、导出整个数据库结构（不包含数据）</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d <span class="keyword">database</span> &gt; dump.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><p>4、导出单个数据表结构（不包含数据）</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d <span class="keyword">database</span> <span class="keyword">table</span> &gt; dump.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><h3 id="Linux-下："><a href="#Linux-下：" class="headerlink" title="Linux 下："></a>Linux 下：</h3><h4 id="一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）："><a href="#一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）：" class="headerlink" title="一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）："></a>一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）：</h4><p>1、导出数据和表结构：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 数据库名 &gt; 数据库名.<span class="keyword">sql</span></span><br><span class="line">#/usr/<span class="keyword">local</span>/mysql/bin/   mysqldump -uroot -p abc &gt; abc.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><p>敲回车后会提示输入密码</p><p>2、只导出表结构</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 -d 数据库名 &gt; 数据库名.<span class="keyword">sql</span></span><br><span class="line">#/usr/<span class="keyword">local</span>/mysql/bin/   mysqldump -uroot -p -d abc &gt; abc.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><p>注：/usr/local/mysql/bin/ —&gt; mysql的data目录</p><h4 id="二、导入数据库"><a href="#二、导入数据库" class="headerlink" title="二、导入数据库"></a>二、导入数据库</h4><p>1、首先建空数据库</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">create</span> <span class="keyword">database</span> abc;</span><br></pre></td></tr></table></figure><p>2、导入数据库</p><ul><li>方法一：</li></ul><p>（1）选择数据库</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">use</span> <span class="title">abc</span>;</span><br></pre></td></tr></table></figure><p>（2）设置数据库编码</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">set</span> names <span class="comment">utf8</span>;</span><br></pre></td></tr></table></figure><p>（3）导入数据（注意sql文件的路径）</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">source</span> <span class="regexp">/home/</span>abc<span class="regexp">/abc.sql;</span></span><br></pre></td></tr></table></figure><ul><li>方法二：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">-u</span>用户名 <span class="selector-tag">-p</span>密码 数据库名 &lt; 数据库名<span class="selector-class">.sql</span></span><br><span class="line"><span class="selector-id">#mysql</span> <span class="selector-tag">-uabc_f</span> <span class="selector-tag">-p</span> <span class="selector-tag">abc</span> &lt; <span class="selector-tag">abc</span><span class="selector-class">.sql</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="windows下："><a href="#windows下：" class="headerlink" title="windows下："></a>windows下：</h3><p>1.导出整个数据库</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqldump</span> <span class="string">-u 用户名 -p 数据库名 &gt; 导出的文件名</span></span><br><span class="line"><span class="attr">mysqldump</span> <span class="string">-u dbuser -p dbname &gt; dbname.sql</span></span><br></pre></td></tr></table></figure><p>2.导出一个表</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqldump</span> <span class="string">-u 用户名 -p 数据库名 表名&gt; 导出的文件名</span></span><br><span class="line"><span class="attr">mysqldump</span> <span class="string">-u dbuser -p dbname users&gt; dbname_users.sql</span></span><br></pre></td></tr></table></figure><p>3.导出一个数据库结构</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p -d --<span class="meta">add</span>-<span class="meta">drop</span>-<span class="meta">table</span> dbname &gt;d:/dbname_db.sql</span><br></pre></td></tr></table></figure><p>-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table</p><p>4.导入数据库</p><p>常用source 命令<br>进入mysql数据库控制台，如<br>mysql -u root -p<br>mysql&gt;use 数据库<br>然后使用source命令，后面参数为脚本文件(如这里用到的.sql)<br>mysql&gt;source d:/dbname.sql</p>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql用户创建授权</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="mysql创建用户并授权"><a href="#mysql创建用户并授权" class="headerlink" title="mysql创建用户并授权"></a>mysql创建用户并授权</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">create<span class="built_in"> user </span><span class="string">'username'</span>@<span class="string">'host'</span> identified by <span class="string">'password'</span></span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">'username'</span>@<span class="string">'host'</span></span><br></pre></td></tr></table></figure><h3 id="用户创建并授权"><a href="#用户创建并授权" class="headerlink" title="用户创建并授权"></a>用户创建并授权</h3><a id="more"></a><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> <span class="keyword">database</span>.<span class="keyword">table</span> <span class="keyword">to</span> <span class="string">'username'</span>@<span class="string">'host'</span> identified <span class="keyword">by</span> <span class="string">'password'</span></span><br></pre></td></tr></table></figure><h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span></span><br></pre></td></tr></table></figure><ul><li>localhost 表示只能在本地连，”%” 表示可以在任意一台机器连，”host” 指定ip 表示可以在指定机器上连</li><li>database: 指定数据库，如果是所有数据库可以用 * 代替</li><li>table: 指定表，如果是所有表可以用 * 代替</li><li>all privileges ： 赋予所有权限</li></ul><h3 id="设置-amp-修改用户密码"><a href="#设置-amp-修改用户密码" class="headerlink" title="设置&amp;修改用户密码"></a>设置&amp;修改用户密码</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'username'</span>@<span class="string">'host'</span>=<span class="keyword">password</span>(<span class="string">'newpassowrd'</span>)</span><br></pre></td></tr></table></figure><h3 id="撤销用户权限"><a href="#撤销用户权限" class="headerlink" title="撤销用户权限"></a>撤销用户权限</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege <span class="keyword">ON</span> databasename.tablename <span class="keyword">FROM</span> <span class="string">'username'</span>@<span class="string">'host'</span></span><br></pre></td></tr></table></figure><ul><li>假如你在给用户‘dog’@’localhost’授权的时候是这样的(或类似的): GRANT SELECT ON test.user TO ‘dog’@’localhost’,则在使用REVOKE SELECT ON *.* FROM ‘dog’@’localhost’,命令并不能撤销该用户对test数据库中user表的SELECT 操作</li><li>相反,如果授权使用的是GRANT SELECT ON *.* TO ‘dog’@’localhost’,则REVOKE SELECT ON test.user FROM ‘dog’@’localhost’命令也不能撤销该用户对test数据库中user表的Select 权限</li></ul><h3 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'username'</span>@<span class="string">'host'</span></span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">DROP<span class="built_in"> USER </span><span class="string">'username'</span>@<span class="string">'host'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql重置root密码</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%87%8D%E7%BD%AEroot%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="mysql重置root密码"><a href="#mysql重置root密码" class="headerlink" title="mysql重置root密码"></a>mysql重置root密码</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>1）：编辑mysqld.cnf文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>2）：在文件中的skip-external-locking一行的下面添加一行：</p><p>skip-grant-tables</p><p>3）：重启MySQL服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><a id="more"></a><p>4）：终端输入mysql进入MySQL，输入USE mysql切换至mysql数据库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">use mysql</span><br></pre></td></tr></table></figure><p>5）：把root用户的密码修改为000000</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET authentication_string=password(<span class="string">'000000'</span>) WHERE User=<span class="string">'root'</span> AND Host =<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p>6）：修改字段plugin</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UPDATE user SET plugin=<span class="string">"mysql_native_password"</span>;</span><br></pre></td></tr></table></figure><p>7）：刷新权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>8）：退出</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure><p>9）：注释掉/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>利用mysql自带的用户debian-sys-maint进行重置密码，只有Debian或Ubuntu服务器才有，存在于/etc/mysql/debian.cnf文件中</p><p>打开/etc/mysql/目录下的debian.cnf文件，里面包括用户名和密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure><p>使用文件中提供的用户名和密码进入mysql</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u debian-sys-maint -p</span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">update user <span class="built_in">set</span> authentication_string=password(<span class="string">'123456'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql生成sql语句</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%94%9F%E6%88%90sql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="使用python自动生成mysql的sql语句"><a href="#使用python自动生成mysql的sql语句" class="headerlink" title="使用python自动生成mysql的sql语句"></a>使用python自动生成mysql的sql语句</h2><p>平时我们在工作当中有的时候使用数据库没有用orm模型，这个时候就需要我们手写sql语句，因此写了一个脚本自动来生成sql语句</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_sql</span><span class="params">(opt=<span class="string">'select'</span>, data=None, condition=None, table=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    sql语句生成模块</span></span><br><span class="line"><span class="string">    :param opt: 操作符，默认是查询select</span></span><br><span class="line"><span class="string">    :param data: 数据</span></span><br><span class="line"><span class="string">    :param condition: 条件</span></span><br><span class="line"><span class="string">    :param table: 表名</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> <span class="keyword">not</span> isinstance(data, dict):</span><br><span class="line">        print(<span class="string">"没有需要处理的数据或者数据格式不是字典类型"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> table:</span><br><span class="line">        print(<span class="string">"缺少表名"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    where_str = <span class="literal">None</span>  <span class="comment"># sql判断条件</span></span><br><span class="line">    <span class="keyword">if</span> condition <span class="keyword">and</span> isinstance(condition, dict):</span><br><span class="line">        where_str = <span class="string">' and '</span>.join([<span class="string">f"<span class="subst">&#123;key&#125;</span>='<span class="subst">&#123;value&#125;</span>'"</span> <span class="keyword">if</span> isinstance(value, str) <span class="keyword">else</span> <span class="string">f"<span class="subst">&#123;key&#125;</span>=<span class="subst">&#123;value&#125;</span>"</span></span><br><span class="line">                                  <span class="keyword">for</span> key, value <span class="keyword">in</span> condition.items()])</span><br><span class="line">    k_list, v_list = [], []</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> data.items():</span><br><span class="line">        k_list.append(k)</span><br><span class="line">        v_list.append(v)</span><br><span class="line">    key_str = <span class="string">','</span>.join(k_list)</span><br><span class="line"></span><br><span class="line">    message = <span class="literal">None</span>  <span class="comment"># 返回的信息</span></span><br><span class="line">    <span class="keyword">if</span> opt.lower() == <span class="string">'select'</span>:  <span class="comment"># 查询</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> where_str:</span><br><span class="line">            sql = <span class="string">"select &#123;&#125; from &#123;&#125;"</span>.format(key_str, table)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sql = <span class="string">"select &#123;&#125; from &#123;&#125; where &#123;&#125;"</span>.format(key_str, table, where_str)</span><br><span class="line">    <span class="keyword">elif</span> opt.lower() == <span class="string">'insert'</span>:  <span class="comment"># 新增</span></span><br><span class="line">        sql = <span class="string">"insert ignore into &#123;&#125;(&#123;&#125;) values &#123;&#125;"</span>.format(table, key_str, tuple(v_list))</span><br><span class="line">    <span class="keyword">elif</span> opt.lower() == <span class="string">'update'</span>:  <span class="comment"># 更新</span></span><br><span class="line">        set_value = <span class="string">' and '</span>.join([<span class="string">f"<span class="subst">&#123;key&#125;</span>='<span class="subst">&#123;value&#125;</span>'"</span> <span class="keyword">if</span> isinstance(value, str) <span class="keyword">else</span> <span class="string">f"<span class="subst">&#123;key&#125;</span>=<span class="subst">&#123;value&#125;</span>"</span></span><br><span class="line">                                  <span class="keyword">for</span> key, value <span class="keyword">in</span> data.items()])</span><br><span class="line">        sql = <span class="string">"update &#123;&#125; set &#123;&#125; where &#123;&#125;"</span>.format(table, set_value, where_str)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sql = <span class="literal">None</span></span><br><span class="line">        message = <span class="string">"未定义的操作符:&#123;&#125;"</span>.format(opt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sql, message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"joe"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="string">"gender"</span>: <span class="string">"man"</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition = &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">    table = <span class="string">"student"</span></span><br><span class="line"></span><br><span class="line">    sql, msg = gen_sql(opt=<span class="string">"select"</span>, data=data, condition=condition, table=table)</span><br><span class="line">    print(sql, msg)</span><br><span class="line">    sql, msg = gen_sql(opt=<span class="string">"update"</span>, data=data, condition=condition, table=table)</span><br><span class="line">    print(sql, msg)</span><br><span class="line">    sql, msg = gen_sql(opt=<span class="string">"insert"</span>, data=data, condition=condition, table=table)</span><br><span class="line">    print(sql, msg)</span><br><span class="line">    sql, msg = gen_sql(opt=<span class="string">"select"</span>, data=data, table=table)</span><br><span class="line">    print(sql, msg)</span><br><span class="line">    sql, msg = gen_sql(opt=<span class="string">"delete"</span>, data=data, condition=condition, table=table)</span><br><span class="line">    print(sql, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql连接池</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="mysql连接池"><a href="#mysql连接池" class="headerlink" title="mysql连接池"></a>mysql连接池</h2><p>1、执行带参数的ＳＱＬ时，请先用sql语句指定需要输入的条件列表，然后再用tuple/list进行条件批配</p><p>２、在格式ＳＱＬ中不需要使用引号指定数据类型，系统会根据输入参数自动识别</p><p>３、在输入的值中不需要使用转意函数，系统会自动处理</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> pymysql.cursors <span class="keyword">import</span> DictCursor</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    MYSQL数据库对象，负责产生数据库连接 , 此类中的连接采用连接池实现获取连接对象：conn = Mysql.getConn()</span></span><br><span class="line"><span class="string">    释放连接对象;conn.close()或del conn</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 连接池对象</span></span><br><span class="line">    __pool = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        <span class="comment"># 数据库构造函数，从连接池中取出连接，并生成操作游标</span></span><br><span class="line">        self._conn = Mysql.__getConn(config)</span><br><span class="line">        self._cursor = self._conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getConn</span><span class="params">(config)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 静态方法，从连接池中取出连接</span></span><br><span class="line"><span class="string">        @return MySQLdb.connection</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        host = config.get(<span class="string">'host'</span>, <span class="string">'localhost'</span>)</span><br><span class="line">        port = config.get(<span class="string">'port'</span>, <span class="number">3306</span>)</span><br><span class="line">        user = config.get(<span class="string">'username'</span>)</span><br><span class="line">        passwd = config.get(<span class="string">'password'</span>)</span><br><span class="line">        db = config.get(<span class="string">'database'</span>)</span><br><span class="line">        charset = config.get(<span class="string">'charset'</span>, <span class="string">'utf8mb4'</span>)</span><br><span class="line">        mincached = config.get(<span class="string">'mincached'</span>, <span class="number">1</span>)</span><br><span class="line">        maxcached = config.get(<span class="string">'maxcached'</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">if</span> Mysql.__pool <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            __pool = PooledDB(creator=pymysql, mincached=mincached, maxcached=maxcached,</span><br><span class="line">                              host=host, port=port, user=user, passwd=passwd,</span><br><span class="line">                              db=db, use_unicode=<span class="literal">False</span>, charset=charset, cursorclass=DictCursor)</span><br><span class="line">        <span class="keyword">return</span> __pool.connection()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAll</span><span class="params">(self, sql, param=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 执行查询，并取出所有结果集</span></span><br><span class="line"><span class="string">        @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来</span></span><br><span class="line"><span class="string">        @param param: 可选参数，条件列表值（元组/列表）</span></span><br><span class="line"><span class="string">        @return: result list(字典对象)/boolean 查询到的结果集</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            count = self._cursor.execute(sql)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self._cursor.execute(sql, param)</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            result = self._cursor.fetchall()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getOne</span><span class="params">(self, sql, param=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 执行查询，并取出第一条</span></span><br><span class="line"><span class="string">        @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来</span></span><br><span class="line"><span class="string">        @param param: 可选参数，条件列表值（元组/列表）</span></span><br><span class="line"><span class="string">        @return: result list/boolean 查询到的结果集</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            count = self._cursor.execute(sql)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self._cursor.execute(sql, param)</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            result = self._cursor.fetchone()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMany</span><span class="params">(self, sql, num, param=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 执行查询，并取出num条结果</span></span><br><span class="line"><span class="string">        @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来</span></span><br><span class="line"><span class="string">        @param num:取得的结果条数</span></span><br><span class="line"><span class="string">        @param param: 可选参数，条件列表值（元组/列表）</span></span><br><span class="line"><span class="string">        @return: result list/boolean 查询到的结果集</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            count = self._cursor.execute(sql)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self._cursor.execute(sql, param)</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            result = self._cursor.fetchmany(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertOne</span><span class="params">(self, sql, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 向数据表插入一条记录</span></span><br><span class="line"><span class="string">        @param sql:要插入的ＳＱＬ格式</span></span><br><span class="line"><span class="string">        @param value:要插入的记录数据tuple/list</span></span><br><span class="line"><span class="string">        @return: insertId 受影响的行数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._cursor.execute(sql, value)</span><br><span class="line">        <span class="keyword">return</span> self.__getInsertId()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertMany</span><span class="params">(self, sql, values)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 向数据表插入多条记录</span></span><br><span class="line"><span class="string">        @param sql:要插入的ＳＱＬ格式</span></span><br><span class="line"><span class="string">        @param values:要插入的记录数据tuple(tuple)/list[list]</span></span><br><span class="line"><span class="string">        @return: count 受影响的行数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = self._cursor.executemany(sql, values)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getInsertId</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取当前连接最后一次插入操作生成的id,如果没有则为0</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._cursor.execute(<span class="string">"SELECT @@IDENTITY AS id"</span>)</span><br><span class="line">        result = self._cursor.fetchall()</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>][<span class="string">'id'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__query</span><span class="params">(self, sql, param=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            count = self._cursor.execute(sql)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self._cursor.execute(sql, param)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, sql, param=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 更新数据表记录</span></span><br><span class="line"><span class="string">        @param sql: ＳＱＬ格式及条件，使用(%s,%s)</span></span><br><span class="line"><span class="string">        @param param: 要更新的  值 tuple/list</span></span><br><span class="line"><span class="string">        @return: count 受影响的行数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.__query(sql, param)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, sql, param=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 删除数据表记录</span></span><br><span class="line"><span class="string">        @param sql: ＳＱＬ格式及条件，使用(%s,%s)</span></span><br><span class="line"><span class="string">        @param param: 要删除的条件 值 tuple/list</span></span><br><span class="line"><span class="string">        @return: count 受影响的行数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.__query(sql, param)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 开启事务</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._conn.autocommit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self, option=<span class="string">'commit'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 结束事务</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> option == <span class="string">'commit'</span>:</span><br><span class="line">            self._conn.commit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._conn.rollback()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispose</span><span class="params">(self, is_end=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @summary: 释放连接池资源</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> is_end == <span class="number">1</span>:</span><br><span class="line">            self.end(<span class="string">'commit'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.end(<span class="string">'rollback'</span>)</span><br><span class="line">        self._cursor.close()</span><br><span class="line">        self._conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器</title>
    <url>/docker/docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><h3 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h3><p>&emsp;&emsp;容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统和跑在上面的应用。</p><h3 id="新建启动容器"><a href="#新建启动容器" class="headerlink" title="新建启动容器"></a>新建启动容器</h3><p>&emsp;&emsp;启动容器的主要命令是docker run，下面的命令输出一个“hello world”，之后终止容器</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面命令启动一个bash终端，允许用户进行交互</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令中的-t 表示让docker分配一个伪终端并绑定到容器的标准输入上，-i 则表示让容器的标准输入持续打开</p><p>&emsp;&emsp;利用docker run 来创建容器时，docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在从公有仓库进行下载；</li><li>利用镜像创建并启动一个容器；</li><li>分配一个文件系统，并在只读的镜像层外面挂载一个可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</li><li>从地址池配置一个IP地址给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已经终止的容器"><a href="#启动已经终止的容器" class="headerlink" title="启动已经终止的容器"></a>启动已经终止的容器</h3><p>可以使用docker start 命令，启动一个已经终止的容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker start 容器ID</span><br></pre></td></tr></table></figure><h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><p>如果需要让docker 后台运行，可以通过添加-d 参数来启动容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 /bin/sh -c <span class="string">"while true; do ech</span></span><br><span class="line"><span class="string">o hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;-d参数启动后会返回一个唯一的id，可以通过docker ps 查看容器信息；要获取容器输入信息，可以通过docker logs命令进行查看</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>&emsp;&emsp;可以使用docker stop命令来终止一个已经运行的容器，此外，当docker 容器中指定的应用结束时，容器也自动终止。当docker 启动终端时，可以通过exit或ctrl+d来退出终端，容器立刻终止；</p><p>终止后的容器可以通过docker ps -a 进行查看；</p><p>docker restart命令会将一个运行态的容器终止，然后重新启动它；</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">$ docker stop 容器ID</span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>attach 命令</p><p>&emsp;&emsp;docker attach命令是docker自带的命令，命令后面接容器，可以进入到该容器，打开终端；但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>nsenter命令</p><p>&emsp;&emsp;nsenter 工具在 util-linux 包2.23版本后包含。 如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp; curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz | tar -zxf-; <span class="built_in">cd</span> util-linux-2.24;</span><br><span class="line">$ ./configure --without-ncurses</span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure><p>为了连接到容器，需要找到容器的第一个进程的pid,可以通过下面命令获取；</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PID=$(docker inspect --format <span class="string">"&#123;&#123; .State.Pid &#125;&#125;"</span> &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个pid可以连接到这个容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nsenter --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure><h4 id="完整的demo"><a href="#完整的demo" class="headerlink" title="完整的demo"></a>完整的demo</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu</span><br><span class="line"><span class="comment"># 返回的容器id</span></span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">243c32535da7 ubuntu:latest <span class="string">"/bin/bash"</span> 18 seconds ago Up 17 seconds nostalgic_hypatia</span><br><span class="line">$ PID=$(docker-pid 243c32535da7)</span><br><span class="line">10981</span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid</span><br><span class="line">root@243c32535da7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用docker export 命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREA</span><br><span class="line">TED STATUS PORTS NA</span><br><span class="line">MES</span><br><span class="line">7691a814370e ubuntu:14.04 <span class="string">"/bin/bash"</span> 36 h</span><br><span class="line">ours ago Exited (0) 21 hours ago te</span><br><span class="line">st</span><br><span class="line">$ sudo docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用docker import 命令从容器快照文件中再导入为镜像</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu v1.0 9d37a6082e97 Abou</span><br><span class="line">t a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>也可以通过指定的url或目录来导入</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容<br>器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状<br>态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入<br>时可以重新指定标签等元数据信息。</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用docker rm 来删除一个处于终止状态的容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个正在运行的容器，可以添加 -f 参数，docker 会发送SIGKILL信号给容器。</p><h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>使用命令</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">docker rm <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span> -<span class="params">q</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像</title>
    <url>/docker/docker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>&emsp;&emsp;镜像是docker的三大组件之一，docker运行容器需要本地存在对应的镜像，如果镜像不存在，docker会从镜像仓库下载，默认是从docker hub 公共注册服务器的仓库中下载。可以通过 docker pull 命令从仓库中获取需要的镜像；</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取Ubuntu12.04镜像</span></span><br><span class="line">1 $ sudo docker pull ubuntu:12.04</span><br><span class="line">2 Pulling repository ubuntu</span><br><span class="line">3 ab8e2728644c: Pulling dependent layers</span><br><span class="line">4 511136ea3c5a: Download complete</span><br><span class="line">5 5f0ffaa9455e: Download complete</span><br><span class="line">6 a300658979be: Download complete</span><br><span class="line">7 904483ae0c30: Download complete</span><br><span class="line">8 ffdaafd1ca50: Download complete</span><br><span class="line">9 d047ae21eeaf: Download complete</span><br></pre></td></tr></table></figure><p>下载过程中会输出获取每一层镜像的信息<br>该命令相当于</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull</span><br><span class="line">registry.hub.docker.com/ubuntu:12.04</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果官方注册服务器下载比较慢的时候，可以选择从其他仓库进行下载，从其他仓库下载需要指定完整的仓库注册服务器的地址；</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 $ sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</span><br><span class="line">2 Pulling dl.dockerpool.com:5000/ubuntu</span><br><span class="line">3 ab8e2728644c: Pulling dependent layers</span><br><span class="line">4 511136ea3c5a: Download complete</span><br><span class="line">5 5f0ffaa9455e: Download complete</span><br><span class="line">6 a300658979be: Download complete</span><br><span class="line">7 904483ae0c30: Download complete</span><br><span class="line">8 ffdaafd1ca50: Download complete</span><br><span class="line">9 d047ae21eeaf: Download complete</span><br></pre></td></tr></table></figure><p>下载镜像完成后，就可以使用镜像了。</p><h3 id="使用-docker-images-列出本地所有镜像"><a href="#使用-docker-images-列出本地所有镜像" class="headerlink" title="使用 docker images 列出本地所有镜像"></a>使用 docker images 列出本地所有镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              14.04               578c3e61a98c        3 weeks ago         223MB</span><br><span class="line">ubuntu              latest              113a43faa138        3 weeks ago         81.2MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        2 months ago        1.85kB</span><br><span class="line">ubuntu              12.04               5b117edd0b76        14 months ago       104MB</span><br></pre></td></tr></table></figure><p>可以看到本地已有镜像的信息，包括镜像名，镜像标记，镜像ID，镜像的创建时间和镜像的大小；</p><p>利用创建的镜像来启动容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -t -i ubuntu:16.04 /bin/bash</span><br><span class="line">root@4af941efaebf:/<span class="comment"># ls</span></span><br></pre></td></tr></table></figure><h3 id="可以用-docker-tag-命令来修改镜像的标签"><a href="#可以用-docker-tag-命令来修改镜像的标签" class="headerlink" title="可以用 docker tag 命令来修改镜像的标签"></a>可以用 docker tag 命令来修改镜像的标签</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker tag 5e8b97a2a082 ubuntu16.04:my</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu16.04         latest              5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu16.04         my                  5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              16.04               5e8b97a2a082        3 weeks ago         114MB</span><br><span class="line">ubuntu              14.04               578c3e61a98c        3 weeks ago         223MB</span><br><span class="line">ubuntu              latest              113a43faa138        3 weeks ago         81.2MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        2 months ago        1.85kB</span><br><span class="line">ubuntu              12.04               5b117edd0b76        14 months ago       104MB</span><br></pre></td></tr></table></figure><h3 id="本地导入镜像"><a href="#本地导入镜像" class="headerlink" title="本地导入镜像"></a>本地导入镜像</h3><p>先下载一个镜像，比如Ubuntu14.04，之后使用以下命令进行导入</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>&emsp;&emsp;用户可以通过docker push 命令来上传自己创建的镜像到仓库中进行共享。例如，用户在Docker Hub上注册后可以推送自己的镜像到仓库中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker push ouruser/sinatra</span><br><span class="line">The push refers to a repository [ouruser/sinatra] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository ouruser/sinatra (3 tags)</span><br></pre></td></tr></table></figure><h3 id="存储镜像"><a href="#存储镜像" class="headerlink" title="存储镜像"></a>存储镜像</h3><p>可以使用docker save 命令，导出docker 镜像到本地文件中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load 命令，将本地文件的镜像导入到本地镜像库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker load --input ubuntu_14.04.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sudo docker load &lt; ubuntu_14.04.tar</span><br></pre></td></tr></table></figure><h3 id="移除本地镜像"><a href="#移除本地镜像" class="headerlink" title="移除本地镜像"></a>移除本地镜像</h3><p>可以使用docker rmi 命令移除本地镜像；移除镜像前需要先使用<strong>docker rm</strong>命令删除依赖该镜像的所有容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rmi Ubuntu16.04</span><br></pre></td></tr></table></figure><h3 id="清理所有未打过标签的本地镜像"><a href="#清理所有未打过标签的本地镜像" class="headerlink" title="清理所有未打过标签的本地镜像"></a>清理所有未打过标签的本地镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo docker rmi $(docker images -q -f <span class="string">"dangling=true"</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ sudo docker rmi $(docker images --quiet --filter <span class="string">"dangling=true"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习</title>
    <url>/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/numpy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="numpy学习小结"><a href="#numpy学习小结" class="headerlink" title="numpy学习小结"></a>numpy学习小结</h2><h3 id="安装numpy包"><a href="#安装numpy包" class="headerlink" title="安装numpy包"></a>安装numpy包</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>ndarray.ndim：数组的维数。在Python世界中，维数称之为rank</li><li>ndarray.shape：数组的维度。这是一系列数字，长度由数组的维度（ndim）决定。例如：长度为n的一维数组的shape是n。一个n行m列的矩阵的shape是n,m</li><li>ndarray.size：数组中所有元素的数量</li><li>ndarray.dtype：数组中元素的类型，例如numpy.int32, numpy.int16或者numpy.float64</li><li>ndarray.itemsize：数组中每个元素的大小，单位为字节</li><li>ndarray.data：存储数组元素的缓冲。通常我们只需要通过下标来访问元素，而不需要访问缓冲</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"a's ndim &#123;&#125;"</span>.format(a.ndim))</span><br><span class="line">print(<span class="string">"a's shape &#123;&#125;"</span>.format(a.shape))</span><br><span class="line">print(<span class="string">"a's size &#123;&#125;"</span>.format(a.size))</span><br><span class="line">print(<span class="string">"a's dtype &#123;&#125;"</span>.format(a.dtype))</span><br><span class="line">print(<span class="string">"a's itemsize &#123;&#125;"</span>.format(a.itemsize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br><span class="line"><span class="comment"># a's ndim 1</span></span><br><span class="line"><span class="comment"># a's shape (3,)</span></span><br><span class="line"><span class="comment"># a's size 3</span></span><br><span class="line"><span class="comment"># a's dtype int32</span></span><br><span class="line"><span class="comment"># a's itemsize 4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"b's ndim &#123;&#125;"</span>.format(b.ndim))</span><br><span class="line">print(<span class="string">"b's shape &#123;&#125;"</span>.format(b.shape))</span><br><span class="line">print(<span class="string">"b's size &#123;&#125;"</span>.format(b.size))</span><br><span class="line">print(<span class="string">"b's dtype &#123;&#125;"</span>.format(b.dtype))</span><br><span class="line">print(<span class="string">"b's itemsize &#123;&#125;"</span>.format(b.itemsize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># b's ndim 2</span></span><br><span class="line"><span class="comment"># b's shape (2, 3)</span></span><br><span class="line"><span class="comment"># b's size 6</span></span><br><span class="line"><span class="comment"># b's dtype int32</span></span><br><span class="line"><span class="comment"># b's itemsize 4</span></span><br></pre></td></tr></table></figure><ul><li>zeros：用来创建元素全部是0的数组</li><li>ones：用来创建元素全部是1的数组</li><li>empty：用来创建未初始化的数据，因此是内容是不确定的</li><li>arange：通过指定范围和步长来创建数组</li><li>linespace：通过指定范围和元素数量来创建数组</li><li>random：用来生成随机数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.zeros((<span class="number">2</span>,<span class="number">3</span>))     </span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># [[0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 0.]]</span></span><br><span class="line"></span><br><span class="line">d = np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># [[1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1.]]</span></span><br><span class="line"></span><br><span class="line">e = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># [[6.23042070e-307 3.56043053e-307 1.37961641e-306]</span></span><br><span class="line"><span class="comment">#  [6.23039015e-307 1.69115935e-306 2.11392033e-307]]</span></span><br><span class="line"></span><br><span class="line">f = np.arange(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0.3</span>)</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment"># [1.  1.3 1.6 1.9]</span></span><br><span class="line"></span><br><span class="line">g = np.linspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># [1.  1.5 2. ]</span></span><br><span class="line"></span><br><span class="line">h = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(h)</span><br><span class="line"><span class="comment"># [[0.64425744 0.4496131  0.88346286]</span></span><br><span class="line"><span class="comment">#  [0.3458989  0.89334331 0.61867948]]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了生成数组之外，当我们已经持有某个数据之后，我们可能会需要根据已有数组来产生一些新的数据结构，这时候我们可以使用下面这些函数：</p><ul><li>reshape：根据已有数组和指定的shape，生成一个新的数组</li><li>vstack：用来将多个数组在垂直（v代表vertical）方向拼接（数组的维度必须匹配）</li><li>hstack：用来将多个数组在水平（h代表horizontal）方向拼接（数组的维度必须匹配）</li><li>hsplit：用来将数组在水平方向拆分</li><li>vsplit：用来将数组在垂直方向拆分</li></ul><p>&emsp;&emsp;下面我们通过一些例子来进行说明。为了便于测试，我们先创建几个数据。这里我们创建了：</p><ul><li>zero_line：一行包含3个0的数组</li><li>one_column：一列包含3个1的数组</li><li>a：一个2行3列的矩阵</li><li>b：[11, 20)区间的整数数组</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zero_line = np.zeros((<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">one_column = np.ones((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [[0. 0. 0.]]</span></span><br><span class="line"><span class="comment"># [[1.]</span></span><br><span class="line"><span class="comment">#  [1.]</span></span><br><span class="line"><span class="comment">#  [1.]]</span></span><br><span class="line"></span><br><span class="line">a = np.array(([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]))</span><br><span class="line">b = np.arange(<span class="number">11</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># [11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组b原先是一个一维数组，现在我们通过reshape方法将其调整成为一个3行3列的矩阵</span></span><br><span class="line"><span class="comment">#这里的第二参数设为-1，表示根据实际情况自动决定。由于原先是9个元素的数组，因此调整后刚好是3X3的矩阵</span></span><br><span class="line">b = b.reshape(<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># [[11 12 13]</span></span><br><span class="line"><span class="comment">#  [14 15 16]</span></span><br><span class="line"><span class="comment">#  [17 18 19]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖直方向拼接数组</span></span><br><span class="line">c = np.vstack((a,b,zero_line))</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># [[ 1.  2.  3.]</span></span><br><span class="line"><span class="comment">#  [ 4.  5.  6.]</span></span><br><span class="line"><span class="comment">#  [11. 12. 13.]</span></span><br><span class="line"><span class="comment">#  [14. 15. 16.]</span></span><br><span class="line"><span class="comment">#  [17. 18. 19.]</span></span><br><span class="line"><span class="comment">#  [ 0.  0.  0.]]</span></span><br><span class="line"></span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [5 6]]</span></span><br><span class="line"><span class="comment"># 水平方向拼接数组</span></span><br><span class="line">d = np.hstack((a,b,one_column))</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># [[ 1.  2. 11. 12. 13.  1.]</span></span><br><span class="line"><span class="comment">#  [ 3.  4. 14. 15. 16.  1.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6. 17. 18. 19.  1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数量进行水平拆分</span></span><br><span class="line">e = np.hsplit(d,<span class="number">3</span>)</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># [array([[1., 2.],</span></span><br><span class="line"><span class="comment">#        [3., 4.],</span></span><br><span class="line"><span class="comment">#        [5., 6.]]), array([[11., 12.],</span></span><br><span class="line"><span class="comment">#        [14., 15.],</span></span><br><span class="line"><span class="comment">#        [17., 18.]]), array([[13.,  1.],</span></span><br><span class="line"><span class="comment">#        [16.,  1.],</span></span><br><span class="line"><span class="comment">#        [19.,  1.]])]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定列数进行水平拆分</span></span><br><span class="line">f = np.hsplit(d,(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment"># [array([[1.],</span></span><br><span class="line"><span class="comment">#        [3.],</span></span><br><span class="line"><span class="comment">#        [5.]]), array([[ 2., 11.],</span></span><br><span class="line"><span class="comment">#        [ 4., 14.],</span></span><br><span class="line"><span class="comment">#        [ 6., 17.]]), array([[12., 13.,  1.],</span></span><br><span class="line"><span class="comment">#        [15., 16.,  1.],</span></span><br><span class="line"><span class="comment">#        [18., 19.,  1.]])]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖直拆分</span></span><br><span class="line">g = np.vsplit(d,<span class="number">3</span>)</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># [array([[ 1.,  2., 11., 12., 13.,  1.]]), array([[ 3.,  4., 14., 15., 16.,  1.]]), array([[ 5.,  6., 17., 18., 19.,  1.]])]</span></span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = np.arange(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">print(base_data)</span><br><span class="line">print(base_data[<span class="number">10</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117</span></span><br><span class="line"><span class="string"> 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135</span></span><br><span class="line"><span class="string"> 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153</span></span><br><span class="line"><span class="string"> 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171</span></span><br><span class="line"><span class="string"> 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189</span></span><br><span class="line"><span class="string"> 190 191 192 193 194 195 196 197 198 199]</span></span><br><span class="line"><span class="string">110</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">every_five = np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">5</span>)</span><br><span class="line">print(every_five)</span><br><span class="line"><span class="comment"># [ 0  5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95]</span></span><br><span class="line"></span><br><span class="line">print(base_data[every_five])</span><br><span class="line"><span class="comment"># [100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195]</span></span><br><span class="line"></span><br><span class="line">a = np.array([(<span class="number">1</span>,<span class="number">2</span>),[<span class="number">10</span>,<span class="number">20</span>]])</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [[ 1  2]</span></span><br><span class="line"><span class="comment">#  [10 20]]</span></span><br><span class="line">print(base_data[a])</span><br><span class="line"><span class="comment"># [[101 102]</span></span><br><span class="line"><span class="comment">#  [110 120]]</span></span><br><span class="line"></span><br><span class="line">base_data2 = base_data.reshape(<span class="number">10</span>, <span class="number">-1</span>)</span><br><span class="line">print(base_data2)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[100 101 102 103 104 105 106 107 108 109]</span></span><br><span class="line"><span class="string"> [110 111 112 113 114 115 116 117 118 119]</span></span><br><span class="line"><span class="string"> [120 121 122 123 124 125 126 127 128 129]</span></span><br><span class="line"><span class="string"> [130 131 132 133 134 135 136 137 138 139]</span></span><br><span class="line"><span class="string"> [140 141 142 143 144 145 146 147 148 149]</span></span><br><span class="line"><span class="string"> [150 151 152 153 154 155 156 157 158 159]</span></span><br><span class="line"><span class="string"> [160 161 162 163 164 165 166 167 168 169]</span></span><br><span class="line"><span class="string"> [170 171 172 173 174 175 176 177 178 179]</span></span><br><span class="line"><span class="string"> [180 181 182 183 184 185 186 187 188 189]</span></span><br><span class="line"><span class="string"> [190 191 192 193 194 195 196 197 198 199]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(base_data2[<span class="number">-1</span>,<span class="number">-1</span>])  <span class="comment"># 199</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片索引从0开始</span></span><br><span class="line">print(base_data2[<span class="number">2</span>, :])</span><br><span class="line"><span class="comment"># [120 121 122 123 124 125 126 127 128 129]</span></span><br><span class="line">print(base_data2[:,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [103 113 123 133 143 153 163 173 183 193]</span></span><br></pre></td></tr></table></figure><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = (np.random.random((<span class="number">5</span>,<span class="number">5</span>))<span class="number">-0.5</span>) * <span class="number">100</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ -4.99893607  39.77193936 -15.46706727  16.80691258 -38.51945213]</span></span><br><span class="line"><span class="string"> [-49.06612449  49.35329335  -0.4216167   13.12483635 -41.60876645]</span></span><br><span class="line"><span class="string"> [-43.18292355 -25.25568989   0.44448147  -2.89856688 -24.13873839]</span></span><br><span class="line"><span class="string"> [ 32.75485688  11.0737333   18.77766764  22.513295     3.48913839]</span></span><br><span class="line"><span class="string"> [-10.96543248 -40.42721305  30.38299405 -32.77083843  40.39435566]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.amin(base_data))</span><br><span class="line"><span class="comment"># -49.06612449306485</span></span><br><span class="line"></span><br><span class="line">print(np.amax(base_data))</span><br><span class="line"><span class="comment"># 49.35329334672289</span></span><br><span class="line"></span><br><span class="line">print(np.average(base_data))</span><br><span class="line"><span class="comment"># -2.0333544702011186</span></span><br><span class="line"></span><br><span class="line">print(np.sin(base_data))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 0.95922553  0.87660695 -0.23857285 -0.89073028 -0.73137794]</span></span><br><span class="line"><span class="string"> [ 0.93180625 -0.7908454  -0.40923611  0.52988566  0.69474259]</span></span><br><span class="line"><span class="string"> [ 0.71691953 -0.12263914  0.42998979 -0.24064058  0.83821559]</span></span><br><span class="line"><span class="string"> [ 0.9732393  -0.99694714 -0.07182638 -0.4987417  -0.34059131]</span></span><br><span class="line"><span class="string"> [ 0.99954577 -0.40180897 -0.858805   -0.97678732  0.43167496]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.sum(base_data))</span><br><span class="line"><span class="comment"># -50.83386175502796</span></span><br></pre></td></tr></table></figure><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_data = np.floor((np.random.random((<span class="number">5</span>,<span class="number">5</span>))<span class="number">-0.5</span>) * <span class="number">100</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 39. -20. -44. -45.   6.]</span></span><br><span class="line"><span class="string"> [ -5.  44.  42. -33.  -6.]</span></span><br><span class="line"><span class="string"> [-14.  -9. -13. -30.  -4.]</span></span><br><span class="line"><span class="string"> [ 31. -50.   5.   7.  45.]</span></span><br><span class="line"><span class="string"> [ 39. -16.  42.  39. -24.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 矩阵转置</span></span><br><span class="line">print(base_data.T)  或着</span><br><span class="line">print(base_data.transpose())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 39.  -5. -14.  31.  39.]</span></span><br><span class="line"><span class="string"> [-20.  44.  -9. -50. -16.]</span></span><br><span class="line"><span class="string"> [-44.  42. -13.   5.  42.]</span></span><br><span class="line"><span class="string"> [-45. -33. -30.   7.  39.]</span></span><br><span class="line"><span class="string"> [  6.  -6.  -4.  45. -24.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">matri_one = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1. 1. 1.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">minu_one = np.dot(matri_one, <span class="number">-1</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]</span></span><br><span class="line"><span class="string"> [-1. -1. -1. -1. -1.]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(np.dot(base_data,minu_one))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[-32. -32. -32. -32. -32.]</span></span><br><span class="line"><span class="string"> [-84. -84. -84. -84. -84.]</span></span><br><span class="line"><span class="string"> [-72. -72. -72. -72. -72.]</span></span><br><span class="line"><span class="string"> [ 51.  51.  51.  51.  51.]</span></span><br><span class="line"><span class="string"> [ 46.  46.  46.  46.  46.]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>生成20个随机数，它们每一个都是[0.0, 1.0)之间<br>根据指定的shape生成随机数<br>生成指定范围内（[0, 100)）的指定数量（20）的随机整数<br>对已有的数据（[0, 1, 2, …, 19]）的顺序随机打乱顺序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"random: &#123;&#125;\n"</span>.format(np.random.random(<span class="number">20</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">random: [0.105123   0.90013672 0.58255936 0.27769054 0.00139627 0.69873449</span></span><br><span class="line"><span class="string"> 0.32550338 0.72112185 0.35799445 0.72302835 0.67139936 0.30039148</span></span><br><span class="line"><span class="string"> 0.83770639 0.07878046 0.77641452 0.6054163  0.72421693 0.77157218</span></span><br><span class="line"><span class="string"> 0.08644228 0.65128463]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"rand: &#123;&#125;\n"</span>.format(np.random.rand(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">rand: [[0.73446485 0.30451937 0.49029421 0.62473099]</span></span><br><span class="line"><span class="string"> [0.09829422 0.55518899 0.83903237 0.71153898]</span></span><br><span class="line"><span class="string"> [0.11826133 0.53736883 0.47913765 0.0438171 ]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"randint: &#123;&#125;\n"</span>.format(np.random.randint(<span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">randint: [39 51 97 22 92 29 19 54 92 30  5 61 26 19 92 59 23 64 85 97]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"permutation: &#123;&#125;\n"</span>.format(np.random.permutation(np.arange(<span class="number">20</span>))))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">permutation: [ 5  0 14 10  6 13 11  7 18 19  2 12 17  3  9  8  1 15  4 16]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python图片转字符串</title>
    <url>/python/python%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="python-图片转成字符串"><a href="#python-图片转成字符串" class="headerlink" title="python 图片转成字符串"></a>python 图片转成字符串</h2><a id="more"></a><h3 id="下面是原始图片"><a href="#下面是原始图片" class="headerlink" title="下面是原始图片"></a>下面是原始图片</h3><p><img src="/image/crawl/red_heart.jpg" alt="红心"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">ascii_char = list(<span class="string">"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</span>)</span><br><span class="line"></span><br><span class="line">WIDTH = <span class="number">85</span> <span class="comment"># 字符画的宽</span></span><br><span class="line">HEIGHT = <span class="number">25</span> <span class="comment"># 字符画的高</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将256灰度映射到70个字符上，也就是RGB值转字符的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_char</span><span class="params">(r, g, b, alpha=<span class="number">256</span>)</span>:</span>  <span class="comment"># alpha透明度</span></span><br><span class="line">   <span class="keyword">if</span> alpha == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">   length = len(ascii_char)</span><br><span class="line">   gray = int(<span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b)  <span class="comment"># 计算灰度</span></span><br><span class="line">   unit = (<span class="number">256.0</span> + <span class="number">1</span>) / length</span><br><span class="line">   <span class="keyword">return</span> ascii_char[int(gray / unit)]  <span class="comment"># 不同的灰度对应着不同的字符</span></span><br><span class="line">   <span class="comment"># 通过灰度来区分色块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   img = <span class="string">'./15.jpg'</span> <span class="comment"># 图片所在位置</span></span><br><span class="line">   im = Image.open(img)</span><br><span class="line">   im = im.resize((WIDTH, HEIGHT), Image.NEAREST)</span><br><span class="line">   txt = <span class="string">""</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(HEIGHT):</span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> range(WIDTH):</span><br><span class="line">           txt += get_char(*im.getpixel((j, i))) <span class="comment"># 获得相应的字符</span></span><br><span class="line">       txt += <span class="string">'\n'</span></span><br><span class="line">   print(txt)  <span class="comment"># 打印出字符画</span></span><br><span class="line">   <span class="comment"># 将字符画 写入文件中</span></span><br><span class="line">   <span class="keyword">with</span> open(<span class="string">"15.txt"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">       f.write(txt)</span><br></pre></td></tr></table></figure><h3 id="转换后的效果"><a href="#转换后的效果" class="headerlink" title="转换后的效果"></a>转换后的效果</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">                                                                                </span><br><span class="line">           .uahZO000Okhhw^.                  ..'hhhhhhkqZwk`'.                  </span><br><span class="line">       'phkbddppJJJJmdppddbkb&lt;             aZ0ZqQppppOOdppddbkhk.               </span><br><span class="line">     .hkbddpppmJCpppp0JJQppJCqbk`      'mZ0dpppppJCJJJppppppppddbk:.            </span><br><span class="line">   .mZbdpppppUJpppppppppJJpppLJCQO.   hbQCppppppLJOJJJJppppppppppdbk.           </span><br><span class="line">  .hkdpZppZJJJZpppppppppppppdJJJddbkIhbdpppppppdJJJJJCJJCJJJJJpppppbk,          </span><br><span class="line">  mbbppppppCJJJppppppppppppppppCppdddddpppppppppppJJJJJLppppppJJJ0q0L0.         </span><br><span class="line">.,OLLpppLJqCJCCJppppppppppppppppppppppppppppppppppCppppppppppOJdppppCQ0         </span><br><span class="line">.p0LJCCmppppqCJJwppppppppppZJJLppppppppppppppppppJJppppppppppJJJCqpppL0.        </span><br><span class="line"> mkddppppppppppLJpppppqCJJpppJqpppppppppppJJJJCCJJJJJJJJJJJCqJJqCJJJJLQ         </span><br><span class="line"> .kbdppppppppppJpppppppJmpppp0JdpppppppppwJCJpwJZpppppCJJJJdpppppJppdb[         </span><br><span class="line">  lkbdpppwOqQJJCppppppppppOJJJJJJppppppCJOJpJJCpppppppppJJJpppppppppdq.         </span><br><span class="line">   .kbdpppJwpdJLppppppppppCJCdppJJJppppppJJJppppJJJLppppJJJJJqpppdbk.           </span><br><span class="line">     .kpCJqpppdOZOCLJJJJJJJJJppdJJppppppppJqp0JJJLppppppppppppdCdQ.             </span><br><span class="line">       .<span class="string">"dbdppppJJJpCdCwpppppppppJJpppppppppppppJZppppppppppdbd'.               </span></span><br><span class="line">            kkbLJppppwJJCppppppJJJJJppppppppppppJpppppppdbbm..                  </span><br><span class="line">               .rkbddpppJJJJJCJJJpCJ0ppZLJJJJJJJJdpddpb^                        </span><br><span class="line">                    .kbbpppppJJJqpppppppppppppppCQw'.                           </span><br><span class="line">                        ^kbddppJppppppppppppdbkt.                               </span><br><span class="line">                          .:hbdpppppppppppdb`.                                  </span><br><span class="line">                              .kbdpppppdba.                                     </span><br><span class="line">                                .kbbddb'                                        </span><br><span class="line">                                  .ah..</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter搭建</title>
    <url>/python/jupyter/jupyter%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="搭建jupyter服务器"><a href="#搭建jupyter服务器" class="headerlink" title="搭建jupyter服务器"></a>搭建jupyter服务器</h2><h3 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h3><h3 id="一、选择安装anaconda"><a href="#一、选择安装anaconda" class="headerlink" title="一、选择安装anaconda"></a>一、选择安装anaconda</h3><ol><li><p>根目录下创建一个文件夹用来放anaconda安装包</p></li><li><p>下载anaconda安装包（可以在官网上自行选择版本）</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>repo.continuum.io<span class="regexp">/archive/</span>Anaconda3-<span class="number">4.4</span>.<span class="number">0</span>-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>运行安装程序，安装anaconda</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Anaconda3-4</span><span class="selector-class">.4</span><span class="selector-class">.0-Linux-x86_64</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure><p><strong>PS:</strong> 该文件是一个可执行文件，如果下载的文件没有可执行权限，执行命令 chmod 641 Anaconda3-4.4.0-Linux-x86_64.sh 修改权限。</p></li><li><p>配置环境变量</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>environment</span><br></pre></td></tr></table></figure><p>将anaconda的bin文件夹的路径添加到环境变量中去（一般安装目录为/root/anaconda3/bin）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source /etc/environment  <span class="comment"># 使文件生效</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二、配置jupyter-notebook-的配置文件"><a href="#二、配置jupyter-notebook-的配置文件" class="headerlink" title="二、配置jupyter notebook 的配置文件"></a>二、配置jupyter notebook 的配置文件</h3><ol><li><p>生成jupyter notebook 的配置文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令对于root用户</span></span><br><span class="line">jupyter notebook  --allow-root  --generate-config</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 对于一般用户</span></span><br><span class="line">jupyter notebook  --generate-config</span><br></pre></td></tr></table></figure><p>执行完该命令后会在 .jupyter文件夹下生成一个jupyter_notebook_config.py的配置文件</p></li><li><p>修改配置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vim jupyter_notebook_config.py <span class="comment"># 打开文件修改配置项</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  星号为允许任意ip访问服务</span></span><br><span class="line">c.NotebookApp.ip=<span class="string">'*'</span></span><br><span class="line"><span class="comment"># 该处设置登录jupyter 的密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'此处填写密码'</span></span><br><span class="line"><span class="comment"># 该项为启动服务默认打开浏览器，设置为False默认不打开</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">c.NotebookApp.port =<span class="number">8080</span></span><br><span class="line"><span class="comment"># 该项设置notebook 的工作目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/ubuntu/anaconda'</span></span><br></pre></td></tr></table></figure><p><strong>PS:</strong> 对于密码的配置，我们不应该直接配置明文密码，因此需要对密码进行加密处理</p><h4 id="打开ipython"><a href="#打开ipython" class="headerlink" title="打开ipython"></a>打开ipython</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><p>该命令会让你输入密码，确认密码，然后返回一串加密后的字符串，类似于：sha1:f97cc330b40c:fb618ac068bd66fb36563e15da4f7462131ad5ee</p><p>配置完成之后保存文件。</p></li></ol><h2 id="三、启动jupyter-notebook应用"><a href="#三、启动jupyter-notebook应用" class="headerlink" title="三、启动jupyter notebook应用"></a>三、启动jupyter notebook应用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 notebook 服务</span></span><br><span class="line">nohup jupyter notebook &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更加高级的用法</span></span><br><span class="line">nohup jupyter notebook &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中 nohup 是让进程在ssh连接断开时正常运行，&amp;是为了让进程在后台运行。如果想结束该进程，通过 ps aux|grep jupyter-notebook 查找到进程的pid，通过kill命令结束进程。</p><p>&emsp;&emsp;/dev/null : 代表空设备文件，2：代表标准错误， 1：代表标准输出</p><p>&emsp;&emsp;该命令是将标准输出重定向到文件/dev/null，标准错误输出重定向到标准输出，最终都重定向到/dev/null 文件中.</p><p>&emsp;&emsp;服务启动后，我们就可以通过公网ip + 端口访问我们的服务了。</p><p>&emsp;&emsp;ps：如果是普通用户启动jupyter notebook应用的话，可能会报错 Permission denied: ‘/run/user/0/jupyter’，这时可以打开文件~/.bashrc，添加一行export XDG_RUNTIME_DIR=””，可以解决这个权限问题。</p><p>&emsp;&emsp;如果在创建新的文件的时候出现 Permission denied: Untitled.ipynb的问题，找到你的jupyter的工作家目录，ls -al 查看你的文件的权限， chmod 777 yourdir/ 修改文件的权限。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp; 该服务的搭建过程中，有些重要的对方没有做，没有进行nginx反向代理，没有添加ssl证书。</p>]]></content>
      <categories>
        <category>python</category>
        <category>jupyter</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>mongo去重</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/mongo%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h2 id="mongo-去重"><a href="#mongo-去重" class="headerlink" title="mongo 去重"></a>mongo 去重</h2><p>进入到Mongo的安装目录，进入到bin文件夹下</p><p>导出数据：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mongoexport</span><span class="selector-class">.exe</span> <span class="selector-tag">-d</span> <span class="selector-tag">database</span> <span class="selector-tag">-c</span> <span class="selector-tag">collection</span> <span class="selector-tag">-o</span> <span class="selector-tag">filename</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>导入数据：</p><a id="more"></a><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">mongoimport.<span class="keyword">exe</span> -d database -<span class="keyword">c</span> collection --<span class="keyword">file</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure><p>查询集合中存在重复的数据：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([&#123;<span class="string">$group:</span>&#123;<span class="string">_id:</span>&#123;字段名:<span class="string">'$字段名'</span>&#125;,<span class="string">count:</span>&#123;<span class="string">$sum:</span><span class="number">1</span>&#125;&#125;&#125;,&#123;<span class="string">$match:</span>&#123;<span class="string">count:</span>&#123;<span class="string">$gt:</span><span class="number">1</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure><p>删除重复数据：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">db<span class="built_in">.collection</span>.aggregate([</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$group:</span>&#123;_id:&#123;字段名:<span class="string">'$字段名'</span>&#125;<span class="built_in">,count</span>:&#123;<span class="variable">$sum:1</span>&#125;,dups:&#123;<span class="variable">$addToSet:</span><span class="string">'$_id'</span>&#125;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$match:</span><span class="built_in">&#123;count</span>:&#123;<span class="variable">$gt:1</span>&#125;&#125;</span><br><span class="line">&#125;]).forEach(<span class="keyword">function</span><span class="built_in">(doc</span>)&#123;</span><br><span class="line">doc.dups.shift();</span><br><span class="line">db<span class="built_in">.collection</span><span class="built_in">.remove</span>(&#123;_id:&#123;<span class="variable">$in:doc</span>.dups&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mongo</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>解决api变化问题</title>
    <url>/python/%E7%88%AC%E8%99%AB/%E8%A7%A3%E5%86%B3api%E5%8F%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="python解决api变化的问题"><a href="#python解决api变化的问题" class="headerlink" title="python解决api变化的问题"></a>python解决api变化的问题</h2><p>案例：<a href="http://cic.org.vn" target="_blank" rel="noopener">http://cic.org.vn</a></p><p>&emsp;&emsp;该网站用python进行模拟登录时，url链接是经过js加载生成的，当我们用requests发送get请求的时候，返回的结果并不是真正的主页数据，而是一段js代码，但是直接从这段js代码中解析我们需要的登录页url很困难，因此这里我们可以构造一个轻量级的js环境，执行js代码来获取我们需要的数据。</p><p>环境：<br>我们通过jsdom来构造一个轻量的环境，它是基于node的，因此我们需要安装node环境，这里安装的是node8的版本；</p><a id="more"></a><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -sL http<span class="variable">s:</span>//<span class="keyword">deb</span>.nodesource.<span class="keyword">com</span>/setup_8.<span class="keyword">x</span> | sudo -E bash -</span><br><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> nodejs</span><br></pre></td></tr></table></figure><p>安装jsdom</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> jsdom</span><br></pre></td></tr></table></figure><p>创建js的运行环境</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">js_env = <span class="string">'''</span></span><br><span class="line"><span class="string">    const jsdom = require("jsdom");const &#123; JSDOM &#125; = jsdom;</span></span><br><span class="line"><span class="string">    const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`, &#123;</span></span><br><span class="line"><span class="string">        url: "%s",</span></span><br><span class="line"><span class="string">        contentType: "text/html;charset=utf-8",</span></span><br><span class="line"><span class="string">        includeNodeLocations: true,</span></span><br><span class="line"><span class="string">        storageQuota: 10000000</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    const window=dom.window;</span></span><br><span class="line"><span class="string">    const document=dom.window.document;</span></span><br><span class="line"><span class="string">    const navigator = dom.window.navigator;</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><h3 id="爬虫部分"><a href="#爬虫部分" class="headerlink" title="爬虫部分"></a>爬虫部分</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</span><br></pre></td></tr></table></figure><h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = requests.Session()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'cic.org.vn'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'en-US,en;q=0.9'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://cic.org.vn/"</span></span><br><span class="line">res = sess.get(url=url, headers=headers)</span><br><span class="line">html = Selector(text=res.text)</span><br><span class="line">js = html.xpath(<span class="string">"/html/head/script/text()"</span>).extract_first()</span><br></pre></td></tr></table></figure><h4 id="将我们获取的js代码加载到我们能构建的js运行环境中"><a href="#将我们获取的js代码加载到我们能构建的js运行环境中" class="headerlink" title="将我们获取的js代码加载到我们能构建的js运行环境中"></a>将我们获取的js代码加载到我们能构建的js运行环境中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctx = execjs.compile(js_env % res.url + js)</span><br></pre></td></tr></table></figure><p>执行js获取生成的下一个链接</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">next_url = ctx.eval(<span class="string">"href"</span>) + ctx.eval(<span class="string">"query"</span>)</span><br><span class="line">print(next_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">url = <span class="string">"https://cic.org.vn/webcenter/portal/CMSPortal/;jsessionid=4Hej6rGiIAbPiBs6nsBUMP61E9XNGVRYkRzjI5H0kxOhUW9dTaqR!873813657?_afrLoop=715225492645337"</span></span><br></pre></td></tr></table></figure><p>接下来的步骤都类似上一步，直到我们最终得到登录的url；最后我们就可以正常的模拟登录进行操作抓取数据了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;本次的案例是我第一次遇到的爬虫情况，该网站的主页url也是经过js加载的，其参数是一直变化的，其返回的结果并不是主页的数据，因此我们无法直接从返回的数据中解析出我们需要的参数，所以我们构造这么一个轻量级的js环境进行交互，直接问询我们需要的url参数，到最终获取我们需要的登录页链接中间这种js交互需要3次。</p>]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>requests</tag>
        <tag>jsdom</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda函数</title>
    <url>/lambda/lambda%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="记一次项目中lambda函数的应用"><a href="#记一次项目中lambda函数的应用" class="headerlink" title="记一次项目中lambda函数的应用"></a>记一次项目中lambda函数的应用</h2><p>lambda函数也叫做匿名函数，它允许我们快速定义，并且让代码更简洁<br>此次记录一下在项目中使用到lambda函数的场景</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, url=None, headers=None, encode=False, login_info=None, proxy_ip=None, path=None,  verify=False, retry_times=<span class="number">3</span>, decision=lambda x: True, **kwargs)</span>:</span></span><br><span class="line">    proxies = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> proxy_ip:</span><br><span class="line">        proxies = &#123;<span class="string">"http"</span>: proxy_ip, <span class="string">"https"</span>: proxy_ip&#125;</span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    data = kwargs[<span class="string">'params'</span>] <span class="keyword">if</span> <span class="string">'params'</span> <span class="keyword">in</span> kwargs <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(retry_times):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            res = self.session.get(url=url, headers=headers, proxies=proxies, verify=verify, **kwargs)</span><br><span class="line">            self.save_src(url=url, headers=headers, data=data, res=res, login_info=login_info, path=path, encode=encode)</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> res.status_code != <span class="number">200</span>:</span><br><span class="line">                logger.error(<span class="string">'crawl_session get: internet error! url: %s'</span> % url)</span><br><span class="line">            <span class="keyword">if</span> res.status_code &gt;= <span class="number">500</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> res.status_code == <span class="number">200</span> <span class="keyword">and</span> <span class="keyword">not</span> decision(res):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br></pre></td></tr></table></figure><p>这里封装了一下requests的get方法，加入了一个decision参数，该参数是一个匿名函数，retry_times是重试次数，通过匿名函数对res结果进行判断，对爬取结果进行预处理；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decision</span><span class="params">(res)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'java.lang.NullPointerException'</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>上面的函数是我们在爬虫中定义的一个判断函数，当我们如果知道爬取结果中必定会有某个特殊的返回值时，通过该函数我们可以判断爬取的结果是否是正确的；简单的例子，当有可能我们请求服务端json数据时，返回状态码是200，response的json确是一个空值，而我们确定该json一定不是空值，这是我们可以通过lambda函数预处理进行重爬。</p>]]></content>
      <categories>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>百度贴吧图片抓取</title>
    <url>/python/%E7%88%AC%E8%99%AB/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%9B%BE%E7%89%87%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<h2 id="python爬取百度贴吧张国荣图片"><a href="#python爬取百度贴吧张国荣图片" class="headerlink" title="python爬取百度贴吧张国荣图片"></a>python爬取百度贴吧张国荣图片</h2><p>一直喜欢哥哥的歌，也一直听哥哥的歌，突然想着收集一些哥哥的照片，所以写了一个爬虫爬取哥哥的图片，也给大家参考一下；</p><h4 id="这里我用的request-html这个包"><a href="#这里我用的request-html这个包" class="headerlink" title="这里我用的request-html这个包"></a>这里我用的request-html这个包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTMLSession</span><br><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTML</span><br></pre></td></tr></table></figure><h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrawlSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sess = HTMLSession()</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">"Host"</span>: <span class="string">"tieba.baidu.com"</span>,</span><br><span class="line">            <span class="string">"Referer"</span>: <span class="string">"https://www.baidu.com/"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="分析请求的api-发现它是get请求，带有参数"><a href="#分析请求的api-发现它是get请求，带有参数" class="headerlink" title="分析请求的api,发现它是get请求，带有参数"></a>分析请求的api,发现它是get请求，带有参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.params = &#123;</span><br><span class="line">            <span class="string">"kw"</span>: <span class="string">"张国荣"</span>,</span><br><span class="line">            <span class="string">"tab"</span>: <span class="string">"album"</span>,</span><br><span class="line">            <span class="string">"subtab"</span>: <span class="string">"album_good"</span>,</span><br><span class="line">            <span class="string">"cat_id"</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="发送请求，找到分类的id"><a href="#发送请求，找到分类的id" class="headerlink" title="发送请求，找到分类的id"></a>发送请求，找到分类的id</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = self.sess.get(url=<span class="string">"http://tieba.baidu.com/f?"</span>,params=self.params, headers=self.headers)</span><br><span class="line">category_list = re.findall(<span class="string">'&lt;li cat-id="(.*)"&gt;&lt;span&gt;'</span>, resp.text)</span><br></pre></td></tr></table></figure><h4 id="对每个分类构造api请求，获取每个图册的id"><a href="#对每个分类构造api请求，获取每个图册的id" class="headerlink" title="对每个分类构造api请求，获取每个图册的id"></a>对每个分类构造api请求，获取每个图册的id</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_tid_list = []</span><br><span class="line"><span class="keyword">for</span> cat_id <span class="keyword">in</span> category_list:</span><br><span class="line">    self.params[<span class="string">"cat_id"</span>] = cat_id</span><br><span class="line">    self.params[<span class="string">"pagelets"</span>] = <span class="string">'album/pagelet/album_good'</span></span><br><span class="line">    self.params[<span class="string">"pagelets_stamp"</span>] = <span class="string">"%013d"</span>%(<span class="number">1000</span> * time.time())</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.sess.get(url=<span class="string">"http://tieba.baidu.com/f?"</span>, params=self.params, headers=self.headers)</span><br><span class="line">        resp.html.render()</span><br><span class="line">        html = HTML(html=resp.html.text)</span><br><span class="line">        tid_list = re.findall(<span class="string">r"/p/\d+"</span>, re.sub(<span class="string">r"\\"</span>, <span class="string">''</span>, str(html.links)))</span><br><span class="line">        all_tid_list.extend(tid_list)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        print(<span class="string">"获取tid失败&#123;&#125;"</span>.format(err))</span><br><span class="line"><span class="keyword">return</span> all_tid_list</span><br></pre></td></tr></table></figure><h4 id="拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“-”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数"><a href="#拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“-”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数" class="headerlink" title="拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“_”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数"></a>拿到图册的id后我们就可以去请求图册的数据了；tid就是图册的id，“_”是当前的时间戳，“pe”是每页返回40条数据，”pn“是当前页数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">        <span class="string">"kw"</span>: <span class="string">"张国荣"</span>,</span><br><span class="line">        <span class="string">"alt"</span>: <span class="string">"jview"</span>,</span><br><span class="line">        <span class="string">"rn"</span>: <span class="string">"200"</span>,</span><br><span class="line">        <span class="string">"tid"</span>: tid,</span><br><span class="line">        <span class="string">"pn"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"ps"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"pe"</span>: <span class="string">"40"</span>,</span><br><span class="line">        <span class="string">"info"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_"</span>: <span class="string">"%013d"</span> % (<span class="number">1000</span> * time.time())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息"><a href="#构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息" class="headerlink" title="构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息"></a>构造请求获取图册的数据；这里我们可以拿到每个图册的标题和图册中图片的信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_url = <span class="string">"http://tieba.baidu.com/photo/g/bw/picture/list?"</span></span><br><span class="line">resp = self.sess.get(url=base_url, params=params, headers=self.headers).text</span><br><span class="line">time.sleep(random.random() + <span class="number">1</span>)</span><br><span class="line">resp = json.loads(resp)</span><br><span class="line">title = resp[<span class="string">"data"</span>][<span class="string">"title"</span>]</span><br><span class="line">pic_list = resp[<span class="string">"data"</span>][<span class="string">"pic_list"</span>]</span><br></pre></td></tr></table></figure><h4 id="保存我们需要的图册标题和图片链接"><a href="#保存我们需要的图册标题和图片链接" class="headerlink" title="保存我们需要的图册标题和图片链接"></a>保存我们需要的图册标题和图片链接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    image_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self.total_images:</span><br><span class="line">        image_dict = &#123;&#125;</span><br><span class="line">        image_url = []</span><br><span class="line">        image_dict[<span class="string">"title"</span>] = item[<span class="string">"title"</span>]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> item[<span class="string">"images_info"</span>]:</span><br><span class="line">            image_url.append(each[<span class="string">"purl"</span>])</span><br><span class="line">        image_dict[<span class="string">"image_url"</span>] = image_url</span><br><span class="line">        image_list.append(image_dict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"image_urls.json"</span>, <span class="string">"w"</span>, encoding=<span class="string">'GBK'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(image_list))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"写入数据失败&#123;&#125;"</span>.format(err))</span><br></pre></td></tr></table></figure><p>这样我们就拿到了哥哥的图片链接了，然后我们请求图片链接，下载图片即可<br><img src="/image/crawl/leslie.png" alt="张国荣"></p><h2 id="完整代码可以看我的gitub链接："><a href="#完整代码可以看我的gitub链接：" class="headerlink" title="完整代码可以看我的gitub链接："></a>完整代码可以看我的gitub链接：</h2><p><a href="https://github.com/gongjiaqiang/my_spider" target="_blank" rel="noopener">https://github.com/gongjiaqiang/my_spider</a></p>]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python3中Unicode字符转中文</title>
    <url>/python/%E7%88%AC%E8%99%AB/python3%E4%B8%ADUnicode%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h2 id="python3中将Unicode字符串转成中文"><a href="#python3中将Unicode字符串转成中文" class="headerlink" title="python3中将Unicode字符串转成中文"></a>python3中将Unicode字符串转成中文</h2><p>用python爬虫爬取数据时，有时候会发现爬取的数据类似于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a</span><br></pre></td></tr></table></figure><p>这样的Unicode字符串，在python的交互环境里可以直接打印输出查看内容；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>但是有些时候，我们需要保存的是中文数据，而不是Unicode字符串，所以我们需要将Unicode转成中文，我们知道encode()方法是将Unicode码转成我们需要的编码格式，但是我们返回的本身就是str格式，所以我们需要将Unicode字符串转成Unicode码，网上查了资料，是将字符串进行decode(“unicode_escape”)转换，但是在python3中，提示str没有decode的方法。</p><p>因此解决的办法是先采用encode()进行编码，在用同样的编码格式进行decode解码；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>.encode(<span class="string">"utf-8"</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(type(data))  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(data)  <span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">"\u3010\u6f14\u5531\u4f1a\u30112000-\u62c9\u9614\u97f3\u4e50\u4f1a"</span>.encode(<span class="string">"GBK"</span>).decode(<span class="string">"GBK"</span>)</span><br><span class="line">print(type(data))  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(data)  <span class="comment"># 【演唱会】2000-拉阔音乐会</span></span><br></pre></td></tr></table></figure><p>编码格式可以任意，只是解码的时候需要用相同的格式进行解码就行，这样我们就可以保存中文数据了。</p>]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python返回每个月最大天数</title>
    <url>/python/python%E8%BF%94%E5%9B%9E%E6%AF%8F%E4%B8%AA%E6%9C%88%E6%9C%80%E5%A4%A7%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="python返回过去时间里的每月最大天数"><a href="#python返回过去时间里的每月最大天数" class="headerlink" title="python返回过去时间里的每月最大天数"></a>python返回过去时间里的每月最大天数</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_list</span><span class="params">(num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    year = now.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">    mon = now.strftime(<span class="string">'%m'</span>)</span><br><span class="line">    day = now.strftime(<span class="string">'%d'</span>)</span><br><span class="line">    date_list = []</span><br><span class="line">    date_list.append([day, mon, year])</span><br><span class="line">    temp = now</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num):</span><br><span class="line">        last_mon_day = temp - datetime.timedelta(days=temp.day)</span><br><span class="line">        last_day = last_mon_day.strftime(<span class="string">'%d'</span>)</span><br><span class="line">        mon = last_mon_day.strftime(<span class="string">'%m'</span>)</span><br><span class="line">        year = last_mon_day.strftime(<span class="string">'%Y'</span>)</span><br><span class="line">        date_list.append([last_day, mon, year])</span><br><span class="line">        temp = last_mon_day</span><br><span class="line">    <span class="keyword">return</span> date_list</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回过去一年每个月的时间</span></span><br><span class="line">date_list = get_date_list(<span class="number">12</span>)</span><br><span class="line">print(date_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="string">'22'</span>, <span class="string">'06'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'05'</span>, <span class="string">'2018'</span>], [<span class="string">'30'</span>, <span class="string">'04'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'03'</span>, <span class="string">'2018'</span>], [<span class="string">'28'</span>, <span class="string">'02'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'01'</span>, <span class="string">'2018'</span>], [<span class="string">'31'</span>, <span class="string">'12'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'11'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'10'</span>, <span class="string">'2017'</span>], [<span class="string">'30'</span>, <span class="string">'09'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'08'</span>, <span class="string">'2017'</span>], [<span class="string">'31'</span>, <span class="string">'07'</span>, <span class="string">'2017'</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中元素替换</title>
    <url>/python/python%E4%B8%AD%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="python中元素进行替换有很多方法，下面是我学习中的一些总结"><a href="#python中元素进行替换有很多方法，下面是我学习中的一些总结" class="headerlink" title="python中元素进行替换有很多方法，下面是我学习中的一些总结"></a>python中元素进行替换有很多方法，下面是我学习中的一些总结</h2><h3 id="1、字符串替换str-replace-方法"><a href="#1、字符串替换str-replace-方法" class="headerlink" title="1、字符串替换str.replace()方法"></a>1、字符串替换str.replace()方法</h3><p>python中的replace()方法是把字符串中的old字符串替换成new的字符串，如果指定替换次数max,则按照替换次数进行替换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.replace(old,new,count=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>old：字符串替换前的字符<br>new：字符串替换后的字符<br>count：替换的次数，默认为0，不填表示全局替换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>)  <span class="comment"># 表示全局替换</span></span><br><span class="line"><span class="string">'he@@o wor@d! I @ove python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>)  <span class="comment"># 替换指定次数</span></span><br><span class="line"><span class="string">'he@@o world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"l"</span>,<span class="string">"@"</span>,<span class="number">2</span>).replace(<span class="string">"o"</span>,<span class="string">"$"</span>)  <span class="comment"># 多个字符替换可以进行链式调用replace()方法</span></span><br><span class="line"><span class="string">'he@@$ w$rld! I l$ve pyth$n!'</span></span><br></pre></td></tr></table></figure><h3 id="2、正则表达式中的sub-和subn-方法"><a href="#2、正则表达式中的sub-和subn-方法" class="headerlink" title="2、正则表达式中的sub()和subn()方法"></a>2、正则表达式中的sub()和subn()方法</h3><p>sub(pattern, repl, string)<br>其中pattern表示原字符串中的字符，repl表示需要替换成的字符，string表示需要替换的字符串；<br>subn()和sub()的区别在于subn()返回的一个包含新字符串和替换次数的二元组；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! I love python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">"hello"</span>,<span class="string">"nihao"</span>,str)  </span><br><span class="line"><span class="string">'nihao world! I love python!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(<span class="string">"l"</span>,<span class="string">"*"</span>,str)</span><br><span class="line">(<span class="string">'he**o wor*d! I *ove python!'</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法"><a href="#3、如果同时处理多个字符串的替换，此时可以使用string的maketrans-和translate-方法" class="headerlink" title="3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法"></a>3、如果同时处理多个字符串的替换，此时可以使用string的maketrans()和translate()方法</h3><p>maketrans()方法用来生成字符映射表，而translate()方法则按映射表中定义的对应关系转换并替换其中的字符，用这两种方法可以同时处理多个不同的字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = <span class="string">''</span>.maketrans(<span class="string">"abcdefghij"</span>,<span class="string">"1234567890"</span>)  <span class="comment"># 创建映射表，注意字符串的长度要一致，达到一一对应的目的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world! i love python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.translate(table)  <span class="comment"># 按照关系表将sting中的字符逐个进行替换</span></span><br><span class="line"><span class="string">'85llo worl4! 9 lov5 pyt8on'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="4、对列表里的元素进行替换，可以使用列表解析的方法"><a href="#4、对列表里的元素进行替换，可以使用列表解析的方法" class="headerlink" title="4、对列表里的元素进行替换，可以使用列表解析的方法"></a>4、对列表里的元素进行替换，可以使用列表解析的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="number">5</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="4-1、批量进行替换"><a href="#4-1、批量进行替换" class="headerlink" title="4.1、批量进行替换"></a>4.1、批量进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [<span class="string">"a"</span> <span class="keyword">if</span> x <span class="keyword">in</span> pattern <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="4-2、根据字典的映射进行替换"><a href="#4-2、根据字典的映射进行替换" class="headerlink" title="4.2、根据字典的映射进行替换"></a>4.2、根据字典的映射进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="number">1</span>:<span class="string">"apple"</span>, <span class="number">3</span>:<span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep = [dict[x] <span class="keyword">if</span> x <span class="keyword">in</span> dict <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rep</span><br><span class="line">[<span class="string">'apple'</span>, <span class="number">2</span>, <span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。"><a href="#5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io-StringIO对象。" class="headerlink" title="5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。"></a>5、在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能重新创建一个新的字符串对象。但是如果一定要修改原字符串，可以使用io.StringIO对象。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"hello world!"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str = StringIO(str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str</span><br><span class="line">&lt;_io.StringIO object at <span class="number">0x7fa1e61addc8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell()  <span class="comment"># 返回当前的位置</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()  <span class="comment"># 从当前位置开始读取字符串</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 返回字符串的全部内容</span></span><br><span class="line"><span class="string">'hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.seek(<span class="number">6</span>)  <span class="comment"># 定义开始修改的位置</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.write(<span class="string">"china"</span>)  <span class="comment"># 修改字符串</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.read()</span><br><span class="line"><span class="string">'!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.getvalue()  <span class="comment"># 获取修改后的字符串全部内容</span></span><br><span class="line"><span class="string">'hello china!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io_str.tell() </span><br><span class="line"><span class="number">12</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中arrow库的使用</title>
    <url>/python/python%E4%B8%ADarrow%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Arrow是一个Python库，为创建，操作，格式化和转换日期，时间和时间戳提供了一种明智的，人性化的方法。 它实现和更新日期时间类型，填补功能上的空白，并提供支持许多常见创建场景的智能模块API。 简而言之，它可以帮助您使用更少的进口和更少的代码来处理日期和时间。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> arrow</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="简单开始"><a href="#简单开始" class="headerlink" title="简单开始"></a>简单开始</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> arrow</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.utcnow()  <span class="comment"># 获取世界标准时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T09:<span class="number">37</span>:<span class="number">28.989983</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.now()  <span class="comment"># 获取本地时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">40</span>:<span class="number">19.019529</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.now(<span class="string">'US/Pacific'</span>)  <span class="comment"># 获取指定时区的时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T02:<span class="number">41</span>:<span class="number">54.815029</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">44</span>:<span class="number">43.519166</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.year  <span class="comment"># 当前年</span></span><br><span class="line"><span class="number">2018</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.month  <span class="comment"># 当前月份</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.day  <span class="comment"># 当前天</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.hour  <span class="comment"># 当前第几个小时</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.minute  <span class="comment"># 当前多少分钟</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.second  <span class="comment"># 当前多少秒</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.timestamp  <span class="comment"># 获取时间戳</span></span><br><span class="line"><span class="number">1528364683</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.float_timestamp  <span class="comment"># 浮点数时间戳</span></span><br><span class="line"><span class="number">1528364683.519166</span></span><br></pre></td></tr></table></figure><h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T17:<span class="number">59</span>:<span class="number">36.917894</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format()</span><br><span class="line"><span class="string">'2018-06-07 17:59:36+08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.format(<span class="string">'YYYY-MM-DD HH:mm:ss ZZ'</span>)</span><br><span class="line"><span class="string">'2018-06-07 17:59:36 +08:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ctime()  <span class="comment"># 返回日期和时间的ctime格式化表示。</span></span><br><span class="line"><span class="string">'Thu Jun  7 17:59:36 2018'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.weekday()  <span class="comment"># 以整数形式返回星期几（0-6）</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isoweekday()  <span class="comment"># 以整数形式返回一周中的ISO日（1-7）</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.isocalendar()  <span class="comment"># 返回3元组（ISO年，ISO周数，ISO工作日）</span></span><br><span class="line">(<span class="number">2018</span>, <span class="number">23</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.toordinal()  <span class="comment"># 返回日期的格雷戈里序数</span></span><br><span class="line"><span class="number">736852</span></span><br></pre></td></tr></table></figure><h3 id="从string中解析时间对象"><a href="#从string中解析时间对象" class="headerlink" title="从string中解析时间对象"></a>从string中解析时间对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="string">'2018-06-07 18:52:45'</span>, <span class="string">'YYYY-MM-DD HH:mm:ss'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T18:<span class="number">52</span>:<span class="number">45</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'June was born in May 1980'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(str,<span class="string">'MMMM YYYY'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">1980</span><span class="number">-05</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure><h3 id="解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens"><a href="#解析的格式化参考：http-arrow-readthedocs-io-en-latest-tokens" class="headerlink" title="解析的格式化参考：http://arrow.readthedocs.io/en/latest/#tokens"></a>解析的格式化参考：<a href="http://arrow.readthedocs.io/en/latest/#tokens" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/#tokens</a></h3><h3 id="时间的替换和偏移"><a href="#时间的替换和偏移" class="headerlink" title="时间的替换和偏移"></a>时间的替换和偏移</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(hour=<span class="number">20</span>,minute=<span class="number">00</span>)  <span class="comment"># 替换时间</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T20:<span class="number">00</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.replace(tzinfo=<span class="string">'US/Pacific'</span>)  <span class="comment"># 替换时区</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T19:<span class="number">04</span>:<span class="number">50.245201</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=+<span class="number">3</span>)  <span class="comment"># 往后偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-10</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.shift(days=<span class="number">-3</span>)  <span class="comment"># 往前偏移三天</span></span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-04</span>T19:<span class="number">04</span>:<span class="number">50.245201</span>+<span class="number">08</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="按名称或tzinfo转换为时区"><a href="#按名称或tzinfo转换为时区" class="headerlink" title="按名称或tzinfo转换为时区"></a>按名称或tzinfo转换为时区</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">16</span>:<span class="number">51.695083</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arw.to(<span class="string">'US/Pacific'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T04:<span class="number">16</span>:<span class="number">51.695083</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br></pre></td></tr></table></figure><h3 id="更人性化的设计"><a href="#更人性化的设计" class="headerlink" title="更人性化的设计"></a>更人性化的设计</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>past = arrow.utcnow().shift(hours=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T10:<span class="number">24</span>:<span class="number">19.968351</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>past.humanize()</span><br><span class="line"><span class="string">'an hour ago'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>present = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future = present.shift(hours=+<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T13:<span class="number">25</span>:<span class="number">57.160630</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize()</span><br><span class="line"><span class="string">'in 2 hours'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>future.humanize(a,locale=<span class="string">'ru'</span>)  <span class="comment"># 支持更多的语言环境</span></span><br><span class="line"><span class="string">'через 3 часа'</span></span><br></pre></td></tr></table></figure><h3 id="获取任意时间单位的时间跨度"><a href="#获取任意时间单位的时间跨度" class="headerlink" title="获取任意时间单位的时间跨度"></a>获取任意时间单位的时间跨度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'hour'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'year'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-01</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-12</span><span class="number">-31</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'month'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-30</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().span(<span class="string">'day'</span>)</span><br><span class="line">(&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;, &lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;)</span><br></pre></td></tr></table></figure><h3 id="只得到任意单位时间中的最大值或最小值"><a href="#只得到任意单位时间中的最大值或最小值" class="headerlink" title="只得到任意单位时间中的最大值或最小值"></a>只得到任意单位时间中的最大值或最小值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'hour'</span>)  </span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T11:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().floor(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.utcnow().ceil(<span class="string">'day'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2018</span><span class="number">-06</span><span class="number">-07</span>T23:<span class="number">59</span>:<span class="number">59.999999</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="表示特定于语言环境的数据和功能的类"><a href="#表示特定于语言环境的数据和功能的类" class="headerlink" title="表示特定于语言环境的数据和功能的类"></a>表示特定于语言环境的数据和功能的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrow.locales.Locale</span><br></pre></td></tr></table></figure><h2 id="arrow库的官方文档：http-arrow-readthedocs-io-en-latest"><a href="#arrow库的官方文档：http-arrow-readthedocs-io-en-latest" class="headerlink" title="arrow库的官方文档：http://arrow.readthedocs.io/en/latest/"></a>arrow库的官方文档：<a href="http://arrow.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/</a></h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中random库使用</title>
    <url>/python/python%E4%B8%ADrandom%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；"><a href="#1、random-random-生成一个随机的浮点数，范围在0-0-0-1之间；" class="headerlink" title="1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；"></a>1、random.random() 生成一个随机的浮点数，范围在0.0~0.1之间；</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.random()</span><br><span class="line">print(num)  <span class="comment"># num=0.4329135788510704</span></span><br></pre></td></tr></table></figure><h3 id="2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"><a href="#2、random-uniform-函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；" class="headerlink" title="2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；"></a>2、random.uniform() 函数可以设定浮点数的范围，需要两个参数，一个上限，另一个下限；</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.uniform(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(num)  <span class="comment"># num=1.9499995621894857</span></span><br></pre></td></tr></table></figure><h3 id="3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限"><a href="#3、random-randint-随机生成一个整数int类型-可以指定这个整数的范围，同样有上限和下限" class="headerlink" title="3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限"></a>3、random.randint() 随机生成一个整数int类型,可以指定这个整数的范围，同样有上限和下限</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">print(num)  <span class="comment"># num=2</span></span><br></pre></td></tr></table></figure><h3 id="4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"><a href="#4、random-choice-可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等" class="headerlink" title="4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等"></a>4、random.choice() 可以从任意序列，比如list列表中，选取一个随机的元素返回，可以用字符串、列表、元组等</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">num = random.choice(list)</span><br><span class="line">print(num)  <span class="comment"># num=5</span></span><br></pre></td></tr></table></figure><h3 id="5、random-shuffle-随机打乱一个序列"><a href="#5、random-shuffle-随机打乱一个序列" class="headerlink" title="5、random.shuffle() 随机打乱一个序列"></a>5、random.shuffle() 随机打乱一个序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(list)  <span class="comment"># list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">random.shuffle(list)</span><br><span class="line">print(list)  <span class="comment"># list=[1, 5, 4, 2, 0, 6, 9, 8, 3, 7]</span></span><br></pre></td></tr></table></figure><h3 id="6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改"><a href="#6、random-sample-可以从指定的序列中，随机截取指定长度的片段，不做原地修改" class="headerlink" title="6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改"></a>6、random.sample() 可以从指定的序列中，随机截取指定长度的片段，不做原地修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">new_list = random.sample(list, <span class="number">5</span>)  <span class="comment"># 第一个参数要截取的对象，第二个参数是截取的长度</span></span><br><span class="line">print(new_list)  <span class="comment"># [7, 9, 0, 8, 1]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理简单验证码</title>
    <url>/python/python%E5%A4%84%E7%90%86%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h4 id="利用python对简单的验证码进行处理"><a href="#利用python对简单的验证码进行处理" class="headerlink" title="利用python对简单的验证码进行处理"></a>利用python对简单的验证码进行处理</h4><p>验证码如下所示：<br><img src="/image/code/code.png" alt="这里写图片描述"><br>首先导入我们需要的包文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br></pre></td></tr></table></figure><p>将验证码进行切分，其中进行切分的坐标可以自行调整最佳；Image模块的convert()函数，用于不同模式图像之间的转换。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div_im</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)   <span class="comment"># 转换为灰度图像返回</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">''</span>.join(random.sample(ascii_lowercase, <span class="number">10</span>))  <span class="comment"># 随机序列化一个字符串</span></span><br><span class="line">    regions = [(<span class="number">8</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">26</span>), (<span class="number">20</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">26</span>), (<span class="number">32</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">26</span>), (<span class="number">44</span>, <span class="number">6</span>, <span class="number">56</span>, <span class="number">26</span>)]   <span class="comment"># 定义切分坐标</span></span><br><span class="line">    arr = list()</span><br><span class="line">    <span class="keyword">for</span> i, region <span class="keyword">in</span> enumerate(regions):</span><br><span class="line">        im2 = im.crop(region)   <span class="comment"># 将验证码按坐标进行切分</span></span><br><span class="line">        f_name = <span class="string">'&#123;&#125;_&#123;&#125;.jpg'</span>.format(name, i)</span><br><span class="line">        im2.save(f_name)</span><br><span class="line">        arr.append(f_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>切分后返回的图片为：<br><img src="/image/code/code1.jpg" alt="这里写图片描述"> <img src="/image/code/code2.jpg" alt="这里写图片描述"> <img src="/image/code/code3.jpg" alt="这里写图片描述"> <img src="/image/code/code4.jpg" alt="这里写图片描述"></p><p>将图片进行二值化处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_im_to_array</span><span class="params">(im_name)</span>:</span></span><br><span class="line">    im = Image.open(im_name).convert(<span class="string">'L'</span>)</span><br><span class="line">    a = numpy.array(im)</span><br><span class="line">    a = numpy.array([[<span class="number">0</span> <span class="keyword">if</span> j &lt; <span class="number">5</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> i] <span class="keyword">for</span> i <span class="keyword">in</span> a])  <span class="comment"># 数字5是自己调整的阈值</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>样本集标注：采集100张验证码图片进行切分，人为进行标注0~9；<br><img src="/image/code/test1.png" alt="这里写图片描述"><br><img src="/image/code/test2.png" alt="这里写图片描述"></p><p>最后就是进行测试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec</span><span class="params">(f_name)</span>:</span></span><br><span class="line">    a = convert_im_to_array(f_name)  <span class="comment"># 测试图片的二值化数组</span></span><br><span class="line">    min_i = <span class="number">-1</span></span><br><span class="line">    min_v = <span class="number">10000000</span>  <span class="comment"># 选择一个较大的数即可</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = <span class="string">'sample_im/&#123;&#125;'</span>.format(i)  <span class="comment"># 样本集路径0~9</span></span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">            b = convert_im_to_array(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(p, im))  <span class="comment"># 样本集图片的二值化数组</span></span><br><span class="line">            tmp = sum(sum((a - b)**<span class="number">2</span>))  </span><br><span class="line">            print(tmp)</span><br><span class="line">            <span class="keyword">if</span> tmp &lt; min_v:</span><br><span class="line">                min_v = tmp</span><br><span class="line">                min_i = i</span><br><span class="line">            print(<span class="string">"min_v的值："</span>,min_v)</span><br><span class="line">        print(<span class="string">"min_i的值："</span>,min_i)</span><br><span class="line">    <span class="keyword">return</span> min_i  <span class="comment"># 返回图片中的数字</span></span><br></pre></td></tr></table></figure><p>最后可以进行多次测试比较识别的准确率。</p>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进行excel转json</title>
    <url>/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/python%E8%BF%9B%E8%A1%8Cexcel%E8%BD%ACjson/</url>
    <content><![CDATA[<h2 id="使用python进行excel转json文件"><a href="#使用python进行excel转json文件" class="headerlink" title="使用python进行excel转json文件"></a>使用python进行excel转json文件</h2><h3 id="1、首先导入我们需要用到的库"><a href="#1、首先导入我们需要用到的库" class="headerlink" title="1、首先导入我们需要用到的库"></a>1、首先导入我们需要用到的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、具体代码如下："><a href="#2、具体代码如下：" class="headerlink" title="2、具体代码如下："></a>2、具体代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Excel_to_json</span><span class="params">(file)</span>:</span></span><br><span class="line">    wb = xlrd.open_workbook(file)</span><br><span class="line"></span><br><span class="line">    convert_list = []</span><br><span class="line">    sh = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">    title = sh.row_values(<span class="number">0</span>)  <span class="comment"># 表头，json文件的key</span></span><br><span class="line">    print(title)</span><br><span class="line">    <span class="keyword">for</span> rownum <span class="keyword">in</span> range(<span class="number">1</span>, sh.nrows):</span><br><span class="line">        rowvalue = sh.row_values(rownum)</span><br><span class="line">        single = OrderedDict()  <span class="comment"># 有序字典</span></span><br><span class="line">        <span class="keyword">for</span> colnum <span class="keyword">in</span> range(<span class="number">0</span>, len(rowvalue)):</span><br><span class="line">            print(<span class="string">"key:&#123;0&#125;, value:&#123;1&#125;"</span>.format(title[colnum], rowvalue[colnum]))</span><br><span class="line">            single[title[colnum]] = rowvalue[colnum]</span><br><span class="line">        convert_list.append(single)</span><br><span class="line"></span><br><span class="line">    j = json.dumps(convert_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"file.json"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(j)</span><br></pre></td></tr></table></figure><h2 id="使用python进行json转csv文件"><a href="#使用python进行json转csv文件" class="headerlink" title="使用python进行json转csv文件"></a>使用python进行json转csv文件</h2><h3 id="1、同样，我们先导入需要的库"><a href="#1、同样，我们先导入需要的库" class="headerlink" title="1、同样，我们先导入需要的库"></a>1、同样，我们先导入需要的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><h3 id="2、代码如下："><a href="#2、代码如下：" class="headerlink" title="2、代码如下："></a>2、代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_to_csv</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(path + <span class="string">'.json'</span>, <span class="string">"r"</span>) <span class="keyword">as</span>  f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    jsonData = json.loads(data)</span><br><span class="line"></span><br><span class="line">    csvfile = open(path + <span class="string">".csv"</span>, <span class="string">"w"</span>, newline=<span class="string">''</span>)</span><br><span class="line">    keys_write = <span class="literal">True</span></span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    print(jsonData)</span><br><span class="line">    <span class="keyword">for</span> dic <span class="keyword">in</span> jsonData:</span><br><span class="line">        <span class="keyword">if</span> keys_write:</span><br><span class="line">            keys = list(dic.keys())</span><br><span class="line">            print(keys)</span><br><span class="line">            writer.writerow(keys)</span><br><span class="line">            keys_write = <span class="literal">False</span></span><br><span class="line">        writer.writerow(list(dic.values()))</span><br><span class="line">        print(list(dic.values()))</span><br><span class="line">    csvfile.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    path = <span class="string">"file"</span>  <span class="comment"># 文件的路径</span></span><br><span class="line">    json_to_csv(path)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python字典多次嵌套</title>
    <url>/python/python%E5%AD%97%E5%85%B8%E5%A4%9A%E6%AC%A1%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<h2 id="python实现字典多层嵌套"><a href="#python实现字典多层嵌套" class="headerlink" title="python实现字典多层嵌套"></a>python实现字典多层嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于字典</span></span><br><span class="line">dict1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其实现多次嵌套效果</span></span><br><span class="line">dict2 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: &#123;<span class="string">'1'</span>: <span class="number">3</span>, <span class="string">'2'</span>: <span class="number">4</span>&#125;, </span><br><span class="line">        <span class="string">'d'</span>: &#123;<span class="string">'5'</span>: &#123;<span class="string">'2'</span>: <span class="number">5</span>, <span class="string">'3'</span>: <span class="number">6</span>&#125;, <span class="string">'4'</span>: &#123;<span class="string">'1'</span>: <span class="number">7</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c.1"</span>:<span class="number">3</span>, <span class="string">"c.2"</span>:<span class="number">4</span>, <span class="string">"d.5.2"</span>:<span class="number">5</span>, <span class="string">"d.5.3"</span>:<span class="number">6</span>, <span class="string">"d.4.1"</span>:<span class="number">7</span>&#125;</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(d1)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> key:</span><br><span class="line">            parts = key.split(<span class="string">'.'</span>)</span><br><span class="line">            par = d2</span><br><span class="line">            key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            print(<span class="string">'=========='</span>, key)</span><br><span class="line">            <span class="keyword">while</span> parts:</span><br><span class="line">                par = par.setdefault(key, &#123;&#125;)</span><br><span class="line">                print(par)</span><br><span class="line">                key = parts.pop(<span class="number">0</span>)</span><br><span class="line">            par[key] = value</span><br><span class="line">            print(par)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        d2[key] = value</span><br><span class="line"></span><br><span class="line">fun(d1)</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure><h3 id="其中用到了字典的setdefault方法"><a href="#其中用到了字典的setdefault方法" class="headerlink" title="其中用到了字典的setdefault方法"></a>其中用到了字典的setdefault方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict.setdefault(key,default=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>如果键不存在于字典中，将会添加新的键，并将值设置为默认值；如果字典中包含该给定的键，则返回该键对应的值，否则返回该键设置的默认值。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>dict.get(key,default=None)<br>get方法返回给定键的值，如果键不可用返回默认值；</p><h3 id="collection-defaultdict"><a href="#collection-defaultdict" class="headerlink" title="collection defaultdict"></a>collection defaultdict</h3><p>defaultdict()返回一个字典，自动给每一个键赋一个初始值</p><p><em>参考链接地址：<a href="https://blog.csdn.net/whgyxy/article/details/72458000" target="_blank" rel="noopener">https://blog.csdn.net/whgyxy/article/details/72458000</a></em></p>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中闭包和装饰器</title>
    <url>/python/python%E4%B8%AD%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p><em>闭包</em> 是引用了变量的函数，这个被引用的自由变量将和这个函数一同存在，即使离开了创造这个变量的环境也不例外。所以，<em>闭包</em> 是由函数和与其相关的引用环境组合而成的实体。简单来说，<em>闭包</em> 就是数据和功能的结合。</p><a id="more"></a><h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p><strong>优点：</strong> 可以提高代码的可复用性<br><strong>缺点：</strong> 由于闭包是引用了外部函数的局部变量，导致外部函数的局部变量没有及时释放，消耗内存。</p><h2 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2.装饰器"></a>2.装饰器</h2><h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><p>装饰器本质上也还是一个python函数，它可以让其他函数在不需要的做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的应用场景主要是一些有切面需求的场景，例如：插入日志，性能测试，事务处理，缓存，权限校验等。通过装饰器，我们可以抽离大量与函数功能本身无关的雷同代码并重复应用。</p><h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><ul><li>引入日志</li><li>函数执行时间统计</li><li>执行函数前的预备处理</li><li>执行函数后的清理功能</li><li>权限校验等场景</li><li>缓存</li></ul><h3 id="一个函数同时被多个装饰器装饰的执行顺序"><a href="#一个函数同时被多个装饰器装饰的执行顺序" class="headerlink" title="一个函数同时被多个装饰器装饰的执行顺序"></a>一个函数同时被多个装饰器装饰的执行顺序</h3><p>一个函数如果同时被多个装饰器装饰，由紧靠函数的装饰器先对函数进行装饰，然后返回的结果在给外层的装饰器去执行装饰，依次类推直到所有装饰器都装饰完成，最后会得到一个函数，在执行这个函数的时候，会先执行最外层装饰器的内容，在执行里面装饰器的内容。这个过程有点像我们给一个精美的物品进行一层一层的包装，在包装的时候是从最里面一层层往往包装，拆开的时候又是从外面一层层的拆开。</p><h3 id="对比函数、闭包、对象在作为实参时的区别"><a href="#对比函数、闭包、对象在作为实参时的区别" class="headerlink" title="对比函数、闭包、对象在作为实参时的区别"></a>对比函数、闭包、对象在作为实参时的区别</h3><p><strong>函数作为实参</strong> 如果没有()会作为一个功能传入到另一个函数，如果有()，则会传入这个函数的执行结果即返回值<br><strong>闭包作为实参</strong> 会传入较为复杂的功能和数据<br><strong>对象作为实参</strong> 会传入最为复杂的功能和数据，但是对象占用的空间比较大，传递的是很多的功能和数据</p><h3 id="通用的装饰器"><a href="#通用的装饰器" class="headerlink" title="通用的装饰器"></a>通用的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_fun</span><span class="params">(fun)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">call_fun</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"----这是前面的功能---权限验证---"</span>)</span><br><span class="line">		ret = fun(*args, **kwargs)</span><br><span class="line">		print(<span class="string">"----这是后面的功能---log日志功能---"</span>)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	<span class="keyword">return</span> call_fun</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI1MjI0NjA4NDQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python之copy</title>
    <url>/python/python%E4%B9%8Bcopy/</url>
    <content><![CDATA[<h2 id="Python中的引用、浅拷贝和深拷贝"><a href="#Python中的引用、浅拷贝和深拷贝" class="headerlink" title="Python中的引用、浅拷贝和深拷贝"></a>Python中的引用、浅拷贝和深拷贝</h2><p>在python中，有一句话：<em>一切皆为对象，一切皆为对象的引用</em>，所以<br>只要记住这句话就很容易清楚python中的引用、浅拷贝和深拷贝了。</p><h3 id="1、引用"><a href="#1、引用" class="headerlink" title="1、引用"></a>1、引用</h3><p>python中的引用是经常使用的，python的引用可以节省内存，加快速度，因为它不需要开辟内存空间。例如：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这表示让 a 这个变量去指向一个地址，这个地址保存着数据为 1，让变量 b 也去指向这个地址，那么通过 b 我们一样可以找到数据 1，通过地址的指向来<br>来查找到数据，这就是python中的引用；</p><h3 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h3><p>浅拷贝 copy.copy()<br>浅拷贝保存的是数据的地址，不保存内容，浅拷贝是需要开辟单独的内存空间来存储地址的，它不能保证<br>数据的独立性。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="comment"># a 的值[1, 2, 3]</span></span><br><span class="line"><span class="comment"># b 的值[1, 2, 3]</span></span><br><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br></pre></td></tr></table></figure><p>可以看出 b 的数据和 a 的数据一样，但是 b 的地址和 a 的地址不相同，而且 b 的地址里保存的是列表里元素 1， 2， 3 的地址，b 通过保存的地址信息来获取数据1, 2, 3 可以通过下面的例子得出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id(a)  <span class="comment"># 1397274473</span></span><br><span class="line">id(b)  <span class="comment"># 1397274545</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">id(a[<span class="number">0</span>])  <span class="comment"># 20705456</span></span><br><span class="line">id(b[<span class="number">0</span>])  <span class="comment"># 20705624</span></span><br></pre></td></tr></table></figure><p>可以看出列表a 和列表 b 里面的元素 1 都指向着同一个地址，当列表 a 的第一个元素的值变为8时，即指向一个新的保存数据为 8 的地址时，列表b 的第一个元素仍然保存的是元素 1 的地址，此时可以看出，浅拷贝只是把数据的地址保存了，并没有保存数据本身，当列表中如果有元素为可变的列表或字典类时，因为拷贝的是列表或字典所对应的地址，如果列表或字典中有元素发生改变，则浅拷贝的列表也会跟着改变，不能保证数据的独立性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">d = copy.copy(c)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4]]</span></span><br><span class="line"><span class="comment"># d=[1, 2, [3, 4]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br><span class="line">id(c[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line">id(d[<span class="number">2</span>][<span class="number">0</span>])  <span class="comment"># 20705576</span></span><br><span class="line"></span><br><span class="line">c[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># c=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(c)  <span class="comment"># 13972747060</span></span><br><span class="line">d <span class="comment"># d=[1, 2, [3, 4, 5]]</span></span><br><span class="line">id(d)  <span class="comment"># 13972745446</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">a <span class="comment"># [1, 2, 3]</span></span><br><span class="line">b <span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h3><p>深拷贝copy.deepcopy()<br>python中，深拷贝在浅拷贝的基础上更进一步，深拷贝保存的是数据的本身，一旦进行深拷贝，则拷贝后的内容不仅和原本的内容完全一样，而且跟原来的没有任何联系，充分保证了数据的独立性。<br>深拷贝相当于在内存中开辟了一片新的内存，不再用来保存数据的地址，而是用新的地址来保存相同的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line">a  <span class="comment"># [1, 2, [3, 4, 5]]</span></span><br><span class="line">b  <span class="comment"># [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure><p>可以看出深拷贝是把列表里的数据保存了，和浅拷贝不同，当列表 a 发生改变时，列表 b 并不会跟着改变，这样充分体现了深拷贝可以保证数据的独立性。</p>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python版布隆过滤器(二)</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/python%E7%89%88%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A82/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script><p><a href="https://blog.leslie168.com/数据库/redis/python版布隆过滤器/">python版布隆过滤器(一)</a></p><h2 id="布隆过滤器扩容和删除过期数据"><a href="#布隆过滤器扩容和删除过期数据" class="headerlink" title="布隆过滤器扩容和删除过期数据"></a>布隆过滤器扩容和删除过期数据</h2><p>&emsp;&emsp; 我们知道，布隆过滤器是不可变的，但如果布隆过滤器容量确实不够了，该怎么办呢？或者如果要每个月都删除几个月前的去重数据，该如何处理呢？这边要记录一种布隆过滤器的巧用，多个布隆过滤器组成的循环布隆过滤器。</p><a id="more"></a><h3 id="布隆过滤器扩容"><a href="#布隆过滤器扩容" class="headerlink" title="布隆过滤器扩容"></a>布隆过滤器扩容</h3><p>&emsp;&emsp; 因为布隆过滤器的不可逆，我们没法重新建一个更大的布隆过滤器然后去把数据重新导入。这边采取的扩容的方法是，保留原有的布隆过滤器，建立一个更大的，新增数据都放在新的布隆过滤器中，去重的时候检查所有的布隆过滤器。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterAdapter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, old_filters, new_filter)</span>:</span></span><br><span class="line">        self.old_filters = old_filters</span><br><span class="line">        self.new_filter = new_filter</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.new_filter.add(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> any([f.exists(key) <span class="keyword">for</span> f <span class="keyword">in</span> self.old_filters]) <span class="keyword">or</span> self.new_filter.exists(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([len(f) <span class="keyword">for</span> f <span class="keyword">in</span> self.old_filters]) + len(self.new_filter)</span><br></pre></td></tr></table></figure><h3 id="删除过期数据"><a href="#删除过期数据" class="headerlink" title="删除过期数据"></a>删除过期数据</h3><p>&emsp;&emsp; 为了实现这么一个需求：使用布隆过滤器对url去重，但是每五个月要重新爬取一次。这边介绍一种循环的布隆过滤器，类似于之前的思路，由多个布隆过滤器组成，每个月都清空最早的那个过滤器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleBloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filter_num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param filter_num: 预期包含的filter数量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.filter_num = filter_num</span><br><span class="line">        self.filters = [new_bloomfilter()]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_circle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行循环逻辑</span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.filters) &gt;= self.filter_num:</span><br><span class="line">            self.filters.pop(<span class="number">0</span>)</span><br><span class="line">        self.filters.append(new_bloomfilter())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.filters[<span class="number">-1</span>].add(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> any([f.exists(key) <span class="keyword">for</span> f <span class="keyword">in</span> self.filters])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([len(f) <span class="keyword">for</span> f <span class="keyword">in</span> self.filters])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 1、我们只需要定期执行do_circle方法就可以定期清除最早的过滤器；</p><p>&emsp;&emsp; 2、上面的add方法是对最后一个过滤器执行添加的操作，查询判断则是对所有过滤器都进行判断，这种适合于插入数据过多，而查询判断较少的场景；</p><p>&emsp;&emsp; 3、另一种场景则是插入数据较少，而查询判断过多的场景；因此add方法和exists方法可以适当修改一下；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,key)</span>:</span></span><br><span class="line">    [f.add(key) <span class="keyword">for</span> f <span class="keyword">in</span> self.filters]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self,key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.filters[<span class="number">0</span>].exists(key)</span><br></pre></td></tr></table></figure><p>我们在插入数据过程中，对每个过滤器都执行添加操作，而在查询判断的过程中，我们只需要对任意一个过滤器进行查询就可以了。</p>]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>python版布隆过滤器(一)</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/python%E7%89%88%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://blog.leslie168.com/数据库/redis/python版布隆过滤器/">python版布隆过滤器(二)</a></p><h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="首先导包"><a href="#首先导包" class="headerlink" title="首先导包"></a>首先导包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-conding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> six</span><br><span class="line"><span class="keyword">import</span> redis</span><br></pre></td></tr></table></figure><h3 id="定义哈希Map类"><a href="#定义哈希Map类" class="headerlink" title="定义哈希Map类"></a>定义哈希Map类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleHash</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""根据提供的原始数据，和预定义的多个salt，生成多个hash值"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, hash_func_name=<span class="string">'md5'</span>)</span>:</span></span><br><span class="line">        self.hash_func = getattr(hashlib, hash_func_name)</span><br><span class="line">        <span class="keyword">if</span> len(salts) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"please provide more than 3 element(salt) in the salts"</span>)</span><br><span class="line">        self.salts = salts</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_safe_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param data: 原始数据</span></span><br><span class="line"><span class="string">        :return: 处理成对应python版本可以被hash函数的update方法解析的数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> six.PY3:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, bytes):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, unicode):</span><br><span class="line">                <span class="keyword">return</span> data.encode()</span><br><span class="line">            <span class="keyword">elif</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span>  Exception(<span class="string">"please provide a right str data"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_hash_values</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""根据提供的原始数据, 返回多个hash函数值"""</span></span><br><span class="line">        hash_values = []</span><br><span class="line">        hash_obj = self.hash_func()</span><br><span class="line">        <span class="keyword">for</span> salt <span class="keyword">in</span> self.salts:</span><br><span class="line">            hash_obj.update(self._safe_data(data))</span><br><span class="line">            hash_obj.update(self._safe_data(salt))</span><br><span class="line">            ret = hash_obj.hexdigest()</span><br><span class="line">            hash_values.append(int(ret, <span class="number">16</span>))</span><br><span class="line">        <span class="keyword">return</span> hash_values</span><br></pre></td></tr></table></figure><h3 id="定义布隆过滤器"><a href="#定义布隆过滤器" class="headerlink" title="定义布隆过滤器"></a>定义布隆过滤器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""布隆过滤器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, salts, redis_host=<span class="string">"localhost"</span>, redis_port=<span class="number">6379</span>, redis_db=<span class="number">0</span>, redis_key=<span class="string">"bloomfilter"</span>)</span>:</span></span><br><span class="line">        self.redis_host = redis_host</span><br><span class="line">        self.redis_port = redis_port</span><br><span class="line">        self.redis_db = redis_db</span><br><span class="line">        self.redis_key = redis_key</span><br><span class="line">        self.client = self._get_redis_cli()</span><br><span class="line">        self.multiple_hash = MultipleHash(salts=salts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_redis_cli</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个redis连接对象"""</span></span><br><span class="line">        pool = redis.ConnectionPool(host=self.redis_host, port=self.redis_port, db=self.redis_db)</span><br><span class="line">        client = redis.StrictRedis(connection_pool=pool)</span><br><span class="line">        <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            self.client.setbit(self.redis_key, offset, <span class="number">1</span>)  <span class="comment"># default 0, set 1 when match</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_offset</span><span class="params">(self, hash_value)</span>:</span></span><br><span class="line">        <span class="comment"># (2**9 * 2**20 * 2**3): the len of hash list 哈希表的长度</span></span><br><span class="line">        <span class="keyword">return</span> hash_value % (<span class="number">2</span>**<span class="number">9</span> * <span class="number">2</span>**<span class="number">20</span> * <span class="number">2</span>**<span class="number">3</span>)  <span class="comment"># Mb -&gt; bit</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_exists</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        hash_values = self.multiple_hash.get_hash_values(data)</span><br><span class="line">        <span class="keyword">for</span> hash_value <span class="keyword">in</span> hash_values:</span><br><span class="line">            offset = self._get_offset(hash_value)</span><br><span class="line">            v = self.client.getbit(self.redis_key, offset)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                self.save(data)  <span class="comment"># 如果不存在，保存数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="string">"asfdsafweafxc"</span>, <span class="string">"123"</span>, <span class="string">"123"</span>, <span class="string">"hello"</span>, <span class="string">"hello"</span>, <span class="string">'haha'</span>]</span><br><span class="line">    bm = BloomFilter(salts=[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>], redis_host=<span class="string">"10.0.12.191"</span>, redis_db=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bm.is_exists(d):</span><br><span class="line">            print(<span class="string">"mapping data success : %s"</span> % d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"find replace data : %s"</span> % d)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>pep8的使用</title>
    <url>/python/pep8/</url>
    <content><![CDATA[<h2 id="1-介绍-Introduction"><a href="#1-介绍-Introduction" class="headerlink" title="1 介绍(Introduction)"></a>1 介绍(Introduction)</h2><p>本文档给出了包含主要Python发行版中的标准库的Python代码的编码约定。<br>随着时间的推移，随着更多的约定被识别，过去的约定被语言本身的变化所淘汰，这种风格指南也在不断发展。</p><a id="more"></a><h2 id="2-代码布局-Code-Lay-Out"><a href="#2-代码布局-Code-Lay-Out" class="headerlink" title="2 代码布局(Code Lay-Out)"></a>2 代码布局(Code Lay-Out)</h2><h3 id="2-1-缩进-Indentation"><a href="#2-1-缩进-Indentation" class="headerlink" title="2.1 缩进(Indentation)"></a>2.1 缩进(Indentation)</h3><p>每个缩进需要使用4个空格。</p><p>连续行所包装的元素应该要么采用Python隐式续行，即垂直对齐于圆括号、方括号和花括号，要么采用悬挂缩进。采用悬挂缩进时需考虑以下两点：第一行不应该包括参数，并且在续行中需要再缩进一级以便清楚表示。</p><p>正确的写法</p><pre><code># 同开始分界符(左括号)对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 续行多缩进一级以同其他代码区别
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 悬挂缩进需要多缩进一级
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)</code></pre><p>错误的写法</p><pre><code># 采用悬挂缩进时第一行不应该有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 续行并没有被区分开，因此需要再缩进一级
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre><p>对于延续行，4个空格的规则是可选使用的。</p><p>同样可行的例子:</p><pre><code># 悬挂缩进可以不采用4空格的缩进方法。
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)</code></pre><p>如果if语句太长，需要用多行书写，2个字符(例如,if)加上一个空格和一个左括号刚好是4空格的缩进，但这对多行条件语句的续行是没用的。因为这会和if语句中嵌套的其他的缩进的语句产生视觉上的冲突。这份PEP中并没有做出明确的说明应该怎样来区分条件语句和if语句中所嵌套的语句。以下几种方法都是可行的，但不仅仅只限于这几种方法：</p><pre><code># 不采用额外缩进
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# 增加一行注释，在编辑器中显示时能有所区分
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 在条件语句的续行增加一级缩进
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre><p>多行结束右圆/方/花括号可以单独一行书写，和上一行的缩进对齐：</p><pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
    )</code></pre><p>也可以和多行开始的第一行的第一个字符对齐：</p><pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &apos;a&apos;, &apos;b&apos;, &apos;c&apos;,
    &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
)</code></pre><p>Tab还是空格？(Tab Or Space?)</p><p>推荐使用空格来进行缩进。</p><p>Tab应该只在现有代码已经使用tab进行缩进的情况下使用，以便和现有代码保持一致。</p><p>Python 3不允许tab和空格混合使用。</p><p>Python 2的代码若有tab和空格混合使用的情况，应该把tab全部转换为只有空格。</p><h3 id="2-2-每行最大长度-Maximum-Line-Length"><a href="#2-2-每行最大长度-Maximum-Line-Length" class="headerlink" title="2.2 每行最大长度(Maximum Line Length)"></a>2.2 每行最大长度(Maximum Line Length)</h3><p>将所有行都限制在79个字符长度以内。</p><p>对于连续大段的文字（比如文档字符串(docstring)或注释），其结构上的限制更少，这些行应该被限制在72个字符长度内。</p><p>限制编辑器的窗口宽度能让好几个文件同时打开在屏幕上显示，在使用代码评审(code review)工具时在两个相邻窗口显示两个版本的代码效果很好。</p><p>很多工具的默认自动换行会破坏代码的结构，使代码更难以理解。在窗口大小设置为80个字符的编辑器中，即使在换行时编辑器可能会在最后一列放置一个记号，为避免自动换行也需要限制每行字符长度。一些基于web的工具可能根本没有自动换行的功能。</p><p>一些团队会强烈希望行长度比79个字符更长。当代码仅仅只由一个团队维护时，可以达成一致让行长度增加到80到100字符(实际上最大行长是99字符)，注释和文档字符串仍然是以72字符换行。</p><p>Python标准库比较传统，将行长限制在79个字符以内（文档字符串/注释为72个字符）。</p><p>一种推荐的换行方式是利用Python圆括号、方括号和花括号中的隐式续行。长行可以通过在括号内换行来分成多行。应该最好加上反斜杠来区别续行。</p><p>隐式续行</p><pre><code>a = (&apos;sdfaf&apos; 
    &apos;test&apos;)</code></pre><p>有时续行只能使用反斜杠。例如，较长的多个with语句不能采用隐式续行，只能接受反斜杠表示换行：</p><pre><code>with open(&apos;/path/to/some/file/you/want/to/read&apos;) as file_1, \
     open(&apos;/path/to/some/file/being/written&apos;, &apos;w&apos;) as file_2:
    file_2.write(file_1.read())</code></pre><h3 id="2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator"><a href="#2-3-二元运算符之前还是之后换行？-Should-a-line-break-before-or-after-a-binary-operator" class="headerlink" title="2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)"></a>2.3 二元运算符之前还是之后换行？(Should a line break before or after a binary operator?)</h3><p>长期以来一直推荐的风格是在二元运算符之后换行。但是这样会影响代码可读性，包括两个方面：一是运算符会分散在屏幕上的不同列上，二是每个运算符会留在前一行并远离操作数。所以，阅读代码的时候眼睛必须做更多的工作来确定哪些操作数被加，哪些操作数被减：</p><pre><code># 错误的例子：运算符远离操作数
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)</code></pre><p>为了解决这个可读性问题，数学家及其出版商遵循相反的规定。Donald Knuth在他的“电脑和排版”系列中解释了传统的规则：“尽管在段落中的公式总是在二元运算符之后换行，但显示公式时总是在二元运算符之前换行”。</p><pre><code># 正确的例子：更容易匹配运算符与操作数
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)</code></pre><p>在Python代码中，只要在统一项目中约定一致，就可以在二元运算符之前或之后换行。对于新编写的代码，建议使用Knuth的风格。</p><h3 id="2-4-空行-Blank-Line"><a href="#2-4-空行-Blank-Line" class="headerlink" title="2.4 空行(Blank Line)"></a>2.4 空行(Blank Line)</h3><p>使用2个空行来分隔最外层的函数(function)和类(class)定义。</p><p>使用1个空行来分隔类中的方法(method)定义。</p><p>可以使用额外的空行（尽量少）来分隔一组相关的函数。在一系列相关的仅占一行的函数之间，空行也可以被省略（比如一组虚函数定义）。</p><p>在函数内使用空行（尽量少）使代码逻辑更清晰。</p><p>例子：</p><pre><code>def func():


    class A(object):
        pass

    def func1():
        a = A()

    def func2():
        print(&apos;aaa&apos;)
        print(&apos;bbb&apos;)</code></pre><p>Python支持control-L（如:^L）换页符作为空格；许多工具将这些符号作为分页符，因此你可以使用这些符号来分页或者区分文件中的相关区域。注意，一些编辑器和基于web的代码预览器可能不会将control-L识别为分页符，而是显示成其他符号。</p><h3 id="2-5-源文件编码-Source-File-Encoding"><a href="#2-5-源文件编码-Source-File-Encoding" class="headerlink" title="2.5 源文件编码(Source File Encoding)"></a>2.5 源文件编码(Source File Encoding)</h3><p>Python核心发行版中的代码应该一直使用UTF-8（Python 2中使用ASCII）。</p><p>使用ASCII（Python 2）或者UTF-8（Python 3）的文件不应该添加编码声明。</p><p>在标准库中，只有用作测试目的，或者注释或文档字符串需要提及作者名字而不得不使用非ASCII字符时，才能使用非默认的编码。否则，在字符串文字中包括非ASCII数据时，推荐使用\x, \u, \U或\N等转义符。</p><p>对于Python 3.0及其以后的版本中，标准库遵循以下原则（参见PEP 3131）：Python标准库中的所有标识符都必须只采用ASCII编码的标识符，在可行的条件下也应当使用英文词（很多情况下，使用的缩写和技术术语词都不是英文）。此外，字符串文字和注释应该只包括ASCII编码。只有两种例外：</p><p>(a) 测试情况下为了测试非ASCII编码的特性</p><p>(b) 作者名字。作者名字不是由拉丁字母组成的也必须提供一个拉丁音译名。</p><p>鼓励具有全球受众的开放源码项目采用类似的原则。</p><h3 id="2-6-模块引用-Imports"><a href="#2-6-模块引用-Imports" class="headerlink" title="2.6 模块引用(Imports)"></a>2.6 模块引用(Imports)</h3><p>Imports应该分行写，而不是都写在一行，例如：</p><pre><code># 分开写
import os
import sys

# 不要像下面一样写在一行
import sys, os</code></pre><p>这样写也是可以的：</p><pre><code>from subprocess import Popen, PIPE</code></pre><p>Imports应该写在代码文件的开头，位于模块(module)注释和文档字符串(docstring)之后，模块全局变量(globals)和常量(constants)声明之前。</p><p>Imports应该按照下面的顺序分组来写：</p><ol><li>标准库imports</li><li>相关第三方imports</li><li>本地应用/库的特定imports</li></ol><p>如：</p><pre><code>import re
from lxml import etree
from ak_spider.common.mongo_models import *
from ak_spider.settings import CAPTCHA_SERVER, AK_PROXY_SERVER, logger</code></pre><p>不同组的imports之前用空格隔开。</p><p>推荐使用绝对(absolute)imports，因为这样通常更易读，在import系统没有正确配置（比如中的路径以sys.path结束）的情况下，也会有更好的表现（或者至少会给出错误信息）：</p><pre><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre><p>然而，除了绝对imports，显式的相对imports也是一种可以接受的替代方式。特别是当处理复杂的包布局(package layouts)时，采用绝对imports会显得啰嗦。</p><pre><code>from . import sibling
from .sibling import example</code></pre><p>标准库代码应当一直使用绝对imports，避免复杂的包布局。</p><p>隐式的相对imports应该永不使用，并且Python 3中已经被去掉了</p><p>当从一个包括类的模块中import一个类时，通常可以这样写：</p><pre><code>from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre><p>如果和本地命名的拼写产生了冲突，应当直接import模块：</p><pre><code>import myclass
import foo.bar.yourclass</code></pre><p>然后使用”myclass.MyClass”和”foo.bar.yourclass.YourClass”。</p><p>避免使用通配符imports(from<module>import *)，因为会造成在当前命名空间出现的命名含义不清晰，给读者和许多自动化工具造成困扰。有一个可以正当使用通配符import的情形，即将一个内部接口重新发布成公共API的一部分（比如，使用备选的加速模块中的定义去覆盖纯Python实现的接口，预先无法知晓具体哪些定义将被覆盖）。</module></p><p>当使用这种方式重新发布命名时，指南后面关于公共和内部接口的部分仍然适用。</p><h3 id="2-7-模块级的双下划线命名-Module-level-dunder-names"><a href="#2-7-模块级的双下划线命名-Module-level-dunder-names" class="headerlink" title="2.7 模块级的双下划线命名(Module level dunder names)"></a>2.7 模块级的双下划线命名(Module level dunder names)</h3><p>模块中的“双下滑线”（变量名以两个下划线开头，两个下划线结尾）变量，比如<strong>all</strong>，<strong>author，</strong>version__等，应该写在文档字符串(docstring)之后，除了form <strong>future</strong>引用(imports)的任何其它类型的引用语句之前。Python要求模块中<strong>future</strong>的导入必须出现在除文档字符串(docstring)之外的任何其他代码之前。</p><p>例如：</p><pre><code>&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
__version__ = &apos;0.1&apos;
__author__ = &apos;Cardinal Biggles&apos;

import os
import sys</code></pre><h2 id="3-字符串引用-String-Quotes"><a href="#3-字符串引用-String-Quotes" class="headerlink" title="3 字符串引用(String Quotes)"></a>3 字符串引用(String Quotes)</h2><p>在Python中表示字符串时，不管用单引号还是双引号都是一样的。但是不推荐将这两种方式看作一样并且混用。最好选择一种规则并坚持使用。当字符串中包含单引号时，采用双引号来表示字符串，反之也是一样，这样可以避免使用反斜杠，代码也更易读。</p><p>对于三引号表示的字符串，使用双引号字符来表示(即用”””而不是’’’)。</p><h2 id="4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements"><a href="#4-表达式和语句中的空格-Whitespace-In-Expressions-And-Statements" class="headerlink" title="4 表达式和语句中的空格(Whitespace In Expressions And Statements)"></a>4 表达式和语句中的空格(Whitespace In Expressions And Statements)</h2><h3 id="4-1-一些痛点-Pet-Peeves"><a href="#4-1-一些痛点-Pet-Peeves" class="headerlink" title="4.1 一些痛点(Pet Peeves)"></a>4.1 一些痛点(Pet Peeves)</h3><p>在下列情形中避免使用过多的空白：</p><p>方括号，圆括号和花括号之后：</p><pre><code>#正确的例子:
spam(ham[1], {eggs: 2})

#错误的例子：
spam( ham[ 1 ], { eggs: 2 } )</code></pre><p>逗号，分号或冒号之前：</p><pre><code>#正确的例子:
if x == 4: print x, y; x, y = y, x

#错误的例子:
if x == 4 : print x , y ; x , y = y , x</code></pre><p>不过，在切片操作时，冒号和二元运算符是一样的，应该在其左右两边保留相同数量的空格（就像对待优先级最低的运算符一样）。在扩展切片操作中，所有冒号的左右两边空格数都应该相等。不过也有例外，当切片操作中的参数被省略时，应该也忽略空格。</p><pre><code>#正确的例子:
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]

#错误的例子:
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]</code></pre><p>在调用函数时传递参数list的括号之前：</p><pre><code>#正确的例子:
spam(1)

#错误的例子:
pam (1)</code></pre><p>在索引和切片操作的左括号之前：</p><pre><code>#正确的例子:
dct[&apos;key&apos;] = lst[index]

#错误的例子:
dct [&apos;key&apos;] = lst [index]</code></pre><p>赋值(或其他)运算符周围使用多个空格来和其他语句对齐：</p><pre><code>#正确的例子:
x = 1
y = 2
long_variable = 3

#错误的例子:
x             = 1
y             = 2
long_variable = 3</code></pre><h3 id="4-2-其他建议-Other-Recommendations"><a href="#4-2-其他建议-Other-Recommendations" class="headerlink" title="4.2 其他建议(Other Recommendations)"></a>4.2 其他建议(Other Recommendations)</h3><p>避免任何行末的空格。因为它通常是不可见的，它可能会令人困惑：例如反斜杠后跟空格和换行符不会作为续行标记。一些编辑器会自动去除行末空格，许多项目（如CPython本身）都有提交前的预处理钩子来自动去除行末空格。</p><p>在二元运算符的两边都使用一个空格：赋值运算符(=)，增量赋值运算符(+=, -= etc.)，比较运算符(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算符(and, or, not)。</p><p>如果使用了优先级不同的运算符，则在优先级较低的操作符周围增加空白。请你自行判断，不过永远不要用超过1个空格，永远保持二元运算符两侧的空白数量一样。</p><pre><code>#正确的例子:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

#错误的例子:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)    </code></pre><p>使用=符号来表示关键字参数或参数默认值时，不要在其周围使用空格。</p><pre><code>#正确的例子:
def complex(real, imag=0.0):
return magic(r=real, i=imag)

#错误的例子:
def complex(real, imag = 0.0):
return magic(r = real, i = imag)</code></pre><p>函数注解中的:也遵循一般的:加空格的规则，在-&gt;两侧各使用一个空格。</p><pre><code>#正确的例子:
def munge(input: AnyStr): ...
def munge() -&gt; AnyStr: ...

#错误的例子:
def munge(input:AnyStr): ...
def munge()-&gt;PosInt: ...</code></pre><p>在组合使用函数注解和参数默认值时，需要在=两侧各使用一个空格（只有当这个参数既有函数注解，又有默认值的时候）。</p><pre><code>#正确的例子:
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...

#错误的例子:
def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...</code></pre><p>复合语句（即将多行语句写在一行）一般是不鼓励使用的。</p><pre><code>#正确的例子:
if foo == &apos;blah&apos;:
do_blah_thing()
do_one()
do_two()
do_three()

#最好不要这样:
if foo == &apos;blah&apos;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre><p>有时也可以将短小的if/for/while中的语句写在一行，但对于有多个分句的语句永远不要这样做。也要避免将多行都写在一起。</p><pre><code>#最好不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
for x in lst: total += x
while t &lt; 10: t = delay()

#绝对不要这样：
if foo == &apos;blah&apos;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
list, like, this)

if foo == &apos;blah&apos;: one(); two(); three()</code></pre><h2 id="5-何时在末尾加逗号-When-to-use-trailing-commas"><a href="#5-何时在末尾加逗号-When-to-use-trailing-commas" class="headerlink" title="5 何时在末尾加逗号(When to use trailing commas)"></a>5 何时在末尾加逗号(When to use trailing commas)</h2><p>末尾逗号通常是可选的，除非在定义单元素元组(tuple)时是必需的（而且在Python 2中，它们具有print语句的语义）。为了清楚起见，建议使用括号（技术上来说是冗余的）括起来。</p><pre><code>#正确的例子:
FILES = (&apos;setup.cfg&apos;,)

#也正确，但令人困惑:
FILES = &apos;setup.cfg&apos;,</code></pre><p>当使用版本控制系统时，在将来有可能扩展的列表末尾添加冗余的逗号是有好处的。具体的做法是将每一个元素写在单独的一行，并在行尾添加逗号，右括号单独占一行。但是，与有括号在同一行的末尾元素后面加逗号是没有意义的（上述的单元素元组除外）。</p><pre><code>#正确的例子:
FILES = [
    &apos;setup.cfg&apos;,
    &apos;tox.ini&apos;,
    ]
initialize(FILES,
           error=True,
           )

#错误的例子:
FILES = [&apos;setup.cfg&apos;, &apos;tox.ini&apos;,]
initialize(FILES, error=True,)</code></pre><h2 id="6-注释-Comments"><a href="#6-注释-Comments" class="headerlink" title="6 注释(Comments)"></a>6 注释(Comments)</h2><p>和代码矛盾的注释还不如没有。当代码有改动时，一定要优先更改注释使其保持最新。</p><p>注释应该是完整的多个句子。如果注释是一个短语或一个句子，其首字母应该大写，除非开头是一个以小写字母开头的标识符（永远不要更改标识符的大小写）。</p><p>如果注释很短，结束的句号可以被忽略。块注释通常由一段或几段完整的句子组成，每个句子都应该以句号结束。</p><p>你应该在句尾的句号后再加上2个空格。</p><p>使用英文写作，参考Strunk和White的《The Elements of Style》</p><p>来自非英语国家的Python程序员们，请使用英文来写注释，除非你120%确定你的代码永远不会被不懂你所用语言的人阅读到。</p><h3 id="6-1-块注释（Block-Comments）"><a href="#6-1-块注释（Block-Comments）" class="headerlink" title="6.1 块注释（Block Comments）"></a>6.1 块注释（Block Comments）</h3><p>块注释一般写在对应代码之前，并且和对应代码有同样的缩进级别。块注释的每一行都应该以#和一个空格开头（除非该文本是在注释内缩进对齐的）。</p><p>块注释中的段落应该用只含有单个#的一行隔开。</p><h3 id="6-2-行内注释（Inline-Comments）"><a href="#6-2-行内注释（Inline-Comments）" class="headerlink" title="6.2 行内注释（Inline Comments）"></a>6.2 行内注释（Inline Comments）</h3><p>尽量少用行内注释。</p><p>行内注释是和代码语句写在一行内的注释。行内注释应该至少和代码语句之间有两个空格的间隔，并且以#和一个空格开始。</p><p>行内注释通常不是必要的，在代码含义很明显时甚至会让人分心。请不要这样做：</p><pre><code>x = x + 1                 # x自加</code></pre><p>但这样做是有用的：</p><pre><code>x = x + 1                 # 边界补偿</code></pre><h3 id="6-3-文档字符串-Documentation-Strings"><a href="#6-3-文档字符串-Documentation-Strings" class="headerlink" title="6.3 文档字符串(Documentation Strings)"></a>6.3 文档字符串(Documentation Strings)</h3><p>要知道如何写出好的文档字符串（docstring），请参考PEP 257</p><p>所有的公共模块，函数，类和方法都应该有文档字符串。对于非公共方法，文档字符串不是必要的，但你应该留有注释说明该方法的功能，该注释应当出现在def的下一行。</p><p>PEP 257描述了好的文档字符应该遵循的规则。其中最重要的是，多行文档字符串以单行”””结尾，不能有其他字符，例如：</p><pre><code>&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre><p>对于仅有一行的文档字符串，结尾处的”””应该也写在这一行。</p><h2 id="7-命名约定（Naming-Conventions）"><a href="#7-命名约定（Naming-Conventions）" class="headerlink" title="7 命名约定（Naming Conventions）"></a>7 命名约定（Naming Conventions）</h2><p>Python标准库的命名约定有一些混乱，因此我们永远都无法保持一致。但如今仍然存在一些推荐的命名标准。新的模块和包（包括第三方框架）应该采用这些标准，但若是已经存在的包有另一套风格的话，还是应当与原有的风格保持内部一致。</p><h3 id="7-1-首要原则（Overriding-Principle）"><a href="#7-1-首要原则（Overriding-Principle）" class="headerlink" title="7.1 首要原则（Overriding Principle）"></a>7.1 首要原则（Overriding Principle）</h3><p>对于用户可见的公共部分API，其命名应当表达出功能用途而不是其具体的实现细节。</p><h3 id="7-2-描述：命名风格（Descriptive-Naming-Styles）"><a href="#7-2-描述：命名风格（Descriptive-Naming-Styles）" class="headerlink" title="7.2 描述：命名风格（Descriptive: Naming Styles）"></a>7.2 描述：命名风格（Descriptive: Naming Styles）</h3><p>存在很多不同的命名风格，最好能够独立地从命名对象的用途认出采用了哪种命名风格。</p><p>通常区分以下命名样式：</p><ul><li>b (单个小写字母)</li><li>B (单个大写字母)</li><li>lowercase(小写)</li><li>lower_case_with_underscores(带下划线小写)</li><li>UPPERCASE(大写)</li><li>UPPER_CASE_WITH_UNDERSCORES(带下划线大写)</li><li>CapitalizedWords (也叫做CapWords或者CamelCase – 因为单词首字母大写看起来很像驼峰)。也被称作StudlyCaps。注意：当CapWords里包含缩写时，将缩写部分的字母都大写。HTTPServerError比HttpServerError要好。</li><li>mixedCase (注意：和CapitalizedWords不同在于其首字母小写！)</li><li>Capitalized_Words_With_Underscores (这种风格超丑！)</li></ul><p>也有风格使用简短唯一的前缀来表示一组相关的命名。这在Python中并不常见，但为了完整起见这里也捎带提一下。比如，os.stat()函数返回一个tuple，其中的元素名原本为st_mode,st-size,st_mtime等等。（这样做是为了强调和POSIX系统调用结构之间的关系，可以让程序员更熟悉。）</p><p>X11库中的公共函数名都以X开头。在Python中这样的风格一般被认为是不必要的，因为属性和方法名之前已经有了对象名的前缀，而函数名前也有了模块名的前缀。</p><p>此外，要区别以下划线开始或结尾的特殊形式（可以和其它的规则结合起来）：</p><p>_single_leading_underscore: 以单个下划线开头是”内部使用”的弱标志。 比如， from M import *不会import下划线开头的对象。</p><p>single_trailing_underscore_: 以单个下划线结尾用来避免和Python关键词产生冲突，例如:</p><pre><code>Tkinter.Toplevel(master, class_=&apos;ClassName&apos;)</code></pre><p><strong>double_leading_underscore: 以双下划线开头的风格命名类属性表示触发命名修饰（在FooBar类中，</strong>boo命名会被修饰成_FooBar__boo;）。</p><h3 id="7-3-规范：命名约定-Prescriptive-Naming-Conventions"><a href="#7-3-规范：命名约定-Prescriptive-Naming-Conventions" class="headerlink" title="7.3 规范：命名约定(Prescriptive: Naming Conventions)"></a>7.3 规范：命名约定(Prescriptive: Naming Conventions)</h3><h4 id="7-3-1-需要避免的命名-Names-To-Avoid"><a href="#7-3-1-需要避免的命名-Names-To-Avoid" class="headerlink" title="7.3.1 需要避免的命名(Names To Avoid)"></a>7.3.1 需要避免的命名(Names To Avoid)</h4><p>不要使用字符’l’（L的小写的字母），’O’（o大写的字母），或者’I’（i的大写的字母）来作为单个字符的变量名。</p><p>在一些字体中，这些字符和数字1和0无法区别开来。比如，当想使用’l’时，使用’L’代替。</p><h4 id="7-3-2-ASCII兼容性-ASCII-Compatibility"><a href="#7-3-2-ASCII兼容性-ASCII-Compatibility" class="headerlink" title="7.3.2 ASCII兼容性(ASCII Compatibility)"></a>7.3.2 ASCII兼容性(ASCII Compatibility)</h4><p>标准库中使用的标识符必须与ASCII兼容(参见PEP 3131中的<a href="https://www.python.org/dev/peps/pep-3131/#policy-specification" target="_blank" rel="noopener">policy</a>这一节) 。</p><h4 id="7-3-3-包和模块命名-Package-And-Module-Names"><a href="#7-3-3-包和模块命名-Package-And-Module-Names" class="headerlink" title="7.3.3 包和模块命名(Package And Module Names)"></a>7.3.3 包和模块命名(Package And Module Names)</h4><p>模块命名应短小，且为全小写。若下划线能提高可读性，也可以在模块名中使用。Python包命名也应该短小，且为全小写，但不应使用下划线。</p><p>当使用C或C++写的扩展模块有相应的Python模块提供更高级的接口时（比如，更加面向对象），C/C++模块名以下划线开头（例如，_sociket）</p><h4 id="7-3-4-类命名-Class-Names"><a href="#7-3-4-类命名-Class-Names" class="headerlink" title="7.3.4 类命名(Class Names)"></a>7.3.4 类命名(Class Names)</h4><p>类命名应该使用驼峰（CapWords）的命名约定。</p><p>当接口已有文档说明且主要是被用作调用时，也可以使用函数的命名约定。</p><p>注意对于内建命名(builtin names)有一个特殊的约定：大部分内建名都是一个单词（或者两个一起使用的单词），驼峰(CapWords)的约定只对异常命名和内建常量使用。</p><h4 id="7-3-5-类型变量命名-Type-variable-names"><a href="#7-3-5-类型变量命名-Type-variable-names" class="headerlink" title="7.3.5 类型变量命名(Type variable names)"></a>7.3.5 类型变量命名(Type variable names)</h4><p>PEP 484中引入的类型变量名称通常应使用简短的驼峰命名: T，AnyStr，Num。 建议将后缀_co或_contra添加到用于声明相应的协变(covariant)和逆变(contravariant)的行为。例如：</p><pre><code>from typing import TypeVar

VT_co = TypeVar(&apos;VT_co&apos;, covariant=True)
KT_contra = TypeVar(&apos;KT_contra&apos;, contravariant=True)</code></pre><h4 id="7-3-6-异常命名-Exception-Names"><a href="#7-3-6-异常命名-Exception-Names" class="headerlink" title="7.3.6 异常命名(Exception Names)"></a>7.3.6 异常命名(Exception Names)</h4><p>由于异常实际上也是类，因此类命名约定也适用与异常。不同的是，如果异常实际上是抛出错误的话，异常名前应该加上”Error”的前缀。</p><h4 id="7-3-7-全局变量命名-Global-Variable-Names"><a href="#7-3-7-全局变量命名-Global-Variable-Names" class="headerlink" title="7.3.7 全局变量命名(Global Variable Names)"></a>7.3.7 全局变量命名(Global Variable Names)</h4><p>（在此之前，我们先假定这些变量都仅在同一个模块内使用。）这些约定同样也适用于函数命名。</p><p>对于引用方式设计为from M import *的模块，应该使用<strong>all</strong>机制来避免import全局变量，或者采用下划线前缀的旧约定来命名全局变量，从而表明这些变量是“模块非公开的”。</p><h4 id="7-3-8-函数命名-Function-Names"><a href="#7-3-8-函数命名-Function-Names" class="headerlink" title="7.3.8 函数命名(Function Names)"></a>7.3.8 函数命名(Function Names)</h4><p>函数命名应该都是小写，必要时使用下划线来提高可读性。</p><p>只有当已有代码风格已经是混合大小写时（比如threading.py），为了保留向后兼容性才使用混合大小写。</p><h4 id="7-3-9-函数和方法参数-Function-And-Method-Arguments"><a href="#7-3-9-函数和方法参数-Function-And-Method-Arguments" class="headerlink" title="7.3.9 函数和方法参数(Function And Method Arguments)"></a>7.3.9 函数和方法参数(Function And Method Arguments)</h4><p>实例方法的第一参数永远都是self。</p><p>类方法的第一个参数永远都是cls。</p><p>在函数参数名和保留关键字冲突时，相对于使用缩写或拼写简化，使用以下划线结尾的命名一般更好。比如，class_比clss更好。（或许使用同义词避免这样的冲突是更好的方式。）</p><h4 id="7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables"><a href="#7-3-10-方法命名和实例变量-Method-Names-And-Instance-Variables" class="headerlink" title="7.3.10 方法命名和实例变量(Method Names And Instance Variables)"></a>7.3.10 方法命名和实例变量(Method Names And Instance Variables)</h4><p>使用函数命名的规则：小写单词，必要时使用下划线分开以提高可读性。</p><p>仅对于非公开方法和变量命名在开头使用一个下划线。</p><p>避免和子类的命名冲突，使用两个下划线开头来触发Python的命名修饰机制。</p><p>Python类名的命名修饰规则：如果类Foo有一个属性叫<strong>a，不能使用Foo.</strong>a的方式访问该变量。（有用户可能仍然坚持使用Foo._Foo__a的方法访问。）一般来说，两个下划线开头的命名方法仅用于避免与设计为子类的类中的属性名冲突。</p><h4 id="7-3-11-常量-Constants"><a href="#7-3-11-常量-Constants" class="headerlink" title="7.3.11 常量(Constants)"></a>7.3.11 常量(Constants)</h4><p>常量通常是在模块级别定义的，使用全部大写并用下划线将单词分开。如：MAX_OVERFLOW和TOTAL 。</p><h4 id="7-3-12-继承的设计-Designing-For-Inheritance"><a href="#7-3-12-继承的设计-Designing-For-Inheritance" class="headerlink" title="7.3.12 继承的设计(Designing For Inheritance)"></a>7.3.12 继承的设计(Designing For Inheritance)</h4><p>记得永远区别类的方法和实例变量（属性）应该是公开的还是非公开的。如果有疑虑的话，请选择非公开的；因为之后将非公开属性变为公开属性要容易些。</p><p>公开属性是那些你希望和你定义的类无关的客户来使用的，并且确保不会出现向后不兼容的问题。非公开属性是那些不希望被第三方使用的部分，你可以不用保证非公开属性不会变化或被移除。</p><p>我们在这里没有使用“私有（private）”这个词，因为在Python里没有什么属性是真正私有的（这样设计省略了大量不必要的工作）。</p><p>另一类属性属于子类API的一部分（在其他语言中经常被称为”protected”）。一些类是为继承设计的，要么扩展要么修改类的部分行为。当设计这样的类时，需要谨慎明确地决定哪些属性是公开的，哪些属于子类API，哪些真的只会被你的基类调用。</p><p>请记住以上几点，下面是Python风格的指南：</p><ul><li>公开属性不应该有开头下划线。</li><li>如果公开属性的名字和保留关键字有冲突，在你的属性名尾部加上一个下划线。这比采用缩写和简写更好。（然而，和这条规则冲突的是，‘cls’对任何变量和参数来说都是一个更好地拼写，因为大家都知道这表示class，特别是在类方法的第一个参数里。）</li><li>对于简单的公共数据属性，最后仅公开属性名字，不要公开复杂的调用或设值方法。请记住，如果你发现一个简单的数据属性需要增加功能行为时，Python为功能增强提供了一个简单的途径。这种情况下，使用Properties注解将功能实现隐藏在简单数据属性访问语法之后。注意 1：Properties注解仅仅对新风格类有用。<br>注意 2：尽量保证功能行为没有副作用，尽管缓存这种副作用看上去并没有什么大问题。<br>注意 3: 对计算量大的运算避免试用properties；属性的注解会让调用者相信访问的运算量是相对较小的。</li><li>如果你的类将被子类继承的话，你有一些属性并不想让子类访问，考虑将他们命名为两个下划线开头并且结尾处没有下划线。这样会触发Python命名修饰算法，类名会被修饰添加到属性名中。这样可以避免属性命名冲突，以免子类会不经意间包含相同的命名。注意 1：注意命名修饰仅仅是简单地将类名加入到修饰名中，所以如果子类有相同的类名合属性名，你可能仍然会遇到命名冲突问题。<br>注意 2：命名修饰可以有特定用途，比如在调试时，__getattr__()比较不方便。然而命名修饰算法的可以很好地记录，并且容意手动执行。<br>注意 3：不是所有人都喜欢命名修饰。需要试着去平衡避免偶然命名冲突的需求和高级调用者使用的潜在可能性。</li></ul><h3 id="7-4-公开和内部接口-Public-And-Internal-Interfaces"><a href="#7-4-公开和内部接口-Public-And-Internal-Interfaces" class="headerlink" title="7.4 公开和内部接口(Public And Internal Interfaces)"></a>7.4 公开和内部接口(Public And Internal Interfaces)</h3><p>任何向后兼容性保证仅对公开接口适用。相应地，用户能够清楚分辨公开接口和内部接口是很重要的。</p><p>文档化的接口被认为是公开的，除非文档中明确申明了它们是临时的或者内部接口，不保证向后兼容性。所有文档中未提到的接口应该被认为是内部的。</p><p>为了更好审视公开接口和内部接口，模块应该在<strong>all属性中明确申明公开API是哪些。将</strong>all__设为空list表示该模块中没有公开API。</p><p>即使正确设置了__all属性，内部接口（包，模块，类，函数，属性或其他命名）也应该以一个下划线开头。</p><p>如果接口的任一一个命名空间（包，模块或类）是内部的，那么该接口也应该是内部的</p><p>引用的命名应该永远被认为是实现细节。其他模块不应当依赖这些非直接访问的引用命名，除非它们在文档中明确地被写为模块的API，例如os.path或者包的<strong>init</strong>模块，那些从子模块展现的功能。</p><h2 id="8-编程建议-Programming-Recommendations"><a href="#8-编程建议-Programming-Recommendations" class="headerlink" title="8 编程建议(Programming Recommendations)"></a>8 编程建议(Programming Recommendations)</h2><p>1 代码应该以不影响其他Python实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。</p><p>例如，不要依赖于 CPython 在字符串拼接时的优化实现，像这种语句形式a += b和a = a + b。即使是 CPython（仅对某些类型起作用） 这种优化也是脆弱的，不是在所有的实现中都不使用引用计数。在库中性能敏感的部分，用’’.join形式来代替。这会确保在所有不同的实现中字符串拼接是线性时间的。</p><p>2 与单例作比较，像None应该用is或is not，从不使用==操作符。</p><p>同样的，当心if x is not None这样的写法，你是不知真的要判断x不是None。例如，测试一个默认值为None的变量或参数是否设置成了其它值，其它值有可能是某种特殊类型（如容器），这种特殊类型在逻辑运算时其值会被当作Flase来看待。</p><p>用is not操作符而不是not … is。虽然这两个表达式是功能相同的，前一个是更可读的，是首选。</p><p>推荐的写法:</p><pre><code>if foo is not None:</code></pre><p>不推荐的写法:</p><pre><code>if not foo is None:</code></pre><p>3 用富比较实现排序操作的时候，最好实现所有六个比较操作符（ __eq__ 、 __ne__ 、 __lt__ , __le__ , __gt__ , __ge__），而不是依靠其他代码来进行特定比较。</p><p>为了最大限度的减少工作量，functools.total_ordering()装饰器提供了一个工具去生成缺少的比较方法。</p><p>PEP 207 说明了 Python 假定的所有反射规则。因此，解释器可能使用y &gt; x替换x &lt; y，使用y &gt;= x替换x &lt;= y，也可能交换x == y和x != y的操作数。sort()和min()操作肯定会使用&lt;操作符，max()函数肯定会使用&gt;操作符。当然，最好是六个操作符都实现，以便在其他情况下不会出现混淆。</p><p>4 始终使用def语句来代替直接绑定了一个lambda表达式的赋值语句。</p><p>推荐的写法:</p><pre><code>def f(x): return 2*x</code></pre><p>不推荐的写法:</p><pre><code>f = lambda x: 2*x</code></pre><p>第一个表单意味着生成的函数对象的名称是’f’而不是通用的’<lambda>‘。通常这对异常追踪和字符串表述是更有用的。使用赋值语句消除了使用lambda表达式可以提供，而一个显式的def语句不能提供的唯一好处，如，lambda能镶嵌在一个很长的表达式里。</lambda></p><p>5 异常类应派生自Exception而不是BaseException。直接继承BaseException是为Exception保留的，从BaseException继承并捕获异常这种做法几乎总是错的。</p><p>设计异常的层次结构，应基于那些可能出现异常的代码，而不是引发异常的位置。编码的时候，以回答“出了什么问题？”为目标，而不是仅仅指出“这里出现了问题”（见 PEP 3151 一个内建异常结构层次的例子）。</p><p>类的命名约定适用于异常，如果异常类是一个错误，你应该给异常类加一个后缀Error。用于非本地流程控制或者其他形式的信号的非错误异常不需要一个特殊的后缀。</p><p>6 适当的使用异常链。在 Python 3 里，应该使用raise X from Y来指示显式替换，而不会丢失原始的追溯。</p><p>当有意替换一个内部的异常时（在 Python 2 用raise X，Python 3.3+ 用raise X from None），请确保将相关详细信息转移到新异常中（例如，将KeyError转换为AttributeError时保留属性名称，或将原始异常的文本嵌入到新的异常消息中）。</p><p>7 在 Python 2 里抛出异常时，用raise ValueError(‘message’)代替旧式的raise ValueError, ‘message’。</p><p>在 Python 3 之后的语法里，旧式的异常抛出方式是非法的。</p><p>使用括号形式的异常意味着，当你传给异常的参数过长或者包含字符串格式化时，你就不需要使用续行符了，这要感谢括号！</p><p>8 捕获异常时，尽可能使用明确的异常，而不是用一个空的except:语句。</p><p>例如，用：</p><pre><code>try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre><p>一个空的except:语句将会捕获到SystemExit和KeyboardInterrupt异常，很难区分程序的中断到底是Ctrl+C还是其他问题引起的。如果你想捕获程序的所有错误，使用except Exception:(空except:等同于except BaseException)。</p><p>一个好的经验是限制使用空except语句，除了这两种情况：</p><ul><li>如果异常处理程序会打印出或者记录回溯信息；至少用户意识到错误的存在。</li><li>如果代码需要做一些清理工作，但后面用raise向上抛出异常。try .. finally是处理这种情况更好的方式。</li></ul><p>9 绑定异常给一个名字时，最好使用 Python 2.6 里添加的明确的名字绑定语法：</p><pre><code>try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre><p>Python 3 只支持这种语法，避免与基于逗号的旧式语法产生二义性。</p><p>10 捕获操作系统错误时，最好使用 Python 3.3 里引进的明确的异常结构层次，而不是内省的errno值。</p><p>11 另外，对于所有try / except子句，将try子句限制为必需的绝对最小代码量。同样，这样可以避免屏蔽错误。</p><p>推荐的写法：</p><pre><code>try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)</code></pre><p>不推荐的写法：</p><pre><code>try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre><p>12 当某个资源仅被特定代码段使用，用with语句确保其在使用后被立即干净的清除了，try/finally也是也接受的。</p><p>13 当它们做一些除了获取和释放资源之外的事的时候，上下文管理器应该通过单独的函数或方法调用。例如：</p><p>推荐的写法:</p><pre><code>with conn.begin_transaction():
    do_stuff_in_transaction(conn)</code></pre><p>不推荐的写法：</p><pre><code>with conn:
    do_stuff_in_transaction(conn)</code></pre><p>第二个例子没有提供任何信息来表明<strong>enter</strong>和<strong>exit</strong>方法在完成一个事务后做了一些除了关闭连接以外的其它事。在这种情况下明确是很重要的。</p><p>14 坚持使用return语句。函数内的return语句都应该返回一个表达式，或者None。如果一个return语句返回一个表达式，另一个没有返回值的应该用return None清晰的说明，并且在一个函数的结尾应该明确使用一个return语句（如果有返回值的话）。</p><p>推荐的写法：</p><pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x &lt; 0:
        return None
    return math.sqrt(x)</code></pre><p>不推荐的写法：</p><pre><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)

def bar(x):
    if x &lt; 0:
        return
    return math.sqrt(x)</code></pre><p>15 用字符串方法代替字符串模块。</p><p>字符串方法总是快得多，并且与unicode字符串共享相同的API。如果需要与2.0以下的Python的向后兼容，则覆盖此规则。</p><p>16 用’’.startswith()和’’.endswith()代替字符串切片来检查前缀和后缀。</p><p>startswith()和endswith()是更简洁的，不容易出错的。例如：</p><pre><code>#推荐的写法：
if foo.startswith(&apos;bar&apos;):

#不推荐的写法：
if foo[:3] == &apos;bar&apos;:</code></pre><p>17 对象类型的比较应该始终使用isinstance()而不是直接比较。</p><pre><code>#推荐的写法：
if isinstance(obj, int):

#不推荐的写法：
if type(obj) is type(1):</code></pre><p>当比较一个对象是不是字符串时，记住它有可能也是一个 unicode 字符串！在 Python 2 里面，str和unicode有一个公共的基类叫basestring，因此你可以这样做：</p><pre><code>if isinstance(obj, basestring):</code></pre><p>注意，在 Python 3 里面，unicode和basestring已经不存在了（只有str），byte对象不再是字符串的一种（被一个整数序列替代）。</p><p>18 对于序列（字符串、列表、元组）来说，空的序列为False：</p><p>正确的写法：</p><pre><code>if not seq:
if seq:</code></pre><p>错误的写法：</p><pre><code>if len(seq):
if not len(seq):</code></pre><p>19 不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，一些编辑器（或者，reindent.py）会将其裁剪掉。</p><p>20 不要用==比较True和False。</p><pre><code>#推荐的写法：
if greeting:

#不推荐的写法：
if greeting == True:

#更加不推荐的写法：
if greeting is True:</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
</search>
