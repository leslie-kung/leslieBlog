---
title: 进程线程协程
type: categories
copyright: true
date: 2022-03-03 13:52:27
tags:
    - python
categories: [python, 基础]
keywords: [进程, 线程, 协程]
top: 80
---

<script type="text/javascript" src="/js/src/bai.js"></script>


## 多任务的概念
多任务就是操作系统同时运行多个任务。
- 并发：指的是任务数多余CPU核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换的速度相当快，看上去一起执行而已）
- 并行：指的是任务数小于等于CPU核数，即任务真的是一起执行的

<!-- more -->

## 多线程
线程就是程序中代码的一个执行分支，默认只有一个代码执行分支，也就说是主线程，开辟多个线程好比开辟多个代码的执行分支，能够完成多个任务一起值。 线程是cpu调度的基本单位。

- 线程的使用 导入threading模块
- 多线程执行顺序是无序的
- 主线程会等待所有子线程执行完成以后程序再退出
```python
# 创建线程
    xxx = threading.Thread(target=yyy)
# 设置守护主线程，主线程退出后，子线程直接销毁
    xxx.setDaemon(True)
# 线程的启动
    xxx.start()
```
1.每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。

2.无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。

3.在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据

4.缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）


## 互斥锁
某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。

互斥锁为资源引入了一个状态：锁定/非锁定
```python
# 创建锁
mutex = threading.Lock()
# 锁定
mutex.acquire()
# 释放
mutex.release()
```
如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止

锁的好处：
- 确保了某段关键代码只能有一个线程从头到尾完整地执行

锁的坏处：
- 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
- 由于可以存在多个锁，不同的线程有不同的锁，并试图获取对方持有的锁时，可能会造成死锁

避免死锁
- 程序设计时要尽量避免（银行家算法）
- 添加超时时间等

## 多进程
程序：是一个静止的

进程：一个程序运行起来后，代码+用到的资源称之为进程，她是操作系统分配资源的基本单位。

进程的状态：
- 就绪态 ： 运行的条件都已经慢去，正在等待CPU执行
- 执行态 ： CPU正在执行其功能
- 等待态 ： 等待某些条件满足，例如一个程序sleep了，此时就是等待态了

通俗来说一个运行起来的软件或者程序叫做进程，每启动一个进程都会向操作系统索要运行资源，所以进程是操作系统资源分配的基本单位，进程只提供资源，真正干活的是进程中的线程。

你可以把进程想成公司（提供资源），员工可以想成线程（真正干活的人）。线程是依附在进程里面的，没有进程就没有线程，默认请求下一个进程只有一个线程（主线程）。

进程之间不共享全局变量

#### 进程和线程对比
- 进程：一个运行起来的程序或者软件就叫做进程，没启动一个进程都会想操作系统索要运行资源，进程只提供资源，真正干活的是线程，进程是操作系统资源分配的基本单位，进程可以理解成公司（公司提供资源）
- 线程：线程是运行程序中（进程）执行分支，默认情况下进程中只有一个线程（主线程），多个分支可以完成多个任务一起执行。 线程是cup调度基本单位
- 进程之间不共享全局变量， 线程之间共享全局变量

- 多进程开发比多线程开发的程序稳定性和健壮性要强，因为某个进程挂掉不会影响其它进程的运行，如果是多线程模式开发，进程挂掉，进程中所有的线程都会消耗

#### 消息队列queue
初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；

    Queue.qsize()：返回当前队列包含的消息数量；

    Queue.empty()：如果队列为空，返回True，反之False ；

    Queue.full()：如果队列满了，返回True,反之False；

Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；
- 如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出"Queue.Empty"异常；

- 如果block值为False，消息列队如果为空，则会立刻抛出"Queue.Empty"异常；
- Queue.get_nowait()：相当Queue.get(False)；

Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；
- 如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出"Queue.Full"异常；

- 如果block值为False，消息列队如果没有空间可写入，则会立刻抛出"Queue.Full"异常；
- Queue.put_nowait(item)：相当Queue.put(item, False)；
    
导入消息队列
```python
from multiprocessing import Queue
# 初始化一个Queue对象
queue = Queue() 里面参数为空代表没有上限
```

进程池pool
```python
# 导入进程池
from multiprocessing import Pool
# 创建进程池
po = Pool(5)  参数5表示最大进程数为5
```
            
multiprocessing.Pool常用函数解析：
- apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
- close()：关闭Pool，使其不再接受新的任务；
- terminate()：不管任务是否完成，立即终止；
- join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；
- 如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()

## 协程

协程: 

又称为微线程，也是用户基线程，可以在不开劈线程的基础上完成多个任务交替值，程序员可以控制执行顺序

如何理解: 

如果在函数里面只看一个yield关键字，那么可以理解程是协程

学习协程的目的:
 
在单线程的基础上完成多个任务，可以使用这个协程，多个任务一定是交替执行的

gevent的使用：
```python
import gevent
# 打补丁
from gevent import monkey
# 打补丁， 让gevent能够失败系统的耗时操作，完成协程之间自动进行切换
# 提示： 打补丁的代码一定要先执行
# 提示： gevent封装的greenlet框架
monkey.patch_all()
# 创建协程指派对应的任务
g1 = gevent.spawn(work1)
g2 = gevent.spawn(work2)
# 主线程不会等待所有的协程把任务执行完成以后程序在退出。
# 等待协程把任务执行完成以后程序在退出
g1.join()
g2.join()
```

## 迭代器
迭代器是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，知道所有元素被访问完结束。迭代器只能往前不能后退。

可迭代对象有：

列表、字典、元组、字符串、集合、range、
        
判断是否是可迭代对象：
```python
result = isinstance（object, Iterable）
```
自定义可迭代对象
```python
from collections import Iterable , Iterator 
```   
在类里面提供__iter__和__next__方法创建的对象就是迭代器，迭代器记录当前遍历位置及获取下一个位置的值。


## 生成器
生成器就是一种特殊的迭代器

生成器的创建方式：
- 和列表生成式类似，只不过把列表的[ ]改成了( )
```python
g1 = (x*3 for x in range(3))
```
- 函数里面如果存在yield关键字，那么就表示是一个生成器
启动生成器的时候如果有代码执行遇到yield那么代码会暂停，下次在启动生成器的时候会在暂停的位置上继续往下执行

 生成器中使用return关键字语法上没有问题
 在生成器执行完return操作，就会停止迭代，跑着停止迭代异常

- return关键字： 只能返回一次结果
- yield关键字：代码执行到yield会暂停，再次启动生成器会继续往下执行，每启动一次生成器都会返回一个值，yield会返回多个值

使用send方法可以给生成器传入参数

第一个启动生成器一般都是用next函数，如果使用send方法启动生成器需要传入参数会None，再次启动生成器可以传入非空的数据可以不是None

## 全局解释器锁(GIL)
作用：保证用一时刻只有一个线程可以执行代码

Python中的多线程是假的

原因：

Python的解释器由c写的cpython，而cpython中就存在GIL
python解释器：cpython    jpython    pypython

解决的办法：
- 更换解释器，比如使用jpython解释器
- 使用多进程来完成多任务的操作

在程序当中，如果需要大量消耗内存的，比如进行科学计算时，使用多进程要比多线程快；在进行IO操作（中间有时间阻塞的操作）时，多线程要比多进程快。

