---
title: python之copy
type: categories
copyright: true
tags:
  - python
  - 基础
categories:
  - python
  - 基础
abbrlink: 2800827854
date: 2020-01-02 10:37:05
---

## Python中的引用、浅拷贝和深拷贝
在python中，有一句话：*一切皆为对象，一切皆为对象的引用*，所以
只要记住这句话就很容易清楚python中的引用、浅拷贝和深拷贝了。

### 1、引用
python中的引用是经常使用的，python的引用可以节省内存，加快速度，因为它不需要开辟内存空间。例如：
<!--more-->
```python
a = 1
b = 1
```
这表示让 a 这个变量去指向一个地址，这个地址保存着数据为 1，让变量 b 也去指向这个地址，那么通过 b 我们一样可以找到数据 1，通过地址的指向来
来查找到数据，这就是python中的引用；


### 2、浅拷贝
浅拷贝 copy.copy()
浅拷贝保存的是数据的地址，不保存内容，浅拷贝是需要开辟单独的内存空间来存储地址的，它不能保证
数据的独立性。例如：
```python
a = [1, 2, 3]
b = copy.copy(a)
# a 的值[1, 2, 3]
# b 的值[1, 2, 3]
id(a)  # 1397274473
id(b)  # 1397274545
```
可以看出 b 的数据和 a 的数据一样，但是 b 的地址和 a 的地址不相同，而且 b 的地址里保存的是列表里元素 1， 2， 3 的地址，b 通过保存的地址信息来获取数据1, 2, 3 可以通过下面的例子得出：
```python
id(a)  # 1397274473
id(b)  # 1397274545
id(a[0])  # 20705624
id(b[0])  # 20705624
a[0] = 8
id(a[0])  # 20705456
id(b[0])  # 20705624
```
可以看出列表a 和列表 b 里面的元素 1 都指向着同一个地址，当列表 a 的第一个元素的值变为8时，即指向一个新的保存数据为 8 的地址时，列表b 的第一个元素仍然保存的是元素 1 的地址，此时可以看出，浅拷贝只是把数据的地址保存了，并没有保存数据本身，当列表中如果有元素为可变的列表或字典类时，因为拷贝的是列表或字典所对应的地址，如果列表或字典中有元素发生改变，则浅拷贝的列表也会跟着改变，不能保证数据的独立性：
```python
c = [1, 2, [3, 4]]
d = copy.copy(c)
# c=[1, 2, [3, 4]]
# d=[1, 2, [3, 4]]
id(c)  # 13972747060
id(d)  # 13972745446
id(c[2][0])  # 20705576
id(d[2][0])  # 20705576

c[2].append(5)
# c=[1, 2, [3, 4, 5]]
id(c)  # 13972747060
d # d=[1, 2, [3, 4, 5]]
id(d)  # 13972745446
```
```python
a = [1, 2]
b = copy.copy(a)
a.append(3)
a # [1, 2, 3]
b # [1, 2]
```

### 3、深拷贝
深拷贝copy.deepcopy()
python中，深拷贝在浅拷贝的基础上更进一步，深拷贝保存的是数据的本身，一旦进行深拷贝，则拷贝后的内容不仅和原本的内容完全一样，而且跟原来的没有任何联系，充分保证了数据的独立性。
深拷贝相当于在内存中开辟了一片新的内存，不再用来保存数据的地址，而是用新的地址来保存相同的数据。
```python
a = [1, 2, [3, 4]]
b = copy.deepcopy(a)

a  # [1, 2, [3, 4]]
b  # [1, 2, [3, 4]]

a[2].append(5)
a  # [1, 2, [3, 4, 5]]
b  # [1, 2, [3, 4]]
```
可以看出深拷贝是把列表里的数据保存了，和浅拷贝不同，当列表 a 发生改变时，列表 b 并不会跟着改变，这样充分体现了深拷贝可以保证数据的独立性。
